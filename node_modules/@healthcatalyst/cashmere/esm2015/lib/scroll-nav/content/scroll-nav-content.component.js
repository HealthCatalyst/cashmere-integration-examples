/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/content/scroll-nav-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewEncapsulation, Input, ViewChild, EventEmitter, Output, QueryList, ContentChildren, HostListener } from '@angular/core';
import { CdkScrollable } from '@angular/cdk/scrolling';
import { Subject } from 'rxjs';
import { HcScrollNavComponent } from '../nav/scroll-nav.component';
import { takeUntil } from 'rxjs/operators';
import { ScrollNavTargetDirective } from './scroll-nav-target.directive';
/**
 * Contains scrollable content that is navigable via `hc-scroll-nav` links.
 */
export class HcScrollNavContentComponent {
    constructor() {
        this.DEFAULT_BUFFER = 40;
        /**
         * If true, will force the height of the final scroll target area to be the height of the scrollable container.
         * This is helpful if you want the last target in the content area to be able to scroll to the top. You can alternatively
         * target the last item with css. *Defaults to true.*
         */
        this.makeLastTargetFullHeight = true;
        /**
         * Number in pixels, used to give a little leeway in the shifting of the active nav when scrolling. *Defaults to 40.*
         * Example: Left at default, if showing just the bottom 40 pixels of the section before, count the next section as active.
         */
        this.bufferSpace = this.DEFAULT_BUFFER;
        /**
         * If true, applies smooth scrolling via css. *Defaults to true.*
         */
        this.shouldAnimateScroll = true;
        /**
         * Fires when a new section is scrolled into view. Broadcasts the id of that section.
         */
        this.newSectionInView = new EventEmitter();
        this.unsubscribe$ = new Subject();
        this.minHeightForLastTargetSet = false;
    }
    /**
     * @return {?}
     */
    get _scrollTargets() {
        return this.targets.toArray().map((/**
         * @param {?} t
         * @return {?}
         */
        t => t._el.nativeElement));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._cdkScrollableElement) {
            this._cdkScrollableElement
                .elementScrolled()
                .pipe(takeUntil(this.unsubscribe$))
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.checkActiveSection();
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.makeLastTargetFullHeight && !this.minHeightForLastTargetSet) {
            this.insureMinHeightForLastTarget();
        }
    }
    /**
     * @return {?}
     */
    _onWindowResize() {
        if (this.makeLastTargetFullHeight) {
            this.minHeightForLastTargetSet = false;
        }
    }
    /**
     * Scroll to top and reset the "automatic full height for the last item" setting.
     * @return {?}
     */
    refresh() {
        this.scrollToTop();
        this.minHeightForLastTargetSet = false;
    }
    /**
     * Helper function to scroll to the top of the content area.
     * @return {?}
     */
    scrollToTop() {
        this._cdkScrollableElement.scrollTo({ top: 0 });
    }
    /**
     * Will update the navigation state.
     * @return {?}
     */
    checkActiveSection() {
        /** @type {?} */
        let offset = this._cdkScrollableElement.measureScrollOffset('top') + this._scrollTargets[0].offsetTop;
        this._scrollTargets.forEach((/**
         * @param {?} t
         * @param {?} index
         * @return {?}
         */
        (t, index) => {
            /** @type {?} */
            const el = t;
            /** @type {?} */
            let initialOffset = 0;
            /** @type {?} */
            let nextOffset = 0;
            if (index > 0) {
                initialOffset = el.offsetTop - this.bufferSpace;
            }
            if (index + 1 < this._scrollTargets.length) {
                /** @type {?} */
                const nextEl = this._scrollTargets[index + 1];
                nextOffset = nextEl.offsetTop;
            }
            if ((initialOffset && nextOffset && offset >= initialOffset && offset < nextOffset) ||
                (initialOffset && !nextOffset && offset >= initialOffset) ||
                (!initialOffset && nextOffset && offset < nextOffset)) {
                this.setActiveClass(el.getAttribute('id') || '');
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    insureMinHeightForLastTarget() {
        /** @type {?} */
        const containerHeight = this._cdkScrollableElement.getElementRef().nativeElement.offsetHeight;
        if (containerHeight && this._scrollTargets.length > 0) {
            /** @type {?} */
            const targetEl = this._scrollTargets[this._scrollTargets.length - 1];
            targetEl.style.minHeight = `${containerHeight + 50}px`;
            this.minHeightForLastTargetSet = true;
        }
    }
    /**
     * @private
     * @param {?} scrollTarget
     * @return {?}
     */
    setActiveClass(scrollTarget) {
        if (this.sectionInView !== scrollTarget) {
            this.sectionInView = scrollTarget;
            this.nav._setActiveClassById(scrollTarget);
            this.newSectionInView.next(scrollTarget);
        }
    }
}
HcScrollNavContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'hc-scroll-nav-content',
                encapsulation: ViewEncapsulation.None,
                template: "<div #scrollContainer class=\"hc-scroll-nav-content-container\" [ngClass]=\"{'hc-scroll-nav-smooth': shouldAnimateScroll}\" cdk-scrollable>\n  <ng-content></ng-content>\n</div>",
                styles: [".hc-scroll-nav-content-container{max-height:100%;overflow:scroll;overflow-x:hidden;width:100%}.hc-scroll-nav-smooth{scroll-behavior:smooth}"]
            }] }
];
HcScrollNavContentComponent.propDecorators = {
    nav: [{ type: Input }],
    makeLastTargetFullHeight: [{ type: Input }],
    bufferSpace: [{ type: Input }],
    shouldAnimateScroll: [{ type: Input }],
    newSectionInView: [{ type: Output }],
    _cdkScrollableElement: [{ type: ViewChild, args: ['scrollContainer', { read: CdkScrollable, static: false },] }],
    targets: [{ type: ContentChildren, args: [ScrollNavTargetDirective,] }],
    _onWindowResize: [{ type: HostListener, args: ['window:resize',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    HcScrollNavContentComponent.prototype.DEFAULT_BUFFER;
    /**
     * Reference to the scroll nav component.
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.nav;
    /**
     * If true, will force the height of the final scroll target area to be the height of the scrollable container.
     * This is helpful if you want the last target in the content area to be able to scroll to the top. You can alternatively
     * target the last item with css. *Defaults to true.*
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.makeLastTargetFullHeight;
    /**
     * Number in pixels, used to give a little leeway in the shifting of the active nav when scrolling. *Defaults to 40.*
     * Example: Left at default, if showing just the bottom 40 pixels of the section before, count the next section as active.
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.bufferSpace;
    /**
     * If true, applies smooth scrolling via css. *Defaults to true.*
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.shouldAnimateScroll;
    /**
     * Fires when a new section is scrolled into view. Broadcasts the id of that section.
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.newSectionInView;
    /** @type {?} */
    HcScrollNavContentComponent.prototype._cdkScrollableElement;
    /**
     * @type {?}
     * @private
     */
    HcScrollNavContentComponent.prototype.targets;
    /**
     * Id of the current section scrolled into view.
     * @type {?}
     */
    HcScrollNavContentComponent.prototype.sectionInView;
    /**
     * @type {?}
     * @private
     */
    HcScrollNavContentComponent.prototype.unsubscribe$;
    /**
     * @type {?}
     * @private
     */
    HcScrollNavContentComponent.prototype.minHeightForLastTargetSet;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLW5hdi1jb250ZW50LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi9zY3JvbGwtbmF2L2NvbnRlbnQvc2Nyb2xsLW5hdi1jb250ZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLEtBQUssRUFFTCxTQUFTLEVBRVQsWUFBWSxFQUNaLE1BQU0sRUFDTixTQUFTLEVBQ1QsZUFBZSxFQUNmLFlBQVksRUFFZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDckQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNqRSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDekMsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sK0JBQStCLENBQUM7Ozs7QUFTdkUsTUFBTSxPQUFPLDJCQUEyQjtJQU54QztRQU9xQixtQkFBYyxHQUFHLEVBQUUsQ0FBQzs7Ozs7O1FBTXJCLDZCQUF3QixHQUFHLElBQUksQ0FBQzs7Ozs7UUFHaEMsZ0JBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDOzs7O1FBRWxDLHdCQUFtQixHQUFHLElBQUksQ0FBQzs7OztRQUUxQixxQkFBZ0IsR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQVE3RSxpQkFBWSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDbkMsOEJBQXlCLEdBQUcsS0FBSyxDQUFDO0lBb0Y5QyxDQUFDOzs7O0lBeEZHLElBQVcsY0FBYztRQUNyQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRzs7OztRQUFDLENB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e1xuICAgIENvbXBvbmVudCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgICBJbnB1dCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBBZnRlclZpZXdDaGVja2VkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDZGtTY3JvbGxhYmxlfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0hjU2Nyb2xsTmF2Q29tcG9uZW50fSBmcm9tICcuLi9uYXYvc2Nyb2xsLW5hdi5jb21wb25lbnQnO1xuaW1wb3J0IHt0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7U2Nyb2xsTmF2VGFyZ2V0RGlyZWN0aXZlfSBmcm9tICcuL3Njcm9sbC1uYXYtdGFyZ2V0LmRpcmVjdGl2ZSc7XG5cbi8qKiBDb250YWlucyBzY3JvbGxhYmxlIGNvbnRlbnQgdGhhdCBpcyBuYXZpZ2FibGUgdmlhIGBoYy1zY3JvbGwtbmF2YCBsaW5rcy4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaGMtc2Nyb2xsLW5hdi1jb250ZW50JyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHN0eWxlVXJsczogWydzY3JvbGwtbmF2LWNvbnRlbnQuY29tcG9uZW50LnNjc3MnXSxcbiAgICB0ZW1wbGF0ZVVybDogJ3Njcm9sbC1uYXYtY29udGVudC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSGNTY3JvbGxOYXZDb250ZW50Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IERFRkFVTFRfQlVGRkVSID0gNDA7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgc2Nyb2xsIG5hdiBjb21wb25lbnQuICovXG4gICAgQElucHV0KCkgcHVibGljIG5hdjogSGNTY3JvbGxOYXZDb21wb25lbnQ7XG4gICAgLyoqIElmIHRydWUsIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZiB0aGUgZmluYWwgc2Nyb2xsIHRhcmdldCBhcmVhIHRvIGJlIHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyLlxuICAgICAqIFRoaXMgaXMgaGVscGZ1bCBpZiB5b3Ugd2FudCB0aGUgbGFzdCB0YXJnZXQgaW4gdGhlIGNvbnRlbnQgYXJlYSB0byBiZSBhYmxlIHRvIHNjcm9sbCB0byB0aGUgdG9wLiBZb3UgY2FuIGFsdGVybmF0aXZlbHlcbiAgICAgKiB0YXJnZXQgdGhlIGxhc3QgaXRlbSB3aXRoIGNzcy4gKkRlZmF1bHRzIHRvIHRydWUuKiAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBtYWtlTGFzdFRhcmdldEZ1bGxIZWlnaHQgPSB0cnVlO1xuICAgIC8qKiBOdW1iZXIgaW4gcGl4ZWxzLCB1c2VkIHRvIGdpdmUgYSBsaXR0bGUgbGVld2F5IGluIHRoZSBzaGlmdGluZyBvZiB0aGUgYWN0aXZlIG5hdiB3aGVuIHNjcm9sbGluZy4gKkRlZmF1bHRzIHRvIDQwLipcbiAgICAgKiBFeGFtcGxlOiBMZWZ0IGF0IGRlZmF1bHQsIGlmIHNob3dpbmcganVzdCB0aGUgYm90dG9tIDQwIHBpeGVscyBvZiB0aGUgc2VjdGlvbiBiZWZvcmUsIGNvdW50IHRoZSBuZXh0IHNlY3Rpb24gYXMgYWN0aXZlLiAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBidWZmZXJTcGFjZSA9IHRoaXMuREVGQVVMVF9CVUZGRVI7XG4gICAgLyoqIElmIHRydWUsIGFwcGxpZXMgc21vb3RoIHNjcm9sbGluZyB2aWEgY3NzLiAqRGVmYXVsdHMgdG8gdHJ1ZS4qICovXG4gICAgQElucHV0KCkgcHVibGljIHNob3VsZEFuaW1hdGVTY3JvbGwgPSB0cnVlO1xuICAgIC8qKiBGaXJlcyB3aGVuIGEgbmV3IHNlY3Rpb24gaXMgc2Nyb2xsZWQgaW50byB2aWV3LiBCcm9hZGNhc3RzIHRoZSBpZCBvZiB0aGF0IHNlY3Rpb24uICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBuZXdTZWN0aW9uSW5WaWV3OiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuICAgIEBWaWV3Q2hpbGQoJ3Njcm9sbENvbnRhaW5lcicsIHtyZWFkOiBDZGtTY3JvbGxhYmxlLCBzdGF0aWM6IGZhbHNlfSkgcHVibGljIF9jZGtTY3JvbGxhYmxlRWxlbWVudDogQ2RrU2Nyb2xsYWJsZTtcbiAgICBAQ29udGVudENoaWxkcmVuKFNjcm9sbE5hdlRhcmdldERpcmVjdGl2ZSkgcHJpdmF0ZSB0YXJnZXRzOiBRdWVyeUxpc3Q8U2Nyb2xsTmF2VGFyZ2V0RGlyZWN0aXZlPjtcbiAgICAvKiogSWQgb2YgdGhlIGN1cnJlbnQgc2VjdGlvbiBzY3JvbGxlZCBpbnRvIHZpZXcuICovXG4gICAgcHVibGljIHNlY3Rpb25JblZpZXc6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IF9zY3JvbGxUYXJnZXRzKCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldHMudG9BcnJheSgpLm1hcCh0ID0+IHQuX2VsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHJpdmF0ZSBtaW5IZWlnaHRGb3JMYXN0VGFyZ2V0U2V0ID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUkLm5leHQoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fY2RrU2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nka1Njcm9sbGFibGVFbGVtZW50XG4gICAgICAgICAgICAgICAgLmVsZW1lbnRTY3JvbGxlZCgpXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0FjdGl2ZVNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm1ha2VMYXN0VGFyZ2V0RnVsbEhlaWdodCAmJiAhdGhpcy5taW5IZWlnaHRGb3JMYXN0VGFyZ2V0U2V0KSB7XG4gICAgICAgICAgICB0aGlzLmluc3VyZU1pbkhlaWdodEZvckxhc3RUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnKSBfb25XaW5kb3dSZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1ha2VMYXN0VGFyZ2V0RnVsbEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5taW5IZWlnaHRGb3JMYXN0VGFyZ2V0U2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2Nyb2xsIHRvIHRvcCBhbmQgcmVzZXQgdGhlIFwiYXV0b21hdGljIGZ1bGwgaGVpZ2h0IGZvciB0aGUgbGFzdCBpdGVtXCIgc2V0dGluZy4gKi9cbiAgICBwdWJsaWMgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgICAgICB0aGlzLm1pbkhlaWdodEZvckxhc3RUYXJnZXRTZXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogSGVscGVyIGZ1bmN0aW9uIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBjb250ZW50IGFyZWEuICovXG4gICAgcHVibGljIHNjcm9sbFRvVG9wKCkge1xuICAgICAgICB0aGlzLl9jZGtTY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUbyh7dG9wOiAwfSk7XG4gICAgfVxuXG4gICAgLyoqIFdpbGwgdXBkYXRlIHRoZSBuYXZpZ2F0aW9uIHN0YXRlLiAqL1xuICAgIHB1YmxpYyBjaGVja0FjdGl2ZVNlY3Rpb24oKSB7XG4gICAgICAgIGxldCBvZmZzZXQ6IG51bWJlciA9IHRoaXMuX2Nka1Njcm9sbGFibGVFbGVtZW50Lm1lYXN1cmVTY3JvbGxPZmZzZXQoJ3RvcCcpICsgdGhpcy5fc2Nyb2xsVGFyZ2V0c1swXS5vZmZzZXRUb3A7XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVGFyZ2V0cy5mb3JFYWNoKCh0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IG5leHRPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbE9mZnNldCA9IGVsLm9mZnNldFRvcCAtIHRoaXMuYnVmZmVyU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fc2Nyb2xsVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWwgPSB0aGlzLl9zY3JvbGxUYXJnZXRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgbmV4dE9mZnNldCA9IG5leHRFbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoaW5pdGlhbE9mZnNldCAmJiBuZXh0T2Zmc2V0ICYmIG9mZnNldCA+PSBpbml0aWFsT2Zmc2V0ICYmIG9mZnNldCA8IG5leHRPZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgKGluaXRpYWxPZmZzZXQgJiYgIW5leHRPZmZzZXQgJiYgb2Zmc2V0ID49IGluaXRpYWxPZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgKCFpbml0aWFsT2Zmc2V0ICYmIG5leHRPZmZzZXQgJiYgb2Zmc2V0IDwgbmV4dE9mZnNldClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlQ2xhc3MoZWwuZ2V0QXR0cmlidXRlKCdpZCcpIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnN1cmVNaW5IZWlnaHRGb3JMYXN0VGFyZ2V0KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jZGtTY3JvbGxhYmxlRWxlbWVudC5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmIChjb250YWluZXJIZWlnaHQgJiYgdGhpcy5fc2Nyb2xsVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuX3Njcm9sbFRhcmdldHNbdGhpcy5fc2Nyb2xsVGFyZ2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHRhcmdldEVsLnN0eWxlLm1pbkhlaWdodCA9IGAke2NvbnRhaW5lckhlaWdodCArIDUwfXB4YDtcbiAgICAgICAgICAgIHRoaXMubWluSGVpZ2h0Rm9yTGFzdFRhcmdldFNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEFjdGl2ZUNsYXNzKHNjcm9sbFRhcmdldDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25JblZpZXcgIT09IHNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uSW5WaWV3ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5uYXYuX3NldEFjdGl2ZUNsYXNzQnlJZChzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5uZXdTZWN0aW9uSW5WaWV3Lm5leHQoc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==