/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/cell-resizer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/* Based on an example posted by Paolo Caleffi at: https://github.com/angular/material2/issues/8312 */
import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, HostListener, Input, Output, ViewEncapsulation } from '@angular/core';
import { BindObservable } from './bind-observable/bind-observable';
import { untilDestroyed } from '../util';
import { fromEvent } from 'rxjs';
import { skip } from 'rxjs/operators';
export class CellResizeEvent {
    /**
     * @param {?} width
     * @param {?} directionLeft
     */
    constructor(width, directionLeft) {
        this.width = width;
        this.directionLeft = directionLeft;
    }
}
if (false) {
    /** @type {?} */
    CellResizeEvent.prototype.width;
    /** @type {?} */
    CellResizeEvent.prototype.directionLeft;
}
export class HcCellResizer {
    constructor() {
        /**
         * Sets whether the resizer is active or not
         */
        this.disabled = false;
        this._directionModifier = 1;
        /**
         * Emits a `CellResizeEvent` when a cell has been resized
         */
        this.resized = new EventEmitter();
        this.isResizing = false;
        /**
         * Emits a boolean value of true while a cell is being resized
         */
        this.resizing = new EventEmitter();
    }
    /**
     * Stores the width value for this resizer;
     * typically used with two-way binding on the cell's style.width property
     * @return {?}
     */
    get width() {
        return this._width;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        if (value > 0) {
            this._width = value;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isResizing$
            .pipe(
        // Skip default value
        skip(1), untilDestroyed(this))
            .subscribe((/**
         * @param {?} isResizing
         * @return {?}
         */
        isResizing => {
            this.resizing.emit(isResizing);
            if (isResizing) {
                // We must use arrow function to avoid losing the context,
                //  we cannot pass directly the functions references
                this.dragSubscription = fromEvent(window.document, 'mousemove')
                    .pipe(untilDestroyed(this))
                    .subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this._resizeColumn(event)));
                this.dragSubscription.add(fromEvent(window.document, 'mouseup')
                    .pipe(untilDestroyed(this))
                    .subscribe((/**
                 * @return {?}
                 */
                () => this._stopResizing())));
            }
            else {
                // When resize finishes, we emit one last "resized" event for which
                //  the corresponding "isResizing" value will be false.
                // This can be used to detect which is the final resizing event
                //  and ignore the others
                this.resized.emit(new CellResizeEvent(this.width, this._directionModifier === -1));
                if (this.dragSubscription) {
                    this.dragSubscription.unsubscribe();
                }
            }
        }));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _resizeColumn(event) {
        /** @type {?} */
        const deltaX = event.screenX - this._mouseX;
        /** @type {?} */
        const newWidth = this.width + deltaX * this._directionModifier;
        this._mouseX = event.screenX;
        if (newWidth >= 0) {
            this.resized.emit(new CellResizeEvent(newWidth, this._directionModifier === -1));
        }
        // Prevent text selection while resizing
        event.preventDefault();
        event.stopPropagation();
    }
    // Same problems that mousemove listener have
    /**
     * @private
     * @return {?}
     */
    _stopResizing() {
        this.isResizing = false;
    }
    // isResizing can be set to true only when the component is not disabled
    /**
     * @param {?} event
     * @return {?}
     */
    _startResizing(event) {
        this.isResizing = !this.disabled;
        this._mouseX = event.screenX;
        if (((/** @type {?} */ (event.target))).className === 'hc-cell-resizer-left') {
            this._directionModifier = -1;
        }
        else {
            this._directionModifier = 1;
        }
        // Prevent text selection while resizing
        event.preventDefault();
        event.stopPropagation();
    }
    // Must be present for AOT compilation to work, even if empty
    // Otherwise 'ng build --prod' will optimize away any calls to ngOnDestroy,
    // even if the method is added by the untilDestroyed operator
    /**
     * @return {?}
     */
    ngOnDestroy() { }
}
HcCellResizer.decorators = [
    { type: Component, args: [{
                selector: 'hc-cell-resizer',
                template: '<div class="hc-cell-resizer-left"></div><div class="hc-cell-resizer-right"></div>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }] }
];
HcCellResizer.propDecorators = {
    disabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    width: [{ type: Input }],
    resized: [{ type: Output }],
    resizing: [{ type: Output }],
    _startResizing: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};
tslib_1.__decorate([
    BindObservable(),
    tslib_1.__metadata("design:type", Object)
], HcCellResizer.prototype, "isResizing", void 0);
if (false) {
    /**
     * Sets whether the resizer is active or not
     * @type {?}
     */
    HcCellResizer.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._width;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._directionModifier;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._mouseX;
    /**
     * Emits a `CellResizeEvent` when a cell has been resized
     * @type {?}
     */
    HcCellResizer.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.isResizing;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.isResizing$;
    /**
     * Emits a boolean value of true while a cell is being resized
     * @type {?}
     */
    HcCellResizer.prototype.resizing;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.dragSubscription;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC1yZXNpemVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi90YWJsZS9jZWxsLXJlc2l6ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBR0wsTUFBTSxFQUNOLGlCQUFpQixFQUNwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDakUsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUN2QyxPQUFPLEVBQUMsU0FBUyxFQUEyQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEMsTUFBTSxPQUFPLGVBQWU7Ozs7O0lBQ3hCLFlBQW1CLEtBQWEsRUFBUyxhQUFzQjtRQUE1QyxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQVMsa0JBQWEsR0FBYixhQUFhLENBQVM7SUFBRyxDQUFDO0NBQ3RFOzs7SUFEZSxnQ0FBb0I7O0lBQUUsd0NBQTZCOztBQVVuRSxNQUFNLE9BQU8sYUFBYTtJQVAxQjs7OztRQVc0QyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBaUJqRCx1QkFBa0IsR0FBVyxDQUFDLENBQUM7Ozs7UUFPdEIsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO1FBRXJDLGVBQVUsR0FBRyxLQUFLLENBQUM7Ozs7UUFNNUIsYUFBUSxHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7SUE4RTVELENBQUM7Ozs7OztJQXhHRyxJQUNJLEtBQUs7UUFDTCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQzs7Ozs7SUFDRCxJQUFJLEtBQUssQ0FBQyxLQUFh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QXdDO1FBQ3hDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDNUIsQ0FBQzs7Ozs7OztJQUtNLFdBQVcsS0FBSSxDQUFDOzs7WUF4SDFCLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQixRQUFRLEVBQUUsbUZBQW1GO2dCQUU3RixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7YUFDeEM7Ozt1QkFLSSxXQUFXLFNBQUMsZ0JBQWdCLGNBQUcsS0FBSztvQkFNcEMsS0FBSztzQkFrQkwsTUFBTTt1QkFRTixNQUFNOzZCQTBETixZQUFZLFNBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDOztBQWhFbkI7SUFBakIsY0FBYyxFQUFFOztpREFBNEI7Ozs7OztJQTFCN0MsaUNBQXlEOzs7OztJQWV6RCwrQkFBd0I7Ozs7O0lBRXhCLDJDQUF1Qzs7Ozs7SUFFdkMsZ0NBQXdCOzs7OztJQUt4QixnQ0FBK0Q7Ozs7O0lBRS9ELG1DQUE2Qzs7Ozs7SUFDN0Msb0NBQTBDOzs7OztJQUsxQyxpQ0FBd0Q7Ozs7O0lBRXhELHlDQUF3QyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEJhc2VkIG9uIGFuIGV4YW1wbGUgcG9zdGVkIGJ5IFBhb2xvIENhbGVmZmkgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9pc3N1ZXMvODMxMiAqL1xuXG5pbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCaW5kT2JzZXJ2YWJsZX0gZnJvbSAnLi9iaW5kLW9ic2VydmFibGUvYmluZC1vYnNlcnZhYmxlJztcbmltcG9ydCB7dW50aWxEZXN0cm95ZWR9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHtmcm9tRXZlbnQsIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3NraXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGNsYXNzIENlbGxSZXNpemVFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHdpZHRoOiBudW1iZXIsIHB1YmxpYyBkaXJlY3Rpb25MZWZ0OiBib29sZWFuKSB7fVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hjLWNlbGwtcmVzaXplcicsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiaGMtY2VsbC1yZXNpemVyLWxlZnRcIj48L2Rpdj48ZGl2IGNsYXNzPVwiaGMtY2VsbC1yZXNpemVyLXJpZ2h0XCI+PC9kaXY+JyxcbiAgICBzdHlsZVVybHM6IFtdLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgSGNDZWxsUmVzaXplciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHJlc2l6ZXIgaXMgYWN0aXZlIG9yIG5vdFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZGlzYWJsZWQnKSBASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSB3aWR0aCB2YWx1ZSBmb3IgdGhpcyByZXNpemVyO1xuICAgICAqIHR5cGljYWxseSB1c2VkIHdpdGggdHdvLXdheSBiaW5kaW5nIG9uIHRoZSBjZWxsJ3Mgc3R5bGUud2lkdGggcHJvcGVydHlcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIHNldCB3aWR0aCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfd2lkdGghOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIF9kaXJlY3Rpb25Nb2RpZmllcjogbnVtYmVyID0gMTtcblxuICAgIHByaXZhdGUgX21vdXNlWDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYSBgQ2VsbFJlc2l6ZUV2ZW50YCB3aGVuIGEgY2VsbCBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZXNpemVkID0gbmV3IEV2ZW50RW1pdHRlcjxDZWxsUmVzaXplRXZlbnQ+KCk7XG5cbiAgICBAQmluZE9ic2VydmFibGUoKSBwcml2YXRlIGlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIGlzUmVzaXppbmckITogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgYm9vbGVhbiB2YWx1ZSBvZiB0cnVlIHdoaWxlIGEgY2VsbCBpcyBiZWluZyByZXNpemVkXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZXNpemluZyA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHByaXZhdGUgZHJhZ1N1YnNjcmlwdGlvbj86IFN1YnNjcmlwdGlvbjtcblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nJFxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgICAgc2tpcCgxKSxcbiAgICAgICAgICAgICAgICB1bnRpbERlc3Ryb3llZCh0aGlzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpc1Jlc2l6aW5nID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6aW5nLmVtaXQoaXNSZXNpemluZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHVzZSBhcnJvdyBmdW5jdGlvbiB0byBhdm9pZCBsb3NpbmcgdGhlIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8vICB3ZSBjYW5ub3QgcGFzcyBkaXJlY3RseSB0aGUgZnVuY3Rpb25zIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHdpbmRvdy5kb2N1bWVudCwgJ21vdXNlbW92ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGlwZSh1bnRpbERlc3Ryb3llZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5fcmVzaXplQ29sdW1uKGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQod2luZG93LmRvY3VtZW50LCAnbW91c2V1cCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUodW50aWxEZXN0cm95ZWQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zdG9wUmVzaXppbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJlc2l6ZSBmaW5pc2hlcywgd2UgZW1pdCBvbmUgbGFzdCBcInJlc2l6ZWRcIiBldmVudCBmb3Igd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gIHRoZSBjb3JyZXNwb25kaW5nIFwiaXNSZXNpemluZ1wiIHZhbHVlIHdpbGwgYmUgZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIGlzIHRoZSBmaW5hbCByZXNpemluZyBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgYW5kIGlnbm9yZSB0aGUgb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplZC5lbWl0KG5ldyBDZWxsUmVzaXplRXZlbnQodGhpcy53aWR0aCwgdGhpcy5fZGlyZWN0aW9uTW9kaWZpZXIgPT09IC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcmVzaXplQ29sdW1uKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LnNjcmVlblggLSB0aGlzLl9tb3VzZVg7XG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gdGhpcy53aWR0aCArIGRlbHRhWCAqIHRoaXMuX2RpcmVjdGlvbk1vZGlmaWVyO1xuXG4gICAgICAgIHRoaXMuX21vdXNlWCA9IGV2ZW50LnNjcmVlblg7XG5cbiAgICAgICAgaWYgKG5ld1dpZHRoID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplZC5lbWl0KG5ldyBDZWxsUmVzaXplRXZlbnQobmV3V2lkdGgsIHRoaXMuX2RpcmVjdGlvbk1vZGlmaWVyID09PSAtMSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hpbGUgcmVzaXppbmdcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gU2FtZSBwcm9ibGVtcyB0aGF0IG1vdXNlbW92ZSBsaXN0ZW5lciBoYXZlXG4gICAgcHJpdmF0ZSBfc3RvcFJlc2l6aW5nKCkge1xuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpc1Jlc2l6aW5nIGNhbiBiZSBzZXQgdG8gdHJ1ZSBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgZGlzYWJsZWRcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCddKSBfc3RhcnRSZXNpemluZyhldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSAhdGhpcy5kaXNhYmxlZDtcblxuICAgICAgICB0aGlzLl9tb3VzZVggPSBldmVudC5zY3JlZW5YO1xuXG4gICAgICAgIGlmICgoPEVsZW1lbnQ+ZXZlbnQudGFyZ2V0KS5jbGFzc05hbWUgPT09ICdoYy1jZWxsLXJlc2l6ZXItbGVmdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbk1vZGlmaWVyID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25Nb2RpZmllciA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoaWxlIHJlc2l6aW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIE11c3QgYmUgcHJlc2VudCBmb3IgQU9UIGNvbXBpbGF0aW9uIHRvIHdvcmssIGV2ZW4gaWYgZW1wdHlcbiAgICAvLyBPdGhlcndpc2UgJ25nIGJ1aWxkIC0tcHJvZCcgd2lsbCBvcHRpbWl6ZSBhd2F5IGFueSBjYWxscyB0byBuZ09uRGVzdHJveSxcbiAgICAvLyBldmVuIGlmIHRoZSBtZXRob2QgaXMgYWRkZWQgYnkgdGhlIHVudGlsRGVzdHJveWVkIG9wZXJhdG9yXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge31cbn1cbiJdfQ==