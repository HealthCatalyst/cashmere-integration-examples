/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover-anchoring.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, NgZone, Optional } from '@angular/core';
import { ConnectionPositionPair, Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { takeUntil, take, filter, tap } from 'rxjs/operators';
import { PopoverNotificationService, NotificationAction } from './notification.service';
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() { }
if (false) {
    /** @type {?} */
    PopoverConfig.prototype.horizontalAlign;
    /** @type {?} */
    PopoverConfig.prototype.verticalAlign;
    /** @type {?} */
    PopoverConfig.prototype.hasBackdrop;
    /** @type {?} */
    PopoverConfig.prototype.backdropClass;
    /** @type {?} */
    PopoverConfig.prototype.scrollStrategy;
    /** @type {?} */
    PopoverConfig.prototype.forceAlignment;
    /** @type {?} */
    PopoverConfig.prototype.lockAlignment;
}
export class HcPopoverAnchoringService {
    /**
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _dir
     */
    constructor(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    }
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    anchor(popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = this._anchor._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._popoverOpen;
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._popover._componentOverlay = this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
            this._popover._savePreviouslyFocusedElement();
        }
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    closePopover(value, neighborSubMenusAreOpen = false) {
        if (this._popover._componentOverlay) {
            this._saveClosedState(value, neighborSubMenusAreOpen);
            this._popover._componentOverlay.detach();
            this._popover._restoreFocusAndDestroyTrap();
        }
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopoverToAnchor() {
        if (this._popover._componentOverlay) {
            /** @type {?} */
            const config = this._popover._componentOverlay.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getAnchorElement() {
        return this._anchor._elementRef;
    }
    /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    _applyOpenOptions(options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    }
    /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    _createOverlay() {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            const popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment
            };
            /** @type {?} */
            const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        else if (this._popover.horizontalAlign === 'mouse' || this._popover.verticalAlign === 'mouse') {
            /* If aligning to mouse clicks - adjust the strategy based on the most current click */
            this._overlayRef.updatePositionStrategy(this._getPositionStrategy(this._popover.horizontalAlign, this._popover.verticalAlign, this._popover.forceAlignment, this._popover.lockAlignment, this._anchor._elementRef));
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    }
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    _destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    _destroyPopoverOnceClosed() {
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef
                .detachments()
                .pipe(take(1), takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            () => this._destroyPopover()));
        }
        else {
            this._destroyPopover();
        }
    }
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @private
     * @return {?}
     */
    _subscribeToNotifications() {
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events().subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            switch (event.action) {
                case NotificationAction.OPEN:
                    this.openPopover(event.value);
                    break;
                case NotificationAction.CLOSE:
                    this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    this._destroyPopoverOnceClosed();
                    break;
                case NotificationAction.REALIGN:
                    this.realignPopoverToAnchor();
                    break;
            }
        }));
    }
    /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    _subscribeToBackdrop() {
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .backdropClick()
            .pipe(tap((/**
         * @return {?}
         */
        () => this._popover.backdropClicked.emit())), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    _subscribeToEscape() {
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .keydownEvents()
            .pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => this._popover.overlayKeydown.emit(event))), filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.keyCode === ESCAPE)), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    _subscribeToDetachments() {
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this._saveClosedState()));
    }
    /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    _saveOpenedState() {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            if (this._popover.parent) {
                this._popover.parent._subMenuOpen = true;
            }
            this.popoverOpened.next();
            if (typeof this._context === 'undefined') {
                this._popover.opened.emit();
            }
            else {
                this._popover.opened.emit(this._context);
            }
        }
    }
    /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    _saveClosedState(value, neighborSubMenusAreOpen = false) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            if (this._popover.parent) {
                this._popover.parent._subMenuOpen = neighborSubMenusAreOpen;
            }
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    }
    /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    _getDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    _getOverlayConfig(config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor._elementRef),
            // make it hard for users to shoot themselves in the foot by disabling backdrop if hover is the trigger
            hasBackdrop: anchor.trigger !== 'hover' ? config.hasBackdrop : false,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
            // disable pointer events for hover popovers to avoid potential flickering issues
            panelClass: anchor.trigger === 'hover' ? 'overlay-pointer-events' : ''
        });
    }
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositionChanges(position) {
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges.pipe(takeUntil(this._onDestroy)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            // Position changes may occur outside the Angular zone
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                this._popover._setAlignmentClassesForAnimation(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
                this._popover._setAlignmentClassesForArrow(getHPopAlignmentForArrow(change.connectionPair.overlayX, change.connectionPair.originX), getVPopAlignmentForArrow(change.connectionPair.overlayY, change.connectionPair.originY));
            }));
        }));
    }
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _getScrollStrategyInstance(strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    }
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        const targetPosition = getPosition(horizontalTarget, verticalTarget, this._popover._offsetPos);
        /** @type {?} */
        const positions = [targetPosition];
        /** @type {?} */
        const strategy = this._overlay
            .position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push(...fallbacks);
        }
        return strategy.withPositions(positions);
    }
    /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    _getFallbacks(hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        const possibleHorizontalAlignments = horizontalOverlapAllowed
            ? ['before', 'start', 'center', 'end', 'after', 'mouse']
            : ['before', 'after'];
        /** @type {?} */
        const possibleVerticalAlignments = verticalOverlapAllowed
            ? ['above', 'start', 'center', 'end', 'below', 'mouse']
            : ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        const fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
         * @param {?} h
         * @return {?}
         */
        h => {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                fallbacks.push(getPosition(h, v, this._popover._offsetPos));
            }));
        }));
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    }
}
HcPopoverAnchoringService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HcPopoverAnchoringService.ctorParameters = () => [
    { type: Overlay },
    { type: NgZone },
    { type: Directionality, decorators: [{ type: Optional }] }
];
if (false) {
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype.popoverClosed;
    /**
     * Reference to the overlay containing the popover component.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype._overlayRef;
    /**
     * Reference to the target popover.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._popover;
    /**
     * Stores the context assigned to the popover
     * @type {?}
     */
    HcPopoverAnchoringService.prototype._context;
    /**
     * Reference to the view container for the popover template.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._viewContainerRef;
    /**
     * Reference to the anchor
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._anchor;
    /**
     * Reference to a template portal where the overlay will be attached.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._portal;
    /**
     * Communications channel with the popover.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._notifications;
    /**
     * Single subscription to notifications service events.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._notificationsSubscription;
    /**
     * Single subscription to position changes.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._positionChangeSubscription;
    /**
     * Whether the popover is presently open.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._popoverOpen;
    /**
     * Emits when the service is destroyed.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._onDestroy;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning
 * @param {?} hOverlay
 * @param {?} hOrigin
 * @return {?}
 */
function getHPopAlignmentForArrow(hOverlay, hOrigin) {
    if (hOverlay === hOrigin) {
        return hOverlay;
    }
    if (hOverlay === 'start') {
        return 'after';
    }
    if (hOverlay === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning.
 * @param {?} vOverlay
 * @param {?} vOrigin
 * @return {?}
 */
function getVPopAlignmentForArrow(vOverlay, vOrigin) {
    if (vOverlay === vOrigin && (vOverlay === 'top' || vOverlay === 'bottom')) {
        return vOverlay === 'top' ? 'start' : 'end';
    }
    if (vOverlay === 'top') {
        return 'below';
    }
    if (vOverlay === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to get a cdk position pair from HcPopover alignments.
 * @param {?} h
 * @param {?} v
 * @param {?} offset
 * @return {?}
 */
function getPosition(h, v, offset) {
    const { originX, overlayX } = getHorizontalConnectionPosPair(h);
    const { originY, overlayY } = getVerticalConnectionPosPair(v);
    return new ConnectionPositionPair({ originX, originY }, { overlayX, overlayY }, offset[0], offset[1]);
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
        case 'mouse':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
        case 'mouse':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    const targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    const reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    const left = options.slice(0, targetIndex);
    /** @type {?} */
    const right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        /** @type {?} */
        const r = right.pop();
        if (r) {
            reordered.push(r);
        }
        /** @type {?} */
        const l = left.pop();
        if (l) {
            reordered.push(l);
        }
    }
    // Flush out right side
    while (right.length) {
        /** @type {?} */
        const r2 = right.pop();
        if (r2) {
            reordered.push(r2);
        }
    }
    // Flush out left side
    while (left.length) {
        /** @type {?} */
        const l2 = left.pop();
        if (l2) {
            reordered.push(l2);
        }
    }
    return reordered;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi9wb3AvcG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBYSxVQUFVLEVBQUUsTUFBTSxFQUFhLFFBQVEsRUFBbUIsTUFBTSxlQUFlLENBQUM7QUFDcEcsT0FBTyxFQUNILHNCQUFzQixFQUd0QixPQUFPLEVBQ1AsYUFBYSxFQUloQixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBQyxjQUFjLEVBQVksTUFBTSxtQkFBbUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQ25ELE9BQU8sRUFBZSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDM0MsT0FBTyxFQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBSzVELE9BQU8sRUFBQywwQkFBMEIsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDOzs7Ozs7QUFPdEYsNEJBUUM7OztJQVBHLHdDQUEwQzs7SUFDMUMsc0NBQXNDOztJQUN0QyxvQ0FBcUI7O0lBQ3JCLHNDQUFzQjs7SUFDdEIsdUNBQXdDOztJQUN4Qyx1Q0FBd0I7O0lBQ3hCLHNDQUF1Qjs7QUFJM0IsTUFBTSxPQUFPLHlCQUF5Qjs7Ozs7O0lBd0NsQyxZQUFvQixRQUFpQixFQUFVLE9BQWUsRUFBc0IsSUFBb0I7UUFBcEYsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUFVLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFBc0IsU0FBSSxHQUFKLElBQUksQ0FBZ0I7Ozs7UUF0Q3hHLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQUdwQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUE4QjVCLGlCQUFZLEdBQUcsS0FBSyxDQUFDOzs7O1FBR3JCLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBRWtFLENBQUM7Ozs7SUFFNUcsV0FBVztRQUNQLHlFQUF5RTtRQUN6RSxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXZCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQywwQkFBMEIsRUFBRTtZQUNqQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDakQ7UUFDRCxJQUFJLElBQUksQ0FBQywyQkFBMkIsRUFBRTtZQUNsQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDbEQ7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFM0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2xDLENBQUM7Ozs7Ozs7O0lBR0QsTUFBTSxDQUFDLE9BQXVCLEVBQUUsZ0JBQWtDLEVBQUUsTUFBZ0M7UUFDaEcsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUV2QixvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDO1FBQzFDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBRXRCLHNGQUFzRjtRQUN0RiwrREFBK0Q7UUFDL0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLDBCQUEwQixFQUFFLENBQUM7UUFDcEgsSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7SUFDckMsQ0FBQzs7Ozs7SUFHRCxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBR0QsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDeEUsQ0FBQzs7Ozs7O0lBR0QsV0FBVyxDQUFDLFVBQWdDLEVBQUU7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3hELElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztTQUNqRDtJQUNMLENBQUM7Ozs7Ozs7SUFHRCxZQUFZLENBQUMsS0FBVyxFQUFFLDBCQUFtQyxLQUFLO1FBQzlELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRTtZQUNqQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLHVCQUF1QixDQUFDLENBQUM7WUFDdEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN6QyxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixFQUFFLENBQUM7U0FDL0M7SUFDTCxDQUFDOzs7OztJQUdELHNCQUFzQjtRQUNsQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUU7O2tCQUMzQixNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUU7O2tCQUNwRCxRQUFRLEdBQUcsbUJBQUEsTUFBTSxDQUFDLGdCQUFnQixFQUFxQztZQUM3RSxRQUFRLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztTQUNsQztJQUNMLENBQUM7Ozs7O0lBR0QsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztJQUNwQyxDQUFDOzs7Ozs7O0lBR08saUJBQWlCLENBQUMsT0FBNkI7OztjQUU3QyxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksS0FBSyxLQUFLO1FBQ25ELElBQUksQ0FBQyxRQUFRLENBQUMscUJBQXFCLEdBQUcsWUFBWSxDQUFDOzs7Y0FHN0MsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEtBQUssS0FBSztRQUM3QyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztJQUNqRCxDQUFDOzs7Ozs7SUFHTyxjQUFjO1FBQ2xCLHlDQUF5QztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNuQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOztrQkFFaEYsYUFBYSxHQUFHO2dCQUNsQixlQUFlLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlO2dCQUM5QyxhQUFhLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhO2dCQUMxQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXO2dCQUN0QyxhQUFhLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhO2dCQUMxQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjO2dCQUM1QyxjQUFjLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjO2dCQUM1QyxhQUFhLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhO2FBQzdDOztrQkFFSyxhQUFhLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO1lBRXpFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxtQkFBQSxhQUFhLENBQUMsZ0JBQWdCLEVBQXFDLENBQUMsQ0FBQztZQUV0RyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLEtBQUssT0FBTyxFQUFFO1lBQzdGLHVGQUF1RjtZQUN2RixJQUFJLENBQUMsV0FBVyxDQUFDLHNCQUFzQixDQUNuQyxJQUFJLENBQUMsb0JBQW9CLENBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FDM0IsQ0FDSixDQUFDO1NBQ0w7UUFFRCw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUM1QixDQUFDOzs7Ozs7SUFHTyxlQUFlO1FBQ25CLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQzNCO0lBQ0wsQ0FBQzs7Ozs7OztJQU1PLHlCQUF5QjtRQUM3QixJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQzFDLElBQUksQ0FBQyxXQUFXO2lCQUNYLFdBQVcsRUFBRTtpQkFDYixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ3pDLFNBQVM7OztZQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBQyxDQUFDO1NBQ2hEO2FBQU07WUFDSCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDMUI7SUFDTCxDQUFDOzs7Ozs7O0lBTU8seUJBQXlCO1FBQzdCLElBQUksSUFBSSxDQUFDLDBCQUEwQixFQUFFO1lBQ2pDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFNBQVM7Ozs7UUFBQyxLQUFLLENBQUMsRUFBRTtZQUM3RSxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ2xCLEtBQUssa0JBQWtCLENBQUMsSUFBSTtvQkFDeEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzlCLE1BQU07Z0JBQ1YsS0FBSyxrQkFBa0IsQ0FBQyxLQUFLO29CQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDL0IsTUFBTTtnQkFDVixLQUFLLGtCQUFrQixDQUFDLE1BQU07b0JBQzFCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztvQkFDckIsTUFBTTtnQkFDVixLQUFLLGtCQUFrQixDQUFDLFVBQVUsQ0FBQztnQkFDbkMsK0VBQStFO2dCQUMvRSxLQUFLLGtCQUFrQixDQUFDLGFBQWE7b0JBQ2pDLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO29CQUNqQyxNQUFNO2dCQUNWLEtBQUssa0JBQWtCLENBQUMsT0FBTztvQkFDM0IsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7b0JBQzlCLE1BQU07YUFDYjtRQUNMLENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQzs7Ozs7O0lBR08sb0JBQW9CO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ25CLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxXQUFXO2FBQ1gsYUFBYSxFQUFFO2FBQ2YsSUFBSSxDQUNELEdBQUc7OztRQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxFQUFDLEVBQy9DLE1BQU07OztRQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUMsRUFDNUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFDN0IsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FDN0I7YUFDQSxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUMsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7SUFHTyxrQkFBa0I7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbkIsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLFdBQVc7YUFDWCxhQUFhLEVBQUU7YUFDZixJQUFJLENBQ0QsR0FBRzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFDLEVBQ3RELE1BQU07Ozs7UUFBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLEtBQUssTUFBTSxFQUFDLEVBQ3pDLE1BQU07OztRQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUMsRUFDNUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFDN0IsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FDN0I7YUFDQSxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUMsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7SUFHTyx1QkFBdUI7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbkIsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLFdBQVc7YUFDWCxXQUFXLEVBQUU7YUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQyxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBQyxDQUFDO0lBQ2xELENBQUM7Ozs7OztJQUdPLGdCQUFnQjtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNwQixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUMvQyxJQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFHO2dCQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2FBQzVDO1lBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUMxQixJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsS0FBSyxXQUFXLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQy9CO2lCQUFNO2dCQUNILElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDNUM7U0FDSjtJQUNMLENBQUM7Ozs7Ozs7O0lBR08sZ0JBQWdCLENBQUMsS0FBVyxFQUFFLDBCQUFtQyxLQUFLO1FBQzFFLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUNoRCxJQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFHO2dCQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEdBQUcsdUJBQXVCLENBQUM7YUFDL0Q7WUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEM7SUFDTCxDQUFDOzs7Ozs7SUFHTyxhQUFhO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ2xFLENBQUM7Ozs7Ozs7O0lBR08saUJBQWlCLENBQUMsTUFBcUIsRUFBRSxNQUFnQztRQUM3RSxPQUFPLElBQUksYUFBYSxDQUFDO1lBQ3JCLGdCQUFnQixFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FDdkMsTUFBTSxDQUFDLGVBQWUsRUFDdEIsTUFBTSxDQUFDLGFBQWEsRUFDcEIsTUFBTSxDQUFDLGNBQWMsRUFDckIsTUFBTSxDQUFDLGFBQWEsRUFDcEIsTUFBTSxDQUFDLFdBQVcsQ0FDckI7O1lBRUQsV0FBVyxFQUFFLE1BQU0sQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBRXBFLGFBQWEsRUFBRSxNQUFNLENBQUMsYUFBYSxJQUFJLGtDQUFrQztZQUN6RSxjQUFjLEVBQUUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDdEUsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7O1lBRy9CLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDekUsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7Ozs7Ozs7SUFNTywyQkFBMkIsQ0FBQyxRQUEyQztRQUMzRSxJQUFJLElBQUksQ0FBQywyQkFBMkIsRUFBRTtZQUNsQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDbEQ7UUFFRCxJQUFJLENBQUMsMkJBQTJCLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxNQUFNLENBQUMsRUFBRTtZQUM1RyxzREFBc0Q7WUFDdEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHOzs7WUFBQyxHQUFHLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsZ0NBQWdDLENBQzFDLDZCQUE2QixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQzdELDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQzlELENBQUM7Z0JBQ0YsSUFBSSxDQUFDLFFBQVEsQ0FBQyw0QkFBNEIsQ0FDdEMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFDdkYsd0JBQXdCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FDMUYsQ0FBQztZQUNOLENBQUMsRUFBQyxDQUFDO1FBQ1AsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDOzs7Ozs7O0lBR08sMEJBQTBCLENBQUMsUUFBaUM7UUFDaEUsUUFBUSxRQUFRLEVBQUU7WUFDZCxLQUFLLE9BQU87Z0JBQ1IsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2xELEtBQUssWUFBWTtnQkFDYixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDdkQsS0FBSyxPQUFPO2dCQUNSLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNsRCxLQUFLLE1BQU0sQ0FBQztZQUNaO2dCQUNJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNwRDtJQUNMLENBQUM7Ozs7Ozs7Ozs7O0lBR08sb0JBQW9CLENBQ3hCLGdCQUEwQyxFQUMxQyxjQUFzQyxFQUN0QyxjQUF1QixFQUN2QixhQUFzQixFQUN0QixNQUFrQjs7O2NBR1osY0FBYyxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7O2NBQ3hGLFNBQVMsR0FBRyxDQUFDLGNBQWMsQ0FBQzs7Y0FFNUIsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRO2FBQ3pCLFFBQVEsRUFBRTthQUNWLG1CQUFtQixDQUFDLE1BQU0sQ0FBQzthQUMzQixzQkFBc0IsQ0FBQyxLQUFLLENBQUM7YUFDN0IsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUNmLGtCQUFrQixDQUFDLENBQUMsQ0FBQzthQUNyQixrQkFBa0IsQ0FBQyxhQUFhLENBQUM7UUFFdEMsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQyxjQUFjLEVBQUU7O2tCQUNYLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLGNBQWMsQ0FBQztZQUN0RSxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7U0FDaEM7UUFFRCxPQUFPLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDN0MsQ0FBQzs7Ozs7Ozs7SUFHTyxhQUFhLENBQUMsT0FBaUMsRUFBRSxPQUErQjs7O2NBRTlFLHdCQUF3QixHQUFHLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxLQUFLLE9BQU87O2NBQ3RFLHNCQUFzQixHQUFHLE9BQU8sS0FBSyxPQUFPLElBQUksT0FBTyxLQUFLLE9BQU87Ozs7Y0FJbkUsNEJBQTRCLEdBQStCLHdCQUF3QjtZQUNyRixDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQztZQUN4RCxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDOztjQUNuQiwwQkFBMEIsR0FBNkIsc0JBQXNCO1lBQy9FLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDO1lBQ3ZELENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUM7OztjQUdsQixTQUFTLEdBQTZCLEVBQUU7UUFDOUMsc0JBQXNCLENBQUMsT0FBTyxFQUFFLDRCQUE0QixDQUFDLENBQUMsT0FBTzs7OztRQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3RFLHNCQUFzQixDQUFDLE9BQU8sRUFBRSwwQkFBMEIsQ0FBQyxDQUFDLE9BQU87Ozs7WUFBQyxDQUFDLENBQUMsRUFBRTtnQkFDcEUsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsQ0FBQyxFQUFDLENBQUM7UUFDUCxDQUFDLEVBQUMsQ0FBQztRQUVILDhGQUE4RjtRQUM5RixPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoRCxDQUFDOzs7WUF0YUosVUFBVTs7OztZQWhDUCxPQUFPO1lBTHFCLE1BQU07WUFXOUIsY0FBYyx1QkFtRStDLFFBQVE7Ozs7Ozs7SUF0Q3pFLGtEQUFvQzs7Ozs7SUFHcEMsa0RBQW9DOzs7OztJQUdwQyxnREFBK0I7Ozs7OztJQUcvQiw2Q0FBaUM7Ozs7O0lBR2pDLDZDQUFjOzs7Ozs7SUFHZCxzREFBNEM7Ozs7OztJQUc1Qyw0Q0FBMEM7Ozs7OztJQUcxQyw0Q0FBcUM7Ozs7OztJQUdyQyxtREFBbUQ7Ozs7OztJQUduRCwrREFBaUQ7Ozs7OztJQUdqRCxnRUFBa0Q7Ozs7OztJQUdsRCxpREFBNkI7Ozs7OztJQUc3QiwrQ0FBeUM7Ozs7O0lBRTdCLDZDQUF5Qjs7Ozs7SUFBRSw0Q0FBdUI7Ozs7O0lBQUUseUNBQXdDOzs7Ozs7OztBQWlZNUcsU0FBUyx3QkFBd0IsQ0FBQyxRQUFpQyxFQUFFLE9BQWdDO0lBQ2pHLElBQUksUUFBUSxLQUFLLE9BQU8sRUFBRTtRQUN0QixPQUFPLFFBQVEsQ0FBQztLQUNuQjtJQUVELElBQUksUUFBUSxLQUFLLE9BQU8sRUFBRTtRQUN0QixPQUFPLE9BQU8sQ0FBQztLQUNsQjtJQUVELElBQUksUUFBUSxLQUFLLEtBQUssRUFBRTtRQUNwQixPQUFPLFFBQVEsQ0FBQztLQUNuQjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7Ozs7Ozs7QUFHRCxTQUFTLHdCQUF3QixDQUFDLFFBQStCLEVBQUUsT0FBOEI7SUFDN0YsSUFBSSxRQUFRLEtBQUssT0FBTyxJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssSUFBSSxRQUFRLEtBQUssUUFBUSxDQUFDLEVBQUU7UUFDdkUsT0FBTyxRQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztLQUMvQztJQUVELElBQUksUUFBUSxLQUFLLEtBQUssRUFBRTtRQUNwQixPQUFPLE9BQU8sQ0FBQztLQUNsQjtJQUVELElBQUksUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUN2QixPQUFPLE9BQU8sQ0FBQztLQUNsQjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7Ozs7Ozs7O0FBR0QsU0FBUyxXQUFXLENBQUMsQ0FBMkIsRUFBRSxDQUF5QixFQUFFLE1BQWdCO1VBQ25GLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBQyxHQUFHLDhCQUE4QixDQUFDLENBQUMsQ0FBQztVQUN2RCxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUMsR0FBRyw0QkFBNEIsQ0FBQyxDQUFDLENBQUM7SUFDM0QsT0FBTyxJQUFJLHNCQUFzQixDQUFDLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFFLFFBQVEsRUFBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RyxDQUFDOzs7Ozs7QUFHRCxTQUFTLDZCQUE2QixDQUFDLENBQTBCO0lBQzdELElBQUksQ0FBQyxLQUFLLE9BQU8sRUFBRTtRQUNmLE9BQU8sT0FBTyxDQUFDO0tBQ2xCO0lBRUQsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQ2IsT0FBTyxRQUFRLENBQUM7S0FDbkI7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDOzs7Ozs7QUFHRCxTQUFTLDJCQUEyQixDQUFDLENBQXdCO0lBQ3pELElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRTtRQUNiLE9BQU8sT0FBTyxDQUFDO0tBQ2xCO0lBRUQsSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFFO1FBQ2hCLE9BQU8sT0FBTyxDQUFDO0tBQ2xCO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDcEIsQ0FBQzs7Ozs7O0FBR0QsU0FBUyw4QkFBOEIsQ0FDbkMsQ0FBMkI7SUFFM0IsUUFBUSxDQUFDLEVBQUU7UUFDUCxLQUFLLFFBQVE7WUFDVCxPQUFPLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFDLENBQUM7UUFDL0MsS0FBSyxPQUFPLENBQUM7UUFDYixLQUFLLE9BQU87WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFDLENBQUM7UUFDakQsS0FBSyxLQUFLO1lBQ04sT0FBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzdDLEtBQUssT0FBTztZQUNSLE9BQU8sRUFBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUMsQ0FBQztRQUMvQztZQUNJLE9BQU8sRUFBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUMsQ0FBQztLQUN0RDtBQUNMLENBQUM7Ozs7OztBQUdELFNBQVMsNEJBQTRCLENBQUMsQ0FBeUI7SUFDM0QsUUFBUSxDQUFDLEVBQUU7UUFDUCxLQUFLLE9BQU87WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUM7UUFDaEQsS0FBSyxPQUFPLENBQUM7UUFDYixLQUFLLE9BQU87WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFDLENBQUM7UUFDN0MsS0FBSyxLQUFLO1lBQ04sT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO1FBQ25ELEtBQUssT0FBTztZQUNSLE9BQU8sRUFBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUNoRDtZQUNJLE9BQU8sRUFBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUMsQ0FBQztLQUN0RDtBQUNMLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFVRCxTQUFTLHNCQUFzQixDQUFJLE1BQVMsRUFBRSxPQUFZOztVQUNoRCxXQUFXLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7OztVQUdyQyxTQUFTLEdBQUcsQ0FBQyxNQUFNLENBQUM7OztVQUdwQixJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDOztVQUNwQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUU7SUFFdEUsOENBQThDO0lBQzlDLE9BQU8sSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFOztjQUMxQixDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUMsRUFBRTtZQUNILFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDckI7O2NBQ0ssQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDLEVBQUU7WUFDSCxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JCO0tBQ0o7SUFFRCx1QkFBdUI7SUFDdkIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFOztjQUNYLEVBQUUsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFO1FBQ3RCLElBQUksRUFBRSxFQUFFO1lBQ0osU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN0QjtLQUNKO0lBRUQsc0JBQXNCO0lBQ3RCLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRTs7Y0FDVixFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNyQixJQUFJLEVBQUUsRUFBRTtZQUNKLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDdEI7S0FDSjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ3JCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VsZW1lbnRSZWYsIEluamVjdGFibGUsIE5nWm9uZSwgT25EZXN0cm95LCBPcHRpb25hbCwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gICAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICAgIEhvcml6b250YWxDb25uZWN0aW9uUG9zLFxuICAgIE92ZXJsYXksXG4gICAgT3ZlcmxheUNvbmZpZyxcbiAgICBPdmVybGF5UmVmLFxuICAgIFNjcm9sbFN0cmF0ZWd5LFxuICAgIFZlcnRpY2FsQ29ubmVjdGlvblBvc1xufSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge0RpcmVjdGlvbmFsaXR5LCBEaXJlY3Rpb259IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7RVNDQVBFfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtUZW1wbGF0ZVBvcnRhbH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbiwgU3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3Rha2VVbnRpbCwgdGFrZSwgZmlsdGVyLCB0YXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtIY1BvcENvbXBvbmVudH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0hjUG9wb3Zlckhvcml6b250YWxBbGlnbiwgSGNQb3BvdmVyVmVydGljYWxBbGlnbiwgSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksIEhjUG9wb3Zlck9wZW5PcHRpb25zfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSwgTm90aWZpY2F0aW9uQWN0aW9ufSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7SGNQb3BvdmVyQW5jaG9yRGlyZWN0aXZlfSBmcm9tICcuL2RpcmVjdGl2ZXMvcG9wb3Zlci1hbmNob3IuZGlyZWN0aXZlJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBwb3BvdmVyIGZvciB0aGUgYW5jaG9yaW5nIHNlcnZpY2VcbiAqIHRvIGJ1aWxkIHRoZSBjb3JyZWN0IG92ZXJsYXkgY29uZmlnLlxuICovXG5pbnRlcmZhY2UgUG9wb3ZlckNvbmZpZyB7XG4gICAgaG9yaXpvbnRhbEFsaWduOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gICAgdmVydGljYWxBbGlnbjogSGNQb3BvdmVyVmVydGljYWxBbGlnbjtcbiAgICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgICBiYWNrZHJvcENsYXNzOiBzdHJpbmc7XG4gICAgc2Nyb2xsU3RyYXRlZ3k6IEhjUG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICAgIGZvcmNlQWxpZ25tZW50OiBib29sZWFuO1xuICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW47XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIY1BvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gICAgcG9wb3Zlck9wZW5lZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gICAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IGNvbnRhaW5pbmcgdGhlIHBvcG92ZXIgY29tcG9uZW50LiAqL1xuICAgIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmIHwgbnVsbDtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRhcmdldCBwb3BvdmVyLiAqL1xuICAgIHByaXZhdGUgX3BvcG92ZXI6IEhjUG9wQ29tcG9uZW50O1xuXG4gICAgLyoqIFN0b3JlcyB0aGUgY29udGV4dCBhc3NpZ25lZCB0byB0aGUgcG9wb3ZlciAqL1xuICAgIF9jb250ZXh0OiBhbnk7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSB2aWV3IGNvbnRhaW5lciBmb3IgdGhlIHBvcG92ZXIgdGVtcGxhdGUuICovXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciAqL1xuICAgIHByaXZhdGUgX2FuY2hvcjogSGNQb3BvdmVyQW5jaG9yRGlyZWN0aXZlO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIHBvcnRhbCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGF0dGFjaGVkLiAqL1xuICAgIHByaXZhdGUgX3BvcnRhbDogVGVtcGxhdGVQb3J0YWw8YW55PjtcblxuICAgIC8qKiBDb21tdW5pY2F0aW9ucyBjaGFubmVsIHdpdGggdGhlIHBvcG92ZXIuICovXG4gICAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgICAvKiogU2luZ2xlIHN1YnNjcmlwdGlvbiB0byBub3RpZmljYXRpb25zIHNlcnZpY2UgZXZlbnRzLiAqL1xuICAgIHByaXZhdGUgX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gICAgcHJpdmF0ZSBfcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICAgIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgc2VydmljZSBpcyBkZXN0cm95ZWQuICovXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksIHByaXZhdGUgX25nWm9uZTogTmdab25lLCBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5KSB7fVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIC8vIERlc3Ryb3kgcG9wb3ZlciBiZWZvcmUgdGVybWluYXRpbmcgc3Vic2NyaXB0aW9ucyBzbyB0aGF0IGFueSByZXN1bHRpbmdcbiAgICAgICAgLy8gZGV0YWNobWVudHMgdXBkYXRlICdjbG9zZWQgc3RhdGUnXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCk7XG5cbiAgICAgICAgLy8gVGVybWluYXRlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICAgICAgdGhpcy5wb3BvdmVyT3BlbmVkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBBbmNob3IgYSBwb3BvdmVyIGluc3RhbmNlIHRvIGEgdmlldyBhbmQgY29ubmVjdGlvbiBlbGVtZW50LiAqL1xuICAgIGFuY2hvcihwb3BvdmVyOiBIY1BvcENvbXBvbmVudCwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBIY1BvcG92ZXJBbmNob3JEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICAgICAgdGhpcy5fZGVzdHJveVBvcG92ZXIoKTtcblxuICAgICAgICAvLyBBc3NpZ24gbG9jYWwgcmVmc1xuICAgICAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX2FuY2hvciA9IGFuY2hvcjtcblxuICAgICAgICAvLyBQcm92aWRlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gcG9wb3ZlciBhbmQgYW5jaG9yLlxuICAgICAgICAvLyBUaGVuIHN1YnNjcmliZSB0byBub3RpZmljYXRpb25zIHRvIHRha2UgYXBwcm9wcmlhdGUgYWN0aW9ucy5cbiAgICAgICAgdGhpcy5fcG9wb3Zlci5fbm90aWZpY2F0aW9ucyA9IHRoaXMuX25vdGlmaWNhdGlvbnMgPSB0aGlzLl9hbmNob3IuX25vdGlmaWNhdGlvbnMgPSBuZXcgUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldHMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW47XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cbiAgICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW4gPyB0aGlzLmNsb3NlUG9wb3ZlcigpIDogdGhpcy5vcGVuUG9wb3ZlcigpO1xuICAgIH1cblxuICAgIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgICBvcGVuUG9wb3ZlcihvcHRpb25zOiBIY1BvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fcG9wb3Zlck9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9jb21wb25lbnRPdmVybGF5ID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Fc2NhcGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVPcGVuZWRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgICBjbG9zZVBvcG92ZXIodmFsdWU/OiBhbnksIG5laWdoYm9yU3ViTWVudXNBcmVPcGVuOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXIuX2NvbXBvbmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZSwgbmVpZ2hib3JTdWJNZW51c0FyZU9wZW4pO1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5fY29tcG9uZW50T3ZlcmxheS5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICAgIHJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9wb3BvdmVyLl9jb21wb25lbnRPdmVybGF5KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9wb3BvdmVyLl9jb21wb25lbnRPdmVybGF5LmdldENvbmZpZygpO1xuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICAgICAgICBzdHJhdGVneS5yZWFwcGx5TGFzdFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBhbmNob3IgZWxlbWVudC4gKi9cbiAgICBnZXRBbmNob3JFbGVtZW50KCk6IEVsZW1lbnRSZWYge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yLl9lbGVtZW50UmVmO1xuICAgIH1cblxuICAgIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gICAgcHJpdmF0ZSBfYXBwbHlPcGVuT3B0aW9ucyhvcHRpb25zOiBIY1BvcG92ZXJPcGVuT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICAvLyBPbmx5IG92ZXJyaWRlIHJlc3RvcmVGb2N1cyBhcyBgZmFsc2VgIGlmIHRoZSBvcHRpb24gaXMgZXhwbGljaXRseSBgZmFsc2VgXG4gICAgICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5fcmVzdG9yZUZvY3VzT3ZlcnJpZGUgPSByZXN0b3JlRm9jdXM7XG5cbiAgICAgICAgLy8gT25seSBvdmVycmlkZSBhdXRvRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgICAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuX2F1dG9Gb2N1c092ZXJyaWRlID0gYXV0b0ZvY3VzO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gb3ZlcmxheSB0byBiZSBhdHRhY2hlZCB0byB0aGUgcG9ydGFsLiAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIC8vIENyZWF0ZSBvdmVybGF5IGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ246IHRoaXMuX3BvcG92ZXIuaG9yaXpvbnRhbEFsaWduLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IHRoaXMuX3BvcG92ZXIudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgICAgICAgICBiYWNrZHJvcENsYXNzOiB0aGlzLl9wb3BvdmVyLmJhY2tkcm9wQ2xhc3MsXG4gICAgICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX3BvcG92ZXIuc2Nyb2xsU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgbG9ja0FsaWdubWVudDogdGhpcy5fcG9wb3Zlci5sb2NrQWxpZ25tZW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5Q29uZmlnID0gdGhpcy5fZ2V0T3ZlcmxheUNvbmZpZyhwb3BvdmVyQ29uZmlnLCB0aGlzLl9hbmNob3IpO1xuXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9uQ2hhbmdlcyhvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTtcblxuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlDb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BvcG92ZXIuaG9yaXpvbnRhbEFsaWduID09PSAnbW91c2UnIHx8IHRoaXMuX3BvcG92ZXIudmVydGljYWxBbGlnbiA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgLyogSWYgYWxpZ25pbmcgdG8gbW91c2UgY2xpY2tzIC0gYWRqdXN0IHRoZSBzdHJhdGVneSBiYXNlZCBvbiB0aGUgbW9zdCBjdXJyZW50IGNsaWNrICovXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0UG9zaXRpb25TdHJhdGVneShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5mb3JjZUFsaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5sb2NrQWxpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmNob3IuX2VsZW1lbnRSZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICAvKiogUmVtb3ZlcyB0aGUgcG9wb3ZlciBmcm9tIHRoZSBET00uIERvZXMgTk9UIHVwZGF0ZSBvcGVuIHN0YXRlLiAqL1xuICAgIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBwb3BvdmVyIGltbWVkaWF0ZWx5IGlmIGl0IGlzIGNsb3NlZCwgb3Igd2FpdHMgdW50aWwgaXRcbiAgICAgKiBoYXMgYmVlbiBjbG9zZWQgdG8gZGVzdHJveSBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAgICAgICAgICAgLmRldGFjaG1lbnRzKClcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBvcG92ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYXBwcm9wcmlhdGUgYW5jaG9yIG1ldGhvZCB3aGVuIGFuIGV2ZW50IGlzIGRpc3BhdGNoZWQgdGhyb3VnaFxuICAgICAqIHRoZSBub3RpZmljYXRpb24gc2VydmljZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb05vdGlmaWNhdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5fbm90aWZpY2F0aW9ucy5ldmVudHMoKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5PUEVOOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uQ0xPU0U6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVE9HR0xFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTjpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGVuIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQsIGRvIG5vdCBkZXN0cm95XG4gICAgICAgICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVVBEQVRFX0NPTkZJRzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbGlnblBvcG92ZXJUb0FuY2hvcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3AoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgICAgICAgIC5iYWNrZHJvcENsaWNrKClcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLl9wb3BvdmVyLmJhY2tkcm9wQ2xpY2tlZC5lbWl0KCkpLFxuICAgICAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLnBvcG92ZXJDbG9zZWQpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICAgIH1cblxuICAgIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gZXNjYXBlIGtleWRvd24gZXZlbnQgb2NjdXJzLiAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAgICAgICAua2V5ZG93bkV2ZW50cygpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgICAgICAgICAgZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSksXG4gICAgICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3BvcG92ZXIuaW50ZXJhY3RpdmVDbG9zZSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XG4gICAgfVxuXG4gICAgLyoqIFNldCBzdGF0ZSBiYWNrIHRvIGNsb3NlZCB3aGVuIGRldGFjaGVkLiAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgICAgICAgIC5kZXRhY2htZW50cygpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fc2F2ZUNsb3NlZFN0YXRlKCkpO1xuICAgIH1cblxuICAgIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gICAgcHJpdmF0ZSBfc2F2ZU9wZW5lZFN0YXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCB0aGlzLl9wb3BvdmVyLnBhcmVudCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLnBhcmVudC5fc3ViTWVudU9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIub3BlbmVkLmVtaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCh0aGlzLl9jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gICAgcHJpdmF0ZSBfc2F2ZUNsb3NlZFN0YXRlKHZhbHVlPzogYW55LCBuZWlnaGJvclN1Yk1lbnVzQXJlT3BlbjogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIHRoaXMuX3BvcG92ZXIucGFyZW50ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIucGFyZW50Ll9zdWJNZW51T3BlbiA9IG5laWdoYm9yU3ViTWVudXNBcmVPcGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyQ2xvc2VkLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5jbG9zZWQuZW1pdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogR2V0cyB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLiAqL1xuICAgIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIGNvbmZpZyBmb3IgY3JlYXRpbmcgdGhlIG92ZXJsYXkuICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZyhjb25maWc6IFBvcG92ZXJDb25maWcsIGFuY2hvcjogSGNQb3BvdmVyQW5jaG9yRGlyZWN0aXZlKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgICAgIHJldHVybiBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgICAgICAgICAgICAgIGNvbmZpZy5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgICAgICAgICAgY29uZmlnLnZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgICAgICAgY29uZmlnLmZvcmNlQWxpZ25tZW50LFxuICAgICAgICAgICAgICAgIGNvbmZpZy5sb2NrQWxpZ25tZW50LFxuICAgICAgICAgICAgICAgIGFuY2hvci5fZWxlbWVudFJlZlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIG1ha2UgaXQgaGFyZCBmb3IgdXNlcnMgdG8gc2hvb3QgdGhlbXNlbHZlcyBpbiB0aGUgZm9vdCBieSBkaXNhYmxpbmcgYmFja2Ryb3AgaWYgaG92ZXIgaXMgdGhlIHRyaWdnZXJcbiAgICAgICAgICAgIGhhc0JhY2tkcm9wOiBhbmNob3IudHJpZ2dlciAhPT0gJ2hvdmVyJyA/IGNvbmZpZy5oYXNCYWNrZHJvcCA6IGZhbHNlLFxuXG4gICAgICAgICAgICBiYWNrZHJvcENsYXNzOiBjb25maWcuYmFja2Ryb3BDbGFzcyB8fCAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2UoY29uZmlnLnNjcm9sbFN0cmF0ZWd5KSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5fZ2V0RGlyZWN0aW9uKCksXG5cbiAgICAgICAgICAgIC8vIGRpc2FibGUgcG9pbnRlciBldmVudHMgZm9yIGhvdmVyIHBvcG92ZXJzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nIGlzc3Vlc1xuICAgICAgICAgICAgcGFuZWxDbGFzczogYW5jaG9yLnRyaWdnZXIgPT09ICdob3ZlcicgPyAnb3ZlcmxheS1wb2ludGVyLWV2ZW50cycgOiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhbmltYXRpb24gb3JpZ2luIGlzIGNvcnJlY3QsIGV2ZW4gd2l0aCBhIGZhbGxiYWNrIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBjaGFuZ2VzIG1heSBvY2N1ciBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX3NldEFsaWdubWVudENsYXNzZXNGb3JBbmltYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCksXG4gICAgICAgICAgICAgICAgICAgIGdldFZlcnRpY2FsUG9wb3ZlckFsaWdubWVudChjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9zZXRBbGlnbm1lbnRDbGFzc2VzRm9yQXJyb3coXG4gICAgICAgICAgICAgICAgICAgIGdldEhQb3BBbGlnbm1lbnRGb3JBcnJvdyhjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVgsIGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5YKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VlBvcEFsaWdubWVudEZvckFycm93KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSwgY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogTWFwIGEgc2Nyb2xsIHN0cmF0ZWd5IHN0cmluZyB0eXBlIHRvIGFuIGluc3RhbmNlIG9mIGEgc2Nyb2xsIHN0cmF0ZWd5LiAqL1xuICAgIHByaXZhdGUgX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2Uoc3RyYXRlZ3k6IEhjUG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogU2Nyb2xsU3RyYXRlZ3kge1xuICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdjbG9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgICAgICAgY2FzZSAnbm9vcCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbmQgcmV0dXJuIGEgcG9zaXRpb24gc3RyYXRlZ3kgYmFzZWQgb24gY29uZmlnIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuICovXG4gICAgcHJpdmF0ZSBfZ2V0UG9zaXRpb25TdHJhdGVneShcbiAgICAgICAgaG9yaXpvbnRhbFRhcmdldDogSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgICAgICB2ZXJ0aWNhbFRhcmdldDogSGNQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgICAgIGFuY2hvcjogRWxlbWVudFJlZlxuICAgICk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgICAgIC8vIEF0dGFjaCB0aGUgb3ZlcmxheSBhdCB0aGUgcHJlZmVycmVkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24oaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQsIHRoaXMuX3BvcG92ZXIuX29mZnNldFBvcyk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFt0YXJnZXRQb3NpdGlvbl07XG5cbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5XG4gICAgICAgICAgICAucG9zaXRpb24oKVxuICAgICAgICAgICAgLmZsZXhpYmxlQ29ubmVjdGVkVG8oYW5jaG9yKVxuICAgICAgICAgICAgLndpdGhGbGV4aWJsZURpbWVuc2lvbnMoZmFsc2UpXG4gICAgICAgICAgICAud2l0aFB1c2goZmFsc2UpXG4gICAgICAgICAgICAud2l0aFZpZXdwb3J0TWFyZ2luKDApXG4gICAgICAgICAgICAud2l0aExvY2tlZFBvc2l0aW9uKGxvY2tBbGlnbm1lbnQpO1xuXG4gICAgICAgIC8vIFVubGVzcyB0aGUgYWxpZ25tZW50IGlzIGZvcmNlZCwgYWRkIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgcHJlZmVycmVkIHBvc2l0aW9uc1xuICAgICAgICBpZiAoIWZvcmNlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja3MoaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goLi4uZmFsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJhdGVneS53aXRoUG9zaXRpb25zKHBvc2l0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBmYWxsYmFjayBwb3NpdGlvbnMgYmFzZWQgYXJvdW5kIHRhcmdldCBhbGlnbm1lbnRzLiAqL1xuICAgIHByaXZhdGUgX2dldEZhbGxiYWNrcyhoVGFyZ2V0OiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24sIHZUYXJnZXQ6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24pOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRhcmdldCBhbGlnbm1lbnRzIG92ZXJsYXAgdGhlIGFuY2hvclxuICAgICAgICBjb25zdCBob3Jpem9udGFsT3ZlcmxhcEFsbG93ZWQgPSBoVGFyZ2V0ICE9PSAnYmVmb3JlJyAmJiBoVGFyZ2V0ICE9PSAnYWZ0ZXInO1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID0gdlRhcmdldCAhPT0gJ2Fib3ZlJyAmJiB2VGFyZ2V0ICE9PSAnYmVsb3cnO1xuXG4gICAgICAgIC8vIElmIGEgdGFyZ2V0IGFsaWdubWVudCBkb2Vzbid0IGNvdmVyIHRoZSBhbmNob3IsIGRvbid0IGxldCBhbnkgb2YgdGhlIGZhbGxiYWNrIGFsaWdubWVudHNcbiAgICAgICAgLy8gY292ZXIgdGhlIGFuY2hvclxuICAgICAgICBjb25zdCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ25bXSA9IGhvcml6b250YWxPdmVybGFwQWxsb3dlZFxuICAgICAgICAgICAgPyBbJ2JlZm9yZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2FmdGVyJywgJ21vdXNlJ11cbiAgICAgICAgICAgIDogWydiZWZvcmUnLCAnYWZ0ZXInXTtcbiAgICAgICAgY29uc3QgcG9zc2libGVWZXJ0aWNhbEFsaWdubWVudHM6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9IHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWRcbiAgICAgICAgICAgID8gWydhYm92ZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JlbG93JywgJ21vdXNlJ11cbiAgICAgICAgICAgIDogWydhYm92ZScsICdiZWxvdyddO1xuXG4gICAgICAgIC8vIENyZWF0ZSBmYWxsYmFja3MgZm9yIGVhY2ggYWxsb3dlZCBwcmlvcml0aXplZCBmYWxsYmFjayBhbGlnbm1lbnQgY29tYm9cbiAgICAgICAgY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICAgICAgcHJpb3JpdGl6ZUFyb3VuZFRhcmdldChoVGFyZ2V0LCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzKS5mb3JFYWNoKGggPT4ge1xuICAgICAgICAgICAgcHJpb3JpdGl6ZUFyb3VuZFRhcmdldCh2VGFyZ2V0LCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50cykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja3MucHVzaChnZXRQb3NpdGlvbihoLCB2LCB0aGlzLl9wb3BvdmVyLl9vZmZzZXRQb3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGl0ZW0gc2luY2UgaXQgd2lsbCBiZSB0aGUgdGFyZ2V0IGFsaWdubWVudCBhbmQgaXNuJ3QgY29uc2lkZXJlZCBhIGZhbGxiYWNrXG4gICAgICAgIHJldHVybiBmYWxsYmFja3Muc2xpY2UoMSwgZmFsbGJhY2tzLmxlbmd0aCk7XG4gICAgfVxufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQgZm9yIGFycm93IHBvc2l0aW9uaW5nICovXG5mdW5jdGlvbiBnZXRIUG9wQWxpZ25tZW50Rm9yQXJyb3coaE92ZXJsYXk6IEhvcml6b250YWxDb25uZWN0aW9uUG9zLCBoT3JpZ2luOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyk6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbiB7XG4gICAgaWYgKGhPdmVybGF5ID09PSBoT3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBoT3ZlcmxheTtcbiAgICB9XG5cbiAgICBpZiAoaE92ZXJsYXkgPT09ICdzdGFydCcpIHtcbiAgICAgICAgcmV0dXJuICdhZnRlcic7XG4gICAgfVxuXG4gICAgaWYgKGhPdmVybGF5ID09PSAnZW5kJykge1xuICAgICAgICByZXR1cm4gJ2JlZm9yZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQgZm9yIGFycm93IHBvc2l0aW9uaW5nLiAqL1xuZnVuY3Rpb24gZ2V0VlBvcEFsaWdubWVudEZvckFycm93KHZPdmVybGF5OiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsIHZPcmlnaW46IFZlcnRpY2FsQ29ubmVjdGlvblBvcyk6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICAgIGlmICh2T3ZlcmxheSA9PT0gdk9yaWdpbiAmJiAodk92ZXJsYXkgPT09ICd0b3AnIHx8IHZPdmVybGF5ID09PSAnYm90dG9tJykpIHtcbiAgICAgICAgcmV0dXJuIHZPdmVybGF5ID09PSAndG9wJyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICB9XG5cbiAgICBpZiAodk92ZXJsYXkgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiAnYmVsb3cnO1xuICAgIH1cblxuICAgIGlmICh2T3ZlcmxheSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgcmV0dXJuICdhYm92ZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGNkayBwb3NpdGlvbiBwYWlyIGZyb20gSGNQb3BvdmVyIGFsaWdubWVudHMuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihoOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24sIHY6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24sIG9mZnNldDogbnVtYmVyW10pOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyIHtcbiAgICBjb25zdCB7b3JpZ2luWCwgb3ZlcmxheVh9ID0gZ2V0SG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NQYWlyKGgpO1xuICAgIGNvbnN0IHtvcmlnaW5ZLCBvdmVybGF5WX0gPSBnZXRWZXJ0aWNhbENvbm5lY3Rpb25Qb3NQYWlyKHYpO1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7b3JpZ2luWCwgb3JpZ2luWX0sIHtvdmVybGF5WCwgb3ZlcmxheVl9LCBvZmZzZXRbMF0sIG9mZnNldFsxXSk7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudC4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zKTogSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduIHtcbiAgICBpZiAoaCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICByZXR1cm4gJ2FmdGVyJztcbiAgICB9XG5cbiAgICBpZiAoaCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcmV0dXJuICdiZWZvcmUnO1xuICAgIH1cblxuICAgIHJldHVybiAnY2VudGVyJztcbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIG92ZXJsYXkgY29ubmVjdGlvbiBwb3NpdGlvbiB0byBlcXVpdmFsZW50IHBvcG92ZXIgYWxpZ25tZW50LiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxQb3BvdmVyQWxpZ25tZW50KHY6IFZlcnRpY2FsQ29ubmVjdGlvblBvcyk6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICAgIGlmICh2ID09PSAndG9wJykge1xuICAgICAgICByZXR1cm4gJ2JlbG93JztcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgcmV0dXJuICdhYm92ZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoXG4gICAgaDogSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduXG4pOiB7b3JpZ2luWDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3M7IG92ZXJsYXlYOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvc30ge1xuICAgIHN3aXRjaCAoaCkge1xuICAgICAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnc3RhcnQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdzdGFydCd9O1xuICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdzdGFydCd9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnY2VudGVyJywgb3ZlcmxheVg6ICdjZW50ZXInfTtcbiAgICB9XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbGlnbm1lbnQgdG8gb3JpZ2luL292ZXJsYXkgcG9zaXRpb24gcGFpci4gKi9cbmZ1bmN0aW9uIGdldFZlcnRpY2FsQ29ubmVjdGlvblBvc1BhaXIodjogSGNQb3BvdmVyVmVydGljYWxBbGlnbik6IHtvcmlnaW5ZOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3M7IG92ZXJsYXlZOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3N9IHtcbiAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAndG9wJywgb3ZlcmxheVk6ICdib3R0b20nfTtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICBjYXNlICdtb3VzZSc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ3RvcCd9O1xuICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICdib3R0b20nfTtcbiAgICAgICAgY2FzZSAnYmVsb3cnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7b3JpZ2luWTogJ2NlbnRlcicsIG92ZXJsYXlZOiAnY2VudGVyJ307XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIG9yZGVyZWQgYXJyYXkgb3B0aW9ucyBhbmQgcmV0dXJucyBhIHJlb3JkZXJkZWRcbiAqIGFycmF5IGFyb3VuZCB0aGUgdGFyZ2V0IGl0ZW0uIGUuZy46XG4gKlxuICogdGFyZ2V0OiAzOyBvcHRpb25zOiBbMSwgMiwgMywgNCwgNSwgNiwgN107XG4gKlxuICogcmV0dXJuOiBbMywgNCwgMiwgNSwgMSwgNiwgN11cbiAqL1xuZnVuY3Rpb24gcHJpb3JpdGl6ZUFyb3VuZFRhcmdldDxUPih0YXJnZXQ6IFQsIG9wdGlvbnM6IFRbXSk6IFRbXSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBvcHRpb25zLmluZGV4T2YodGFyZ2V0KTtcblxuICAgIC8vIFNldCB0aGUgZmlyc3QgaXRlbSB0byBiZSB0aGUgdGFyZ2V0XG4gICAgY29uc3QgcmVvcmRlcmVkID0gW3RhcmdldF07XG5cbiAgICAvLyBNYWtlIGxlZnQgYW5kIHJpZ2h0IHN0YWNrcyB3aGVyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBpdGVtIGlzIGxhc3RcbiAgICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5zbGljZSgwLCB0YXJnZXRJbmRleCk7XG4gICAgY29uc3QgcmlnaHQgPSBvcHRpb25zLnNsaWNlKHRhcmdldEluZGV4ICsgMSwgb3B0aW9ucy5sZW5ndGgpLnJldmVyc2UoKTtcblxuICAgIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHN0YWNrcyB1bnRpbCBvbmUgaXMgZW1wdHlcbiAgICB3aGlsZSAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHIgPSByaWdodC5wb3AoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJlb3JkZXJlZC5wdXNoKHIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBsZWZ0LnBvcCgpO1xuICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgcmVvcmRlcmVkLnB1c2gobCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbHVzaCBvdXQgcmlnaHQgc2lkZVxuICAgIHdoaWxlIChyaWdodC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcjIgPSByaWdodC5wb3AoKTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICByZW9yZGVyZWQucHVzaChyMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbHVzaCBvdXQgbGVmdCBzaWRlXG4gICAgd2hpbGUgKGxlZnQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGwyID0gbGVmdC5wb3AoKTtcbiAgICAgICAgaWYgKGwyKSB7XG4gICAgICAgICAgICByZW9yZGVyZWQucHVzaChsMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVvcmRlcmVkO1xufVxuIl19