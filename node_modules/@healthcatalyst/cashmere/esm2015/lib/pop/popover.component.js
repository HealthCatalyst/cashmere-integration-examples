/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, ContentChildren, QueryList } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { transformPopover } from './popover.animations';
import { NotificationAction, PopoverNotification } from './notification.service';
import { getUnanchoredPopoverError, getInvalidHorizontalAlignError, getInvalidVerticalAlignError, getInvalidScrollStrategyError } from './popover.errors';
import { VALID_SCROLL, VALID_HORIZ_ALIGN, VALID_VERT_ALIGN } from './types';
import { MenuItemDirective } from './directives/menu-item.directive';
import { Subject } from 'rxjs';
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
const DEFAULT_TRANSITION = '100ms linear';
/** @type {?} */
const EMPTY_TRANSITION = '0ms linear';
export class HcPopComponent {
    /**
     * @param {?} _elementRef
     * @param {?} _focusTrapFactory
     * @param {?} _document
     */
    constructor(_elementRef, _focusTrapFactory, _document) {
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        /**
         * Whether or not to disable default popover container styles. *Defaults to `false`.*
         */
        this.disableStyle = false;
        /**
         * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
         */
        this.showArrow = true;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'below';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = false;
        this._autoFocusOverride = false;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = true;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Should the popover animate? *Defaults to `true`.*
         */
        this.shouldAnimate = true;
        /**
         * Optional backdrop class. *Defaults to `''`.*
         */
        this.backdropClass = '';
        /**
         * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
         */
        this.autoCloseOnContentClick = false;
        /**
         * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Stores the click coordinates for mouse-based positioning
         */
        this._offsetPos = [0, 0];
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        this._yAlignClass = '';
        this._xAlignClass = '';
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
        /**
         * If this menu has children, keep track of whether any of them are open
         */
        this._subMenuOpen = false;
        /**
         * Reference to subscription of parent popover close events
         */
        this._parentClose = new Subject();
        /**
         * Block this popover from closing its parent on close
         */
        this._parentCloseBlock = false;
    }
    /**
     * Alignment of the popover on the horizontal axis. Can be `before`, `start`, `center`, `end`, `after`, or `mouse`.
     * *Defaults to `center`.*
     * @return {?}
     */
    get horizontalAlign() {
        return this._horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set horizontalAlign(val) {
        this._validateHorizontalAlign(val);
        if (this._horizontalAlign !== val) {
            this._horizontalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the x axis. Alias for `horizontalAlign`. *Defaults to `"center"`.*
     * @return {?}
     */
    get xAlign() {
        return this.horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set xAlign(val) {
        this.horizontalAlign = val;
    }
    /**
     * Alignment of the popover on the vertical axis. Can be `above`, `start`, `center`, `end`, `below`, or `mouse`.
     * *Defaults to `"below"`.*
     * @return {?}
     */
    get verticalAlign() {
        return this._verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set verticalAlign(val) {
        this._validateVerticalAlign(val);
        if (this._verticalAlign !== val) {
            this._verticalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the y axis. Alias for `verticalAlign`. *Defaults to `"below"`.*
     * @return {?}
     */
    get yAlign() {
        return this.verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set yAlign(val) {
        this.verticalAlign = val;
    }
    /**
     * Whether the popover always opens with the specified alignment. *Defaults to `false`.*
     * @return {?}
     */
    get forceAlignment() {
        return this._forceAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set forceAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._forceAlignment !== coercedVal) {
            this._forceAlignment = coercedVal;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     * *Defaults to `false`.*
     * @return {?}
     */
    get lockAlignment() {
        return this._lockAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._lockAlignment !== coercedVal) {
            this._lockAlignment = coerceBooleanProperty(val);
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the first focusable element should be focused on open. *Defaults to `false`.*
     * @return {?}
     */
    get autoFocus() {
        return this._autoFocus && this._autoFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFocus(val) {
        this._autoFocus = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should return focus to the previously focused element after closing. *Defaults to `true`.*
     * @return {?}
     */
    get restoreFocus() {
        return this._restoreFocus && this._restoreFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set restoreFocus(val) {
        this._restoreFocus = coerceBooleanProperty(val);
    }
    /**
     * How the popover should handle scrolling. *Defaults to `"reposition"`.*
     * @return {?}
     */
    get scrollStrategy() {
        return this._scrollStrategy;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollStrategy(val) {
        this._validateScrollStrategy(val);
        if (this._scrollStrategy !== val) {
            this._scrollStrategy = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
        }
    }
    /**
     * Whether the popover should have a backdrop (includes closing on click). *Defaults to `true`.*
     * @return {?}
     */
    get hasBackdrop() {
        return this._hasBackdrop;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasBackdrop(val) {
        this._hasBackdrop = coerceBooleanProperty(val);
        this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
    }
    /**
     * Whether the popover should close when the user clicks the backdrop or presses ESC. *Defaults to `true`.*
     * @return {?}
     */
    get interactiveClose() {
        return this._interactiveClose;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set interactiveClose(val) {
        this._interactiveClose = coerceBooleanProperty(val);
        this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
    }
    /**
     * Custom transition to use while opening. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
     * @return {?}
     */
    get openTransition() {
        return this._openTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set openTransition(val) {
        if (val) {
            this._openTransition = val;
        }
    }
    /**
     * Custom transition to use while closing. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
     * @return {?}
     */
    get closeTransition() {
        return this._closeTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeTransition(val) {
        if (val) {
            this._closeTransition = val;
        }
    }
    /**
     * A link to an associated parent menu that will be closed when this menu closes.
     * @return {?}
     */
    get parent() {
        return this._parentMenu;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set parent(val) {
        if (this._parentMenu) {
            this._parentClose.unsubscribe();
        }
        this._parentMenu = val;
        this._parentClose = this._parentMenu.closed.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            if (this.isOpen()) {
                this.close();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setAlignmentClasses();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._notifications) {
            this._notifications.dispose();
        }
        if (this._parentMenu) {
            this._parentClose.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    _popContainerClicked() {
        if (this.autoCloseOnContentClick) {
            this.close();
        }
    }
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    open(options = {}) {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.OPEN, options);
        this._dispatchActionNotification(notification);
    }
    /**
     * Close this popover and its parent (if linked).
     * @param {?=} value
     * @return {?}
     */
    close(value) {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
        if (this.parent && !this._parentCloseBlock) {
            this.parent.close();
        }
    }
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    toggle() {
        if (this.parent) {
            this.parent._subMenuOpen = !this.isOpen();
        }
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realign() {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.REALIGN);
        this._dispatchActionNotification(notification);
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    _getAnimation() {
        return {
            value: 'visible',
            params: {
                openTransition: this.shouldAnimate ? this.openTransition : EMPTY_TRANSITION,
                closeTransition: this.shouldAnimate ? this.closeTransition : EMPTY_TRANSITION
            }
        };
    }
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    }
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._setAlignmentClassesForAnimation(horizAlign, vertAlign);
        this._setAlignmentClassesForArrow();
    }
    /**
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClassesForAnimation(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._classList['hc-pop-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['hc-pop-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['hc-pop-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['hc-pop-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['hc-pop-center'] = horizAlign === 'center' || vertAlign === 'center';
    }
    /**
     * @param {?=} xAlign
     * @param {?=} yAlign
     * @return {?}
     */
    _setAlignmentClassesForArrow(xAlign = this.horizontalAlign, yAlign = this.verticalAlign) {
        this._classList['hc-pop-show-arrow'] =
            (this.showArrow &&
                (xAlign === 'start' || xAlign === 'center' || xAlign === 'end') &&
                (yAlign === 'above' || yAlign === 'below')) ||
                ((yAlign === 'start' || yAlign === 'center' || yAlign === 'end') && (xAlign === 'before' || xAlign === 'after'));
        this._yAlignClass = this._classList['hc-pop-show-arrow'] ? `hc-pop-arrow-y-${yAlign}` : '';
        this._xAlignClass = this._classList['hc-pop-show-arrow'] ? `hc-pop-arrow-x-${xAlign}` : '';
    }
    /**
     * Set the focus of an hcMenu based on a keyboard arrow press
     * @param {?} downPress
     * @return {?}
     */
    _keyFocus(downPress) {
        /** @type {?} */
        let itemArray = this._menuItems.toArray();
        if (!downPress) {
            itemArray.reverse();
        }
        /** @type {?} */
        let selected = false;
        // Determine if any item in the menu is currently focused, and select the next (or previous)
        for (let i = 0; i < itemArray.length; i++) {
            if (selected && !itemArray[i].ref.nativeElement.classList.contains('hc-divider') && !itemArray[i].ref.nativeElement.disabled) {
                itemArray[i].focus();
                return;
            }
            if (itemArray[i].ref.nativeElement === document.activeElement) {
                selected = true;
            }
        }
        // If no item is focused, selected the first (or last) item that isn't a divider or disabled
        for (let i = 0; i < itemArray.length; i++) {
            if (!itemArray[i].ref.nativeElement.classList.contains('hc-divider') && !itemArray[i].ref.nativeElement.disabled) {
                itemArray[i].focus();
                return;
            }
        }
    }
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    _restoreFocusAndDestroyTrap() {
        /** @type {?} */
        const toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus && this._previouslyFocusedElement) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    }
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    }
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    _trapFocus() {
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus && this._focusTrap) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Dispatch a notification to the notification service, if possible.
     * @private
     * @param {?} notification
     * @return {?}
     */
    _dispatchConfigNotification(notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    }
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @private
     * @param {?} notification
     * @return {?}
     */
    _dispatchActionNotification(notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    }
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateHorizontalAlign(pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    }
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateVerticalAlign(pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    }
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _validateScrollStrategy(strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    }
}
HcPopComponent.decorators = [
    { type: Component, args: [{
                selector: 'hc-pop',
                encapsulation: ViewEncapsulation.None,
                animations: [transformPopover],
                template: "<ng-template>\n  <div class=\"hc-pop-container\"\n      #focusTrapElement\n      class=\"{{_yAlignClass}} {{_xAlignClass}}\"\n      [class.hc-pop-container-basic]=\"!disableStyle\"\n      [ngClass]=\"_classList\"\n      (click)=\"_popContainerClicked()\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n    <div *ngIf=\"showArrow\" class=\"hc-pop-arrow {{_yAlignClass}} {{_xAlignClass}}\"></div>\n  </div>\n</ng-template>\n",
                styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-pop-before.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .hc-pop-before.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.hc-pop-before.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .hc-pop-before.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}.hc-pop-before.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .hc-pop-before.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}.hc-pop-center.hc-pop-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.hc-pop-center.hc-pop-below{-webkit-transform-origin:center top;transform-origin:center top}.hc-pop-after.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .hc-pop-after.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.hc-pop-after.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .hc-pop-after.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}.hc-pop-after.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .hc-pop-after.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}.hc-pop-container-basic{background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;padding:12px}.hc-pop-show-arrow .hc-pop-arrow{background-color:#fff;border-style:solid;border-width:1px;display:block;height:10px;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:10px}.hc-pop-arrow-x-start .hc-pop-arrow{left:5px}.hc-pop-arrow-x-center .hc-pop-arrow{left:calc(50% - 6px)}.hc-pop-arrow-x-end .hc-pop-arrow{left:calc(100% - 15px)}.hc-pop-arrow-y-start .hc-pop-arrow{top:5px}.hc-pop-arrow-y-center .hc-pop-arrow{top:calc(50% - 6px)}.hc-pop-arrow-y-end .hc-pop-arrow{top:calc(100% - 15px)}.hc-pop-arrow-y-above .hc-pop-arrow{border-color:transparent #ccc #ccc transparent;bottom:-6px}.hc-pop-arrow-y-below .hc-pop-arrow{border-color:#ccc transparent transparent #ccc;top:-6px}.hc-pop-arrow-x-before .hc-pop-arrow{border-color:#ccc #ccc transparent transparent;right:-6px}.hc-pop-arrow-x-after .hc-pop-arrow{border-color:transparent transparent #ccc #ccc;left:-6px}.hc-pop-arrow-y-above.hc-pop-show-arrow,.hc-pop-arrow-y-below.hc-pop-show-arrow{margin:6px 0;position:relative}.hc-pop-arrow-x-after.hc-pop-show-arrow,.hc-pop-arrow-x-before.hc-pop-show-arrow{margin:0 6px;position:relative}"]
            }] }
];
/** @nocollapse */
HcPopComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FocusTrapFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
HcPopComponent.propDecorators = {
    disableStyle: [{ type: Input }],
    showArrow: [{ type: Input }],
    horizontalAlign: [{ type: Input }],
    xAlign: [{ type: Input }],
    verticalAlign: [{ type: Input }],
    yAlign: [{ type: Input }],
    forceAlignment: [{ type: Input }],
    lockAlignment: [{ type: Input }],
    autoFocus: [{ type: Input }],
    restoreFocus: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    hasBackdrop: [{ type: Input }],
    interactiveClose: [{ type: Input }],
    openTransition: [{ type: Input }],
    closeTransition: [{ type: Input }],
    parent: [{ type: Input }],
    shouldAnimate: [{ type: Input }],
    backdropClass: [{ type: Input }],
    autoCloseOnContentClick: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    afterOpen: [{ type: Output }],
    afterClose: [{ type: Output }],
    backdropClicked: [{ type: Output }],
    overlayKeydown: [{ type: Output }],
    _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement', { static: false },] }],
    _menuItems: [{ type: ContentChildren, args: [MenuItemDirective, { descendants: true },] }]
};
if (false) {
    /**
     * Whether or not to disable default popover container styles. *Defaults to `false`.*
     * @type {?}
     */
    HcPopComponent.prototype.disableStyle;
    /**
     * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
     * @type {?}
     */
    HcPopComponent.prototype.showArrow;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._horizontalAlign;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._verticalAlign;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._forceAlignment;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._lockAlignment;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._autoFocus;
    /** @type {?} */
    HcPopComponent.prototype._autoFocusOverride;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._restoreFocus;
    /** @type {?} */
    HcPopComponent.prototype._restoreFocusOverride;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._hasBackdrop;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._interactiveClose;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._openTransition;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._closeTransition;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._parentMenu;
    /**
     * Should the popover animate? *Defaults to `true`.*
     * @type {?}
     */
    HcPopComponent.prototype.shouldAnimate;
    /**
     * Optional backdrop class. *Defaults to `''`.*
     * @type {?}
     */
    HcPopComponent.prototype.backdropClass;
    /**
     * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
     * @type {?}
     */
    HcPopComponent.prototype.autoCloseOnContentClick;
    /**
     * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
     * @type {?}
     */
    HcPopComponent.prototype.opened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    HcPopComponent.prototype.closed;
    /**
     * Emits when the popover has finished opening.
     * @type {?}
     */
    HcPopComponent.prototype.afterOpen;
    /**
     * Emits when the popover has finished closing.
     * @type {?}
     */
    HcPopComponent.prototype.afterClose;
    /**
     * Emits when the backdrop is clicked.
     * @type {?}
     */
    HcPopComponent.prototype.backdropClicked;
    /**
     * Emits when a keydown event is targeted to this popover's overlay.
     * @type {?}
     */
    HcPopComponent.prototype.overlayKeydown;
    /**
     * Reference to template so it can be placed within a portal.
     * @type {?}
     */
    HcPopComponent.prototype._templateRef;
    /**
     * Stores the click coordinates for mouse-based positioning
     * @type {?}
     */
    HcPopComponent.prototype._offsetPos;
    /**
     * Stores a reference to the associated overlay
     * @type {?}
     */
    HcPopComponent.prototype._componentOverlay;
    /**
     * Classes to be added to the popover for setting the correct transform origin.
     * @type {?}
     */
    HcPopComponent.prototype._classList;
    /** @type {?} */
    HcPopComponent.prototype._yAlignClass;
    /** @type {?} */
    HcPopComponent.prototype._xAlignClass;
    /**
     * Whether the popover is presently open.
     * @type {?}
     */
    HcPopComponent.prototype._open;
    /**
     * Instance of notification service. Will be undefined until attached to an anchor.
     * @type {?}
     */
    HcPopComponent.prototype._notifications;
    /**
     * Reference to the element to build a focus trap around.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrapElement;
    /**
     * Reference to the element that was focused before opening.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._previouslyFocusedElement;
    /**
     * Reference to a focus trap around the popover.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrap;
    /**
     * If this menu has children, keep track of whether any of them are open
     * @type {?}
     */
    HcPopComponent.prototype._subMenuOpen;
    /**
     * Reference to subscription of parent popover close events
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._parentClose;
    /**
     * Block this popover from closing its parent on close
     * @type {?}
     */
    HcPopComponent.prototype._parentCloseBlock;
    /**
     * Reference to hcMenuItems (if the popover contains them)
     * @type {?}
     */
    HcPopComponent.prototype._menuItems;
    /** @type {?} */
    HcPopComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvcG9wL3BvcG92ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBQ0wsU0FBUyxFQUNULGlCQUFpQixFQUNqQixXQUFXLEVBR1gsUUFBUSxFQUNSLE1BQU0sRUFDTixlQUFlLEVBQ2YsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQVksZ0JBQWdCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN0RCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQTZCLE1BQU0sd0JBQXdCLENBQUM7QUFDM0csT0FBTyxFQUNILHlCQUF5QixFQUN6Qiw4QkFBOEIsRUFDOUIsNEJBQTRCLEVBQzVCLDZCQUE2QixFQUNoQyxNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFJSCxZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUVuQixNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNuRSxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDOzs7TUFHdkIsa0JBQWtCLEdBQUcsY0FBYzs7TUFDbkMsZ0JBQWdCLEdBQUcsWUFBWTtBQVNyQyxNQUFNLE9BQU8sY0FBYzs7Ozs7O0lBZ1F2QixZQUNXLFdBQXVCLEVBQ3RCLGlCQUFtQyxFQUNMLFNB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O0lBa0I5QyxxQ0FBb0M7Ozs7O0lBR3BDLHVDQUE4Qjs7Ozs7SUFHOUIsdUNBQTRCOzs7OztJQUc1QixpREFBeUM7Ozs7O0lBR3pDLGdDQUEyQzs7Ozs7SUFHM0MsZ0NBQTJDOzs7OztJQUczQyxtQ0FBK0M7Ozs7O0lBRy9DLG9DQUFnRDs7Ozs7SUFHaEQseUNBQXFEOzs7OztJQUdyRCx3Q0FBNkQ7Ozs7O0lBRzdELHNDQUF3RTs7Ozs7SUFHeEUsb0NBQThCOzs7OztJQUc5QiwyQ0FBOEI7Ozs7O0lBRzlCLG9DQUFxQjs7SUFDckIsc0NBQWtCOztJQUNsQixzQ0FBa0I7Ozs7O0lBR2xCLCtCQUFjOzs7OztJQUdkLHdDQUEyQzs7Ozs7O0lBRzNDLDJDQUNzQzs7Ozs7O0lBR3RDLG1EQUFzRDs7Ozs7O0lBR3RELG9DQUEwQzs7Ozs7SUFHMUMsc0NBQXFDOzs7Ozs7SUFHckMsc0NBQTBDOzs7OztJQUcxQywyQ0FBbUM7Ozs7O0lBR25DLG9DQUFrRzs7SUFHOUYscUNBQThCOzs7OztJQUM5QiwyQ0FBMkM7Ozs7O0lBQzNDLG1DQUFvRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QW5pbWF0aW9uRXZlbnR9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9jdXNUcmFwLCBGb2N1c1RyYXBGYWN0b3J5fSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7dHJhbnNmb3JtUG9wb3Zlcn0gZnJvbSAnLi9wb3BvdmVyLmFuaW1hdGlvbnMnO1xuaW1wb3J0IHtOb3RpZmljYXRpb25BY3Rpb24sIFBvcG92ZXJOb3RpZmljYXRpb24sIFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7XG4gICAgZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcixcbiAgICBnZXRJbnZhbGlkSG9yaXpvbnRhbEFsaWduRXJyb3IsXG4gICAgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcixcbiAgICBnZXRJbnZhbGlkU2Nyb2xsU3RyYXRlZ3lFcnJvclxufSBmcm9tICcuL3BvcG92ZXIuZXJyb3JzJztcbmltcG9ydCB7XG4gICAgSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksXG4gICAgSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgIEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24sXG4gICAgVkFMSURfU0NST0xMLFxuICAgIFZBTElEX0hPUklaX0FMSUdOLFxuICAgIFZBTElEX1ZFUlRfQUxJR04sXG4gICAgSGNQb3BvdmVyT3Blbk9wdGlvbnNcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge092ZXJsYXlSZWZ9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7TWVudUl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9tZW51LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcyc7XG5cbi8vIFNlZSBodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jLjI1LC44LC4yNSwxIGZvciByZWZlcmVuY2UuXG5jb25zdCBERUZBVUxUX1RSQU5TSVRJT04gPSAnMTAwbXMgbGluZWFyJztcbmNvbnN0IEVNUFRZX1RSQU5TSVRJT04gPSAnMG1zIGxpbmVhcic7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaGMtcG9wJyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGFuaW1hdGlvbnM6IFt0cmFuc2Zvcm1Qb3BvdmVyXSxcbiAgICBzdHlsZVVybHM6IFsnLi9wb3BvdmVyLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL3BvcG92ZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIEhjUG9wQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0byBkaXNhYmxlIGRlZmF1bHQgcG9wb3ZlciBjb250YWluZXIgc3R5bGVzLiAqRGVmYXVsdHMgdG8gYGZhbHNlYC4qICovXG4gICAgQElucHV0KCkgZGlzYWJsZVN0eWxlID0gZmFsc2U7XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdG8gc2hvdyBhIGNvbm5lY3Rpb24gYXJyb3cgd2hlbiBwb3NzaWJsZS4gKkRlZmF1bHRzIHRvIGB0cnVlYC4qICovXG4gICAgQElucHV0KCkgc2hvd0Fycm93ID0gdHJ1ZTtcblxuICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIGhvcml6b250YWwgYXhpcy4gQ2FuIGJlIGBiZWZvcmVgLCBgc3RhcnRgLCBgY2VudGVyYCwgYGVuZGAsIGBhZnRlcmAsIG9yIGBtb3VzZWAuXG4gICAgICogKkRlZmF1bHRzIHRvIGBjZW50ZXJgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBob3Jpem9udGFsQWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsQWxpZ247XG4gICAgfVxuICAgIHNldCBob3Jpem9udGFsQWxpZ24odmFsOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIb3Jpem9udGFsQWxpZ24odmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3Jpem9udGFsQWxpZ24gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgX2hvcml6b250YWxBbGlnbjogSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduID0gJ2NlbnRlcic7XG5cbiAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB4IGF4aXMuIEFsaWFzIGZvciBgaG9yaXpvbnRhbEFsaWduYC4gKkRlZmF1bHRzIHRvIGBcImNlbnRlclwiYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgeEFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3Jpem9udGFsQWxpZ247XG4gICAgfVxuICAgIHNldCB4QWxpZ24odmFsOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24pIHtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsQWxpZ24gPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgdmVydGljYWwgYXhpcy4gQ2FuIGJlIGBhYm92ZWAsIGBzdGFydGAsIGBjZW50ZXJgLCBgZW5kYCwgYGJlbG93YCwgb3IgYG1vdXNlYC5cbiAgICAgKiAqRGVmYXVsdHMgdG8gYFwiYmVsb3dcImAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZlcnRpY2FsQWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbEFsaWduO1xuICAgIH1cbiAgICBzZXQgdmVydGljYWxBbGlnbih2YWw6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVWZXJ0aWNhbEFsaWduKHZhbCk7XG4gICAgICAgIGlmICh0aGlzLl92ZXJ0aWNhbEFsaWduICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsQWxpZ24gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgX3ZlcnRpY2FsQWxpZ246IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24gPSAnYmVsb3cnO1xuXG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgeSBheGlzLiBBbGlhcyBmb3IgYHZlcnRpY2FsQWxpZ25gLiAqRGVmYXVsdHMgdG8gYFwiYmVsb3dcImAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHlBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxBbGlnbjtcbiAgICB9XG4gICAgc2V0IHlBbGlnbih2YWw6IEhjUG9wb3ZlclZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbEFsaWduID0gdmFsO1xuICAgIH1cblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGFsd2F5cyBvcGVucyB3aXRoIHRoZSBzcGVjaWZpZWQgYWxpZ25tZW50LiAqRGVmYXVsdHMgdG8gYGZhbHNlYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZm9yY2VBbGlnbm1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JjZUFsaWdubWVudDtcbiAgICB9XG4gICAgc2V0IGZvcmNlQWxpZ25tZW50KHZhbDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgICAgIGlmICh0aGlzLl9mb3JjZUFsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZm9yY2VBbGlnbm1lbnQgPSBjb2VyY2VkVmFsO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9mb3JjZUFsaWdubWVudCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcG9wb3ZlcidzIGFsaWdubWVudCBpcyBsb2NrZWQgYWZ0ZXIgb3BlbmluZy4gVGhpcyBwcmV2ZW50cyB0aGUgcG9wb3ZlclxuICAgICAqIGZyb20gY2hhbmdpbmcgaXRzIGFsaWduZW1lbnQgd2hlbiBzY3JvbGxpbmcgb3IgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqICpEZWZhdWx0cyB0byBgZmFsc2VgLipcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBsb2NrQWxpZ25tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9ja0FsaWdubWVudDtcbiAgICB9XG4gICAgc2V0IGxvY2tBbGlnbm1lbnQodmFsOiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2tBbGlnbm1lbnQgIT09IGNvZXJjZWRWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2tBbGlnbm1lbnQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfbG9ja0FsaWdubWVudCA9IGZhbHNlO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHNob3VsZCBiZSBmb2N1c2VkIG9uIG9wZW4uICpEZWZhdWx0cyB0byBgZmFsc2VgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBhdXRvRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvRm9jdXMgJiYgdGhpcy5fYXV0b0ZvY3VzT3ZlcnJpZGU7XG4gICAgfVxuICAgIHNldCBhdXRvRm9jdXModmFsOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2F1dG9Gb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICBwcml2YXRlIF9hdXRvRm9jdXMgPSBmYWxzZTtcbiAgICBfYXV0b0ZvY3VzT3ZlcnJpZGUgPSBmYWxzZTtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyIGNsb3NpbmcuICpEZWZhdWx0cyB0byBgdHJ1ZWAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHJlc3RvcmVGb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVGb2N1cyAmJiB0aGlzLl9yZXN0b3JlRm9jdXNPdmVycmlkZTtcbiAgICB9XG4gICAgc2V0IHJlc3RvcmVGb2N1cyh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIHByaXZhdGUgX3Jlc3RvcmVGb2N1cyA9IHRydWU7XG4gICAgX3Jlc3RvcmVGb2N1c092ZXJyaWRlID0gdHJ1ZTtcblxuICAgIC8qKiBIb3cgdGhlIHBvcG92ZXIgc2hvdWxkIGhhbmRsZSBzY3JvbGxpbmcuICpEZWZhdWx0cyB0byBgXCJyZXBvc2l0aW9uXCJgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzY3JvbGxTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFN0cmF0ZWd5O1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsU3RyYXRlZ3kodmFsOiBIY1BvcG92ZXJTY3JvbGxTdHJhdGVneSkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVNjcm9sbFN0cmF0ZWd5KHZhbCk7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxTdHJhdGVneSAhPT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5VUERBVEVfQ09ORklHKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3k6IEhjUG9wb3ZlclNjcm9sbFN0cmF0ZWd5ID0gJ3JlcG9zaXRpb24nO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGhhdmUgYSBiYWNrZHJvcCAoaW5jbHVkZXMgY2xvc2luZyBvbiBjbGljaykuICpEZWZhdWx0cyB0byBgdHJ1ZWAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhhc0JhY2tkcm9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzQmFja2Ryb3A7XG4gICAgfVxuICAgIHNldCBoYXNCYWNrZHJvcCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5faGFzQmFja2Ryb3AgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUcpKTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfaGFzQmFja2Ryb3AgPSB0cnVlO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGNsb3NlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrZHJvcCBvciBwcmVzc2VzIEVTQy4gKkRlZmF1bHRzIHRvIGB0cnVlYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaW50ZXJhY3RpdmVDbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlQ2xvc2U7XG4gICAgfVxuICAgIHNldCBpbnRlcmFjdGl2ZUNsb3NlKHZhbDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5VUERBVEVfQ09ORklHKSk7XG4gICAgfVxuICAgIHByaXZhdGUgX2ludGVyYWN0aXZlQ2xvc2UgPSB0cnVlO1xuXG4gICAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBvcGVuaW5nLiAqRGVmYXVsdHMgdG8gYCcyMDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSdgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBvcGVuVHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5UcmFuc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgb3BlblRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zaXRpb24gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfb3BlblRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG5cbiAgICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIGNsb3NpbmcuICpEZWZhdWx0cyB0byBgJzIwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJ2AuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGNsb3NlVHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlVHJhbnNpdGlvbjtcbiAgICB9XG4gICAgc2V0IGNsb3NlVHJhbnNpdGlvbih2YWw6IHN0cmluZykge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zaXRpb24gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfY2xvc2VUcmFuc2l0aW9uID0gREVGQVVMVF9UUkFOU0lUSU9OO1xuXG4gICAgLyoqIEEgbGluayB0byBhbiBhc3NvY2lhdGVkIHBhcmVudCBtZW51IHRoYXQgd2lsbCBiZSBjbG9zZWQgd2hlbiB0aGlzIG1lbnUgY2xvc2VzLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHBhcmVudCgpOiBIY1BvcENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRNZW51O1xuICAgIH1cbiAgICBzZXQgcGFyZW50KHZhbDogSGNQb3BDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudENsb3NlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyZW50TWVudSA9IHZhbDtcbiAgICAgICAgdGhpcy5fcGFyZW50Q2xvc2UgPSB0aGlzLl9wYXJlbnRNZW51LmNsb3NlZC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcml2YXRlIF9wYXJlbnRNZW51OiBIY1BvcENvbXBvbmVudDtcblxuICAgIC8qKiBTaG91bGQgdGhlIHBvcG92ZXIgYW5pbWF0ZT8gKkRlZmF1bHRzIHRvIGB0cnVlYC4qICovXG4gICAgQElucHV0KCkgc2hvdWxkQW5pbWF0ZSA9IHRydWU7XG5cbiAgICAvKiogT3B0aW9uYWwgYmFja2Ryb3AgY2xhc3MuICpEZWZhdWx0cyB0byBgJydgLiogKi9cbiAgICBASW5wdXQoKSBiYWNrZHJvcENsYXNzID0gJyc7XG5cbiAgICAvKiogU2V0IHRvIHRydWUgaWYgY2xpY2tpbmcgYW55d2hlcmUgaW5zaWRlIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSBpdC4gKkRlZmF1bHRzIHRvIGBmYWxzZWAuKiAqL1xuICAgIEBJbnB1dCgpIGF1dG9DbG9zZU9uQ29udGVudENsaWNrID0gZmFsc2U7XG5cbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuIElmIGBjb250ZXh0YCB3YXMgc2V0IG9uIHRoZSBhbmNob3IsIGl0IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoaXMgZXZlbnQuICovXG4gICAgQE91dHB1dCgpIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICAgIEBPdXRwdXQoKSBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGhhcyBmaW5pc2hlZCBvcGVuaW5nLiAqL1xuICAgIEBPdXRwdXQoKSBhZnRlck9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBoYXMgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICBAT3V0cHV0KCkgYWZ0ZXJDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICAgIEBPdXRwdXQoKSBiYWNrZHJvcENsaWNrZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdHMgd2hlbiBhIGtleWRvd24gZXZlbnQgaXMgdGFyZ2V0ZWQgdG8gdGhpcyBwb3BvdmVyJ3Mgb3ZlcmxheS4gKi9cbiAgICBAT3V0cHV0KCkgb3ZlcmxheUtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIHRlbXBsYXRlIHNvIGl0IGNhbiBiZSBwbGFjZWQgd2l0aGluIGEgcG9ydGFsLiAqL1xuICAgIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYsIHtzdGF0aWM6IGZhbHNlfSkgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIFN0b3JlcyB0aGUgY2xpY2sgY29vcmRpbmF0ZXMgZm9yIG1vdXNlLWJhc2VkIHBvc2l0aW9uaW5nICovXG4gICAgX29mZnNldFBvczogbnVtYmVyW10gPSBbMCwgMF07XG5cbiAgICAvKiogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBhc3NvY2lhdGVkIG92ZXJsYXkgKi9cbiAgICBfY29tcG9uZW50T3ZlcmxheTogT3ZlcmxheVJlZjtcblxuICAgIC8qKiBDbGFzc2VzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyIGZvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4uICovXG4gICAgX2NsYXNzTGlzdDogYW55ID0ge307XG4gICAgX3lBbGlnbkNsYXNzID0gJyc7XG4gICAgX3hBbGlnbkNsYXNzID0gJyc7XG5cbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgICBfb3BlbiA9IGZhbHNlO1xuXG4gICAgLyoqIEluc3RhbmNlIG9mIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBhdHRhY2hlZCB0byBhbiBhbmNob3IuICovXG4gICAgX25vdGlmaWNhdGlvbnM6IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBidWlsZCBhIGZvY3VzIHRyYXAgYXJvdW5kLiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2ZvY3VzVHJhcEVsZW1lbnQnLCB7c3RhdGljOiBmYWxzZX0pXG4gICAgcHJpdmF0ZSBfZm9jdXNUcmFwRWxlbWVudDogRWxlbWVudFJlZjtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgb3BlbmluZy4gKi9cbiAgICBwcml2YXRlIF9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbDtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gYSBmb2N1cyB0cmFwIGFyb3VuZCB0aGUgcG9wb3Zlci4gKi9cbiAgICBwcml2YXRlIF9mb2N1c1RyYXA6IEZvY3VzVHJhcCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKiBJZiB0aGlzIG1lbnUgaGFzIGNoaWxkcmVuLCBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgYW55IG9mIHRoZW0gYXJlIG9wZW4gKi9cbiAgICBwdWJsaWMgX3N1Yk1lbnVPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIHN1YnNjcmlwdGlvbiBvZiBwYXJlbnQgcG9wb3ZlciBjbG9zZSBldmVudHMgKi9cbiAgICBwcml2YXRlIF9wYXJlbnRDbG9zZTogYW55ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIC8qKiBCbG9jayB0aGlzIHBvcG92ZXIgZnJvbSBjbG9zaW5nIGl0cyBwYXJlbnQgb24gY2xvc2UgKi9cbiAgICBfcGFyZW50Q2xvc2VCbG9jazogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byBoY01lbnVJdGVtcyAoaWYgdGhlIHBvcG92ZXIgY29udGFpbnMgdGhlbSkgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKE1lbnVJdGVtRGlyZWN0aXZlLCB7ZGVzY2VuZGFudHM6IHRydWV9KSBfbWVudUl0ZW1zOiBRdWVyeUxpc3Q8TWVudUl0ZW1EaXJlY3RpdmU+O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfZm9jdXNUcmFwRmFjdG9yeTogRm9jdXNUcmFwRmFjdG9yeSxcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueVxuICAgICkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50TWVudSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Q2xvc2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wb3BDb250YWluZXJDbGlja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2VPbkNvbnRlbnRDbGljaykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE9wZW4gdGhpcyBwb3BvdmVyLiAqL1xuICAgIG9wZW4ob3B0aW9uczogSGNQb3BvdmVyT3Blbk9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uT1BFTiwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlIHRoaXMgcG9wb3ZlciBhbmQgaXRzIHBhcmVudCAoaWYgbGlua2VkKS4gKi9cbiAgICBjbG9zZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uQ0xPU0UsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICF0aGlzLl9wYXJlbnRDbG9zZUJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZSB0aGlzIHBvcG92ZXIgb3BlbiBvciBjbG9zZWQuICovXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zdWJNZW51T3BlbiA9ICF0aGlzLmlzT3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5UT0dHTEUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgIH1cblxuICAgIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gICAgcmVhbGlnbigpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR04pO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgIH1cblxuICAgIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICB9XG5cbiAgICAvKiogR2V0cyBhbiBhbmltYXRpb24gY29uZmlnIHdpdGggY3VzdG9taXplZCAob3IgZGVmYXVsdCkgdHJhbnNpdGlvbiB2YWx1ZXMuICovXG4gICAgX2dldEFuaW1hdGlvbigpOiB7dmFsdWU6IGFueTsgcGFyYW1zOiBhbnl9IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiAndmlzaWJsZScsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBvcGVuVHJhbnNpdGlvbjogdGhpcy5zaG91bGRBbmltYXRlID8gdGhpcy5vcGVuVHJhbnNpdGlvbiA6IEVNUFRZX1RSQU5TSVRJT04sXG4gICAgICAgICAgICAgICAgY2xvc2VUcmFuc2l0aW9uOiB0aGlzLnNob3VsZEFuaW1hdGUgPyB0aGlzLmNsb3NlVHJhbnNpdGlvbiA6IEVNUFRZX1RSQU5TSVRJT05cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgICBfb25BbmltYXRpb25Eb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJPcGVuLmVtaXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50b1N0YXRlID09PSAndm9pZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQ2xvc2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gICAgX3NldEFsaWdubWVudENsYXNzZXMoaG9yaXpBbGlnbiA9IHRoaXMuaG9yaXpvbnRhbEFsaWduLCB2ZXJ0QWxpZ24gPSB0aGlzLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgdGhpcy5fc2V0QWxpZ25tZW50Q2xhc3Nlc0ZvckFuaW1hdGlvbihob3JpekFsaWduLCB2ZXJ0QWxpZ24pO1xuICAgICAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzRm9yQXJyb3coKTtcbiAgICB9XG5cbiAgICBfc2V0QWxpZ25tZW50Q2xhc3Nlc0ZvckFuaW1hdGlvbihob3JpekFsaWduID0gdGhpcy5ob3Jpem9udGFsQWxpZ24sIHZlcnRBbGlnbiA9IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1iZWZvcmUnXSA9IGhvcml6QWxpZ24gPT09ICdiZWZvcmUnIHx8IGhvcml6QWxpZ24gPT09ICdlbmQnO1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1hZnRlciddID0gaG9yaXpBbGlnbiA9PT0gJ2FmdGVyJyB8fCBob3JpekFsaWduID09PSAnc3RhcnQnO1xuXG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnaGMtcG9wLWFib3ZlJ10gPSB2ZXJ0QWxpZ24gPT09ICdhYm92ZScgfHwgdmVydEFsaWduID09PSAnZW5kJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydoYy1wb3AtYmVsb3cnXSA9IHZlcnRBbGlnbiA9PT0gJ2JlbG93JyB8fCB2ZXJ0QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydoYy1wb3AtY2VudGVyJ10gPSBob3JpekFsaWduID09PSAnY2VudGVyJyB8fCB2ZXJ0QWxpZ24gPT09ICdjZW50ZXInO1xuICAgIH1cblxuICAgIF9zZXRBbGlnbm1lbnRDbGFzc2VzRm9yQXJyb3coeEFsaWduID0gdGhpcy5ob3Jpem9udGFsQWxpZ24sIHlBbGlnbiA9IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1zaG93LWFycm93J10gPVxuICAgICAgICAgICAgKHRoaXMuc2hvd0Fycm93ICYmXG4gICAgICAgICAgICAgICAgKHhBbGlnbiA9PT0gJ3N0YXJ0JyB8fCB4QWxpZ24gPT09ICdjZW50ZXInIHx8IHhBbGlnbiA9PT0gJ2VuZCcpICYmXG4gICAgICAgICAgICAgICAgKHlBbGlnbiA9PT0gJ2Fib3ZlJyB8fCB5QWxpZ24gPT09ICdiZWxvdycpKSB8fFxuICAgICAgICAgICAgKCh5QWxpZ24gPT09ICdzdGFydCcgfHwgeUFsaWduID09PSAnY2VudGVyJyB8fCB5QWxpZ24gPT09ICdlbmQnKSAmJiAoeEFsaWduID09PSAnYmVmb3JlJyB8fCB4QWxpZ24gPT09ICdhZnRlcicpKTtcblxuICAgICAgICB0aGlzLl95QWxpZ25DbGFzcyA9IHRoaXMuX2NsYXNzTGlzdFsnaGMtcG9wLXNob3ctYXJyb3cnXSA/IGBoYy1wb3AtYXJyb3cteS0ke3lBbGlnbn1gIDogJyc7XG4gICAgICAgIHRoaXMuX3hBbGlnbkNsYXNzID0gdGhpcy5fY2xhc3NMaXN0WydoYy1wb3Atc2hvdy1hcnJvdyddID8gYGhjLXBvcC1hcnJvdy14LSR7eEFsaWdufWAgOiAnJztcbiAgICB9XG5cbiAgICAvKiogU2V0IHRoZSBmb2N1cyBvZiBhbiBoY01lbnUgYmFzZWQgb24gYSBrZXlib2FyZCBhcnJvdyBwcmVzcyAqL1xuICAgIF9rZXlGb2N1cyhkb3duUHJlc3M6IGJvb2xlYW4pIHtcbiAgICAgICAgbGV0IGl0ZW1BcnJheSA9IHRoaXMuX21lbnVJdGVtcy50b0FycmF5KCk7XG4gICAgICAgIGlmICghZG93blByZXNzKSB7XG4gICAgICAgICAgICBpdGVtQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiBhbnkgaXRlbSBpbiB0aGUgbWVudSBpcyBjdXJyZW50bHkgZm9jdXNlZCwgYW5kIHNlbGVjdCB0aGUgbmV4dCAob3IgcHJldmlvdXMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgIWl0ZW1BcnJheVtpXS5yZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2hjLWRpdmlkZXInKSAmJiAhaXRlbUFycmF5W2ldLnJlZi5uYXRpdmVFbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbUFycmF5W2ldLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1BcnJheVtpXS5yZWYubmF0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGl0ZW0gaXMgZm9jdXNlZCwgc2VsZWN0ZWQgdGhlIGZpcnN0IChvciBsYXN0KSBpdGVtIHRoYXQgaXNuJ3QgYSBkaXZpZGVyIG9yIGRpc2FibGVkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW1BcnJheVtpXS5yZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2hjLWRpdmlkZXInKSAmJiAhaXRlbUFycmF5W2ldLnJlZi5uYXRpdmVFbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbUFycmF5W2ldLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJlc3RvcmUgZm9jdXMgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgb3BlbmVkLiBBbHNvIGRlc3Ryb3kgdHJhcC4gKi9cbiAgICBfcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gTXVzdCBjaGVjayBhY3RpdmUgZWxlbWVudCBpcyBmb2N1c2FibGUgZm9yIElFIHNha2VcbiAgICAgICAgaWYgKHRvRm9jdXMgJiYgJ2ZvY3VzJyBpbiB0b0ZvY3VzICYmIHRoaXMucmVzdG9yZUZvY3VzICYmIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c1RyYXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBmb2N1c2VkIGJlZm9yZSB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkLiAqL1xuICAgIF9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gICAgcHJpdmF0ZSBfdHJhcEZvY3VzKCk6IHZvaWQge1xuICAgICAgICAvLyBUaGVyZSB3b24ndCBiZSBhIGZvY3VzIHRyYXAgZWxlbWVudCBpZiB0aGUgY2xvc2UgYW5pbWF0aW9uIHN0YXJ0cyBiZWZvcmUgb3BlbiBmaW5pc2hlc1xuICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvRm9jdXMgJiYgdGhpcy5fZm9jdXNUcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERpc3BhdGNoIGEgbm90aWZpY2F0aW9uIHRvIHRoZSBub3RpZmljYXRpb24gc2VydmljZSwgaWYgcG9zc2libGUuICovXG4gICAgcHJpdmF0ZSBfZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBQb3BvdmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFuZCB0aHJvdyBpZiB1bmFibGUgdG8uICovXG4gICAgcHJpdmF0ZSBfZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBQb3BvdmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fbm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9ucy5kaXNwYXRjaChub3RpZmljYXRpb24pO1xuICAgIH1cblxuICAgIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFsaWdubWVudCBpcyBub3QgYSB2YWxpZCBob3Jpem9udGFsQWxpZ24uICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVIb3Jpem9udGFsQWxpZ24ocG9zOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24pOiB2b2lkIHtcbiAgICAgICAgaWYgKFZBTElEX0hPUklaX0FMSUdOLmluZGV4T2YocG9zKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGdldEludmFsaWRIb3Jpem9udGFsQWxpZ25FcnJvcihwb3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIHZlcnRpY2FsQWxpZ24uICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVWZXJ0aWNhbEFsaWduKHBvczogSGNQb3BvdmVyVmVydGljYWxBbGlnbik6IHZvaWQge1xuICAgICAgICBpZiAoVkFMSURfVkVSVF9BTElHTi5pbmRleE9mKHBvcykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRJbnZhbGlkVmVydGljYWxBbGlnbkVycm9yKHBvcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzY3JvbGwgc3RyYXRlZ3kgaXMgbm90IGEgdmFsaWQgc3RyYXRlZ3kuICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVTY3JvbGxTdHJhdGVneShzdHJhdGVneTogSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICAgICAgaWYgKFZBTElEX1NDUk9MTC5pbmRleE9mKHN0cmF0ZWd5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==