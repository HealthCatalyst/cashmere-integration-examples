/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/date-range/date-range.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Output, EventEmitter, Input, ElementRef, Directive, HostListener } from '@angular/core';
import { DatePipe } from '@angular/common';
import { CalendarOverlayService } from '../services/calendar-overlay.service';
import { ConfigStoreService } from '../services/config-store.service';
export class DateRangeDirective {
    /**
     * @param {?} _elementRef
     * @param {?} calendarOverlayService
     * @param {?} configStoreService
     */
    constructor(_elementRef, calendarOverlayService, configStoreService) {
        this._elementRef = _elementRef;
        this.calendarOverlayService = calendarOverlayService;
        this.configStoreService = configStoreService;
        /**
         * Emits when date range is been changed.
         */
        this.selectedDateRangeChanged = new EventEmitter();
        /**
         * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
         */
        this.selectedPresetChanged = new EventEmitter();
        configStoreService.rangeUpdate$.subscribe((/**
         * @param {?} daterange
         * @return {?}
         */
        (daterange) => {
            this.selectedDateRangeChanged.emit(daterange);
        }));
        configStoreService.presetUpdate$.subscribe((/**
         * @param {?} preset
         * @return {?}
         */
        (preset) => {
            this.selectedPresetChanged.emit(preset);
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.detach();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['options']) {
            /** @type {?} */
            const options = changes['options'].currentValue;
            this.configStoreService.updateDateRangeOptions(options);
        }
        if (changes['selectedDate']) {
            /** @type {?} */
            const selectedDate = changes['selectedDate'].currentValue;
            if (typeof selectedDate === 'number') {
                this.configStoreService.updatePreset(selectedDate);
            }
            else {
                this.configStoreService.updateRange(selectedDate);
            }
        }
    }
    /**
     * @return {?}
     */
    _onClick() {
        this._overlayRef = this.calendarOverlayService.open(this._elementRef);
    }
}
DateRangeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hcDateRange]',
                providers: [CalendarOverlayService, ConfigStoreService, DatePipe]
            },] }
];
/** @nocollapse */
DateRangeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: CalendarOverlayService },
    { type: ConfigStoreService }
];
DateRangeDirective.propDecorators = {
    selectedDateRangeChanged: [{ type: Output }],
    selectedDate: [{ type: Input }],
    selectedPresetChanged: [{ type: Output }],
    options: [{ type: Input }],
    _onClick: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /**
     * Emits when date range is been changed.
     * @type {?}
     */
    DateRangeDirective.prototype.selectedDateRangeChanged;
    /**
     * Sets the selected date range. Accepts either a `DateRange` or a numerical index for preset.
     * @type {?}
     */
    DateRangeDirective.prototype.selectedDate;
    /**
     * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
     * @type {?}
     */
    DateRangeDirective.prototype.selectedPresetChanged;
    /**
     * Configuration to setup behavior of component.
     * @type {?}
     */
    DateRangeDirective.prototype.options;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype.calendarOverlayService;
    /** @type {?} */
    DateRangeDirective.prototype.configStoreService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvZGF0ZS1yYW5nZS9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFTLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFhLFVBQVUsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUEyQixNQUFNLGVBQWUsQ0FBQztBQUM1SSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekMsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sc0NBQXNDLENBQUM7QUFFNUUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFNcEUsTUFBTSxPQUFPLGtCQUFrQjs7Ozs7O0lBbUIzQixZQUNZLFdBQXlDLEVBQ3pDLHNCQUE4QyxFQUMvQyxrQkFBc0M7UUFGckMsZ0JBQVcsR0FBWCxXQUFXLENBQThCO1FBQ3pDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDL0MsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjs7OztRQW5CeEMsNkJBQXdCLEdBQTRCLElBQUksWUFBWSxFQUFhLENBQUM7Ozs7UUFRbEYsMEJBQXFCLEdBQXFDLElBQUksWUFBWSxFQUFzQixDQUFDO1FBYXRHLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxTQUFTOzs7O1FBQUMsQ0FBQyxTQUFvQixFQUFFLEVBQUU7WUFDL0QsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNsRCxDQUFDLEVBQUMsQ0FBQztRQUNILGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxTQUFTOzs7O1FBQUMsQ0FBQyxNQUEwQixFQUFFLEVBQUU7WUFDdEUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QyxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7SUFFRCxRQUFRLEtBQUksQ0FBQzs7OztJQUViLFdBQVc7UUFDUCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUM3QjtJQUNMLENBQUM7Ozs7O0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFOztrQkFDZCxPQUFPLEdBQXFCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFZO1lBQ2pFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMzRDtRQUNELElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFOztrQkFDbkIsWUFBWSxHQUF1QixPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsWUFBWTtZQUU3RSxJQUFLLE9BQU8sWUFBWSxLQUFLLFFBQVEsRUFBRztnQkFDcEMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ3JEO1NBQ0o7SUFDTCxDQUFDOzs7O0lBR0QsUUFBUTtRQUNKLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDMUUsQ0FBQzs7O1lBL0RKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsU0FBUyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxDQUFDO2FBQ3BFOzs7O1lBVnVELFVBQVU7WUFHMUQsc0JBQXNCO1lBRXRCLGtCQUFrQjs7O3VDQVFyQixNQUFNOzJCQUlOLEtBQUs7b0NBSUwsTUFBTTtzQkFJTixLQUFLO3VCQTBDTCxZQUFZLFNBQUMsT0FBTzs7Ozs7OztJQXREckIsc0RBQzJGOzs7OztJQUczRiwwQ0FDaUM7Ozs7O0lBR2pDLG1EQUMwRzs7Ozs7SUFHMUcscUNBQzBCOzs7OztJQUUxQix5Q0FBZ0M7Ozs7O0lBRzVCLHlDQUFpRDs7Ozs7SUFDakQsb0RBQXNEOztJQUN0RCxnREFBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge09uSW5pdCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIEVsZW1lbnRSZWYsIERpcmVjdGl2ZSwgSG9zdExpc3RlbmVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRlUGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7T3ZlcmxheVJlZn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHtDYWxlbmRhck92ZXJsYXlTZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9jYWxlbmRhci1vdmVybGF5LnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRlUmFuZ2UsIERhdGVSYW5nZU9wdGlvbnN9IGZyb20gJy4uL21vZGVsL21vZGVsJztcbmltcG9ydCB7Q29uZmlnU3RvcmVTZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9jb25maWctc3RvcmUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2hjRGF0ZVJhbmdlXScsXG4gICAgcHJvdmlkZXJzOiBbQ2FsZW5kYXJPdmVybGF5U2VydmljZSwgQ29uZmlnU3RvcmVTZXJ2aWNlLCBEYXRlUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVJhbmdlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gICAgLyoqIEVtaXRzIHdoZW4gZGF0ZSByYW5nZSBpcyBiZWVuIGNoYW5nZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgc2VsZWN0ZWREYXRlUmFuZ2VDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8RGF0ZVJhbmdlPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZVJhbmdlPigpO1xuXG4gICAgLyoqIFNldHMgdGhlIHNlbGVjdGVkIGRhdGUgcmFuZ2UuIEFjY2VwdHMgZWl0aGVyIGEgYERhdGVSYW5nZWAgb3IgYSBudW1lcmljYWwgaW5kZXggZm9yIHByZXNldC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkRGF0ZTogbnVtYmVyIHwgRGF0ZVJhbmdlO1xuXG4gICAgLyoqIEVtaXRzIGVpdGhlciBhIG51bWVyaWNhbCBpbmRleCBmb3IgdGhlIHNlbGVjdGVkIHByZXNldCwgb3IgYSBgRGF0ZVJhbmdlYCBpZiB0aGUgc2VsZWN0ZWQgdmFsdWUgaXMgbm90IGEgcHJlc2V0ICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgc2VsZWN0ZWRQcmVzZXRDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgRGF0ZVJhbmdlPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgRGF0ZVJhbmdlPigpO1xuXG4gICAgLyoqIENvbmZpZ3VyYXRpb24gdG8gc2V0dXAgYmVoYXZpb3Igb2YgY29tcG9uZW50LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgb3B0aW9uczogRGF0ZVJhbmdlT3B0aW9ucztcblxuICAgIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MSW5wdXRFbGVtZW50PixcbiAgICAgICAgcHJpdmF0ZSBjYWxlbmRhck92ZXJsYXlTZXJ2aWNlOiBDYWxlbmRhck92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgY29uZmlnU3RvcmVTZXJ2aWNlOiBDb25maWdTdG9yZVNlcnZpY2VcbiAgICApIHtcbiAgICAgICAgY29uZmlnU3RvcmVTZXJ2aWNlLnJhbmdlVXBkYXRlJC5zdWJzY3JpYmUoKGRhdGVyYW5nZTogRGF0ZVJhbmdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlQ2hhbmdlZC5lbWl0KGRhdGVyYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdTdG9yZVNlcnZpY2UucHJlc2V0VXBkYXRlJC5zdWJzY3JpYmUoKHByZXNldDogbnVtYmVyIHwgRGF0ZVJhbmdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUHJlc2V0Q2hhbmdlZC5lbWl0KHByZXNldCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge31cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ29wdGlvbnMnXSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogRGF0ZVJhbmdlT3B0aW9ucyA9IGNoYW5nZXNbJ29wdGlvbnMnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1N0b3JlU2VydmljZS51cGRhdGVEYXRlUmFuZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydzZWxlY3RlZERhdGUnXSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXRlOiBudW1iZXIgfCBEYXRlUmFuZ2UgPSBjaGFuZ2VzWydzZWxlY3RlZERhdGUnXS5jdXJyZW50VmFsdWU7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdGVkRGF0ZSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTdG9yZVNlcnZpY2UudXBkYXRlUHJlc2V0KHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU3RvcmVTZXJ2aWNlLnVwZGF0ZVJhbmdlKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgX29uQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLmNhbGVuZGFyT3ZlcmxheVNlcnZpY2Uub3Blbih0aGlzLl9lbGVtZW50UmVmKTtcbiAgICB9XG59XG4iXX0=