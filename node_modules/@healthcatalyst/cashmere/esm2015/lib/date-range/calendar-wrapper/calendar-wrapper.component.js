/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/calendar-wrapper/calendar-wrapper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewChild, Input, ChangeDetectionStrategy, ViewEncapsulation, Output, EventEmitter, HostBinding } from '@angular/core';
import { ConfigStoreService } from '../services/config-store.service';
import { CalendarComponent } from '../../datepicker/calendar/calendar.component';
import { DatepickerInputDirective } from '../../datepicker/datepicker-input/datepicker-input.directive';
/**
 * Component combining a calendar and input as a representation of a date
 */
export class CalendarWrapperComponent {
    /**
     * @param {?} configStore
     */
    constructor(configStore) {
        this.configStore = configStore;
        this._hostClass = true;
        /**
         * Emits when selected date has changed.
         */
        this.selectedDateChange = new EventEmitter();
        /**
         * Whether the pickers include the calendar, time selector, or both. Defaults to `date`.
         */
        this.mode = 'date';
        /**
         * Whether the time picker should use a 12 or 24 hour clock. Defaults to 12.
         */
        this.hourCycle = 12;
        this.weekendFilter = (/**
         * @return {?}
         */
        () => true);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Necessary to force view refresh
        if (changes.selectedDate) {
            /** @type {?} */
            const date = changes.selectedDate.currentValue;
            if (date) {
                this.hcCalendar.activeDate = date;
                this.datePickerInput.setDate(date);
                this.selectedDateChange.emit(date);
            }
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    _onCalendarChange(date) {
        this.selectedDateChange.emit(date);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        if (this.mode === 'time') {
            /** @type {?} */
            let tempVal = event.value ? new Date(1900, 1, 1, event.value.getHours(), event.value.getMinutes()) : new Date(1900, 1, 1);
            /** @type {?} */
            let minVal = this.minDate ? new Date(1900, 1, 1, this.minDate.getHours(), this.minDate.getMinutes()) : new Date(1900, 1, 1);
            /** @type {?} */
            let maxVal = this.maxDate ? new Date(1900, 1, 1, this.maxDate.getHours(), this.maxDate.getMinutes()) : new Date(1900, 1, 2);
            if (tempVal < minVal || tempVal > maxVal) {
                this.selectedDate = undefined;
                this.selectedDateChange.emit(undefined);
            }
            else {
                this.selectedDateChange.emit(event.value || undefined);
            }
        }
        else {
            if (event.value && ((this.minDate && event.value < this.minDate) || (this.maxDate && event.value > this.maxDate))) {
                this.selectedDate = undefined;
                this.selectedDateChange.emit(undefined);
            }
            else {
                this.selectedDateChange.emit(event.value || undefined);
            }
        }
    }
    /**
     * Focus inner input
     * @return {?}
     */
    focusInput() {
        this.datePickerInput.focus();
    }
}
CalendarWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'hc-calendar-wrapper',
                template: "<div class=\"form-container\">\n    <hc-form-field class=\"hc-calendar-wrapper-form-field\">\n        <hc-label [innerText]=\"prefixLabel\"></hc-label>\n        <input\n            hcInput\n            hcDatepicker\n            [(ngModel)]=\"selectedDate\"\n            required\n            (dateChange)=\"_onInputChange($event)\"\n            [min]=\"minDate\"\n            [max]=\"maxDate\"\n            [_mode]=\"mode\"\n            [_hourCycle]=\"hourCycle\"\n        />\n        <hc-error [innerText]=\"invalidDateLabel\"></hc-error>\n    </hc-form-field>\n</div>\n<hc-calendar\n    [mode]=\"mode\"\n    [hourCycle]=\"hourCycle\"\n    [startAt]=\"selectedDate\"\n    [selected]=\"selectedDate\"\n    [minDate]=\"minDate\"\n    [maxDate]=\"maxDate\"\n    (selectedChange)=\"_onCalendarChange($event)\"\n    [dateFilter]=\"configStore.weekendFilter\"\n>\n</hc-calendar>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".hc-calendar-wrapper-form-field>.hc-form-field-wrapper{height:70px;padding-bottom:0}.hc-calendar-wrapper>.form-container{padding-left:13px}"]
            }] }
];
/** @nocollapse */
CalendarWrapperComponent.ctorParameters = () => [
    { type: ConfigStoreService }
];
CalendarWrapperComponent.propDecorators = {
    _hostClass: [{ type: HostBinding, args: ['class.hc-calendar-wrapper',] }],
    hcCalendar: [{ type: ViewChild, args: [CalendarComponent, { static: true },] }],
    datePickerInput: [{ type: ViewChild, args: [DatepickerInputDirective, { static: true },] }],
    selectedDateChange: [{ type: Output }],
    selectedDate: [{ type: Input }],
    dateFormat: [{ type: Input }],
    mode: [{ type: Input }],
    hourCycle: [{ type: Input }],
    prefixLabel: [{ type: Input }],
    excludeWeekends: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    invalidDateLabel: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    CalendarWrapperComponent.prototype._hostClass;
    /** @type {?} */
    CalendarWrapperComponent.prototype.hcCalendar;
    /** @type {?} */
    CalendarWrapperComponent.prototype.datePickerInput;
    /**
     * Emits when selected date has changed.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.selectedDateChange;
    /**
     * Current selected date.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.selectedDate;
    /** @type {?} */
    CalendarWrapperComponent.prototype.dateFormat;
    /**
     * Whether the pickers include the calendar, time selector, or both. Defaults to `date`.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.mode;
    /**
     * Whether the time picker should use a 12 or 24 hour clock. Defaults to 12.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.hourCycle;
    /**
     * Prefix label on top of component.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.prefixLabel;
    /**
     * Flag to filter out weekends.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.excludeWeekends;
    /**
     * The minimum selectable date.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.minDate;
    /**
     * The maximum selectable date.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.maxDate;
    /**
     * Message displayed when a date is invalid.
     * @type {?}
     */
    CalendarWrapperComponent.prototype.invalidDateLabel;
    /** @type {?} */
    CalendarWrapperComponent.prototype.weekendFilter;
    /** @type {?} */
    CalendarWrapperComponent.prototype.configStore;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItd3JhcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvZGF0ZS1yYW5nZS9jYWxlbmRhci13cmFwcGVyL2NhbGVuZGFyLXdyYXBwZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxTQUFTLEVBQ1QsS0FBSyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsTUFBTSxFQUNOLFlBQVksRUFHWixXQUFXLEVBQ2QsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFDcEUsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sOENBQThDLENBQUM7QUFDL0UsT0FBTyxFQUFDLHdCQUF3QixFQUF5QixNQUFNLDhEQUE4RCxDQUFDOzs7O0FBVzlILE1BQU0sT0FBTyx3QkFBd0I7Ozs7SUFtRGpDLFlBQW1CLFdBQStCO1FBQS9CLGdCQUFXLEdBQVgsV0FBVyxDQUFvQjtRQWpEbEQsZUFBVSxHQUFHLElBQUksQ0FBQzs7OztRQVVULHVCQUFrQixHQUFvQixJQUFJLFlBQVksRUFBSyxDQUFDOzs7O1FBV3JFLFNBQUksR0FBa0MsTUFBTSxDQUFDOzs7O1FBSTdDLGNBQVMsR0FBVyxFQUFFLENBQUM7UUFzQnZCLGtCQUFhOzs7UUFBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUM7SUFFMEIsQ0FBQzs7Ozs7SUFFdEQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLGtDQUFrQztRQUNsQyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7O2tCQUNoQixJQUFJLEdBQU0sT0FBTyxDQUFDLFlBQVksQ0FBQyxZQUFZO1lBQ2pELElBQUksSUFBSSxFQUFFO2dCQUNOLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDbEMs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Qjt5QkFHdkMsU0FBUyxTQUFDLGlCQUFpQixFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQzs4QkFHM0MsU0FBUyxTQUFDLHdCQUF3QixFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQztpQ0FJbEQsTUFBTTsyQkFJTixLQUFLO3lCQUdMLEtBQUs7bUJBSUwsS0FBSzt3QkFJTCxLQUFLOzBCQUlMLEtBQUs7OEJBSUwsS0FBSztzQkFJTCxLQUFLO3NCQUlMLEtBQUs7K0JBSUwsS0FBSzs7OztJQTdDTiw4Q0FDa0I7O0lBRWxCLDhDQUM4Qjs7SUFFOUIsbURBQzBDOzs7OztJQUcxQyxzREFDcUU7Ozs7O0lBR3JFLGdEQUM0Qjs7SUFFNUIsOENBQ21COzs7OztJQUduQix3Q0FDNkM7Ozs7O0lBRzdDLDZDQUN1Qjs7Ozs7SUFHdkIsK0NBQ29COzs7OztJQUdwQixtREFDeUI7Ozs7O0lBR3pCLDJDQUN1Qjs7Ozs7SUFHdkIsMkNBQ3VCOzs7OztJQUd2QixvREFDeUI7O0lBRXpCLGlEQUEyQjs7SUFFZiwrQ0FBc0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBWaWV3Q2hpbGQsXG4gICAgSW5wdXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgT3V0cHV0LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBPbkNoYW5nZXMsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBIb3N0QmluZGluZ1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29uZmlnU3RvcmVTZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9jb25maWctc3RvcmUuc2VydmljZSc7XG5pbXBvcnQge0NhbGVuZGFyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRlcGlja2VyL2NhbGVuZGFyL2NhbGVuZGFyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RhdGVwaWNrZXJJbnB1dERpcmVjdGl2ZSwgSGNEYXRlcGlja2VySW5wdXRFdmVudH0gZnJvbSAnLi4vLi4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLWlucHV0L2RhdGVwaWNrZXItaW5wdXQuZGlyZWN0aXZlJztcbmltcG9ydCB7RH0gZnJvbSAnLi4vLi4vZGF0ZXBpY2tlci9kYXRldGltZS9kYXRlLWZvcm1hdHMnO1xuXG4vKiogQ29tcG9uZW50IGNvbWJpbmluZyBhIGNhbGVuZGFyIGFuZCBpbnB1dCBhcyBhIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF0ZSAgKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaGMtY2FsZW5kYXItd3JhcHBlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NhbGVuZGFyLXdyYXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhbGVuZGFyLXdyYXBwZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIENhbGVuZGFyV3JhcHBlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5oYy1jYWxlbmRhci13cmFwcGVyJylcbiAgICBfaG9zdENsYXNzID0gdHJ1ZTtcblxuICAgIEBWaWV3Q2hpbGQoQ2FsZW5kYXJDb21wb25lbnQsIHtzdGF0aWM6IHRydWV9KVxuICAgIGhjQ2FsZW5kYXI6IENhbGVuZGFyQ29tcG9uZW50O1xuXG4gICAgQFZpZXdDaGlsZChEYXRlcGlja2VySW5wdXREaXJlY3RpdmUsIHtzdGF0aWM6IHRydWV9KVxuICAgIGRhdGVQaWNrZXJJbnB1dDogRGF0ZXBpY2tlcklucHV0RGlyZWN0aXZlO1xuXG4gICAgLyoqIEVtaXRzIHdoZW4gc2VsZWN0ZWQgZGF0ZSBoYXMgY2hhbmdlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBzZWxlY3RlZERhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEPiA9IG5ldyBFdmVudEVtaXR0ZXI8RD4oKTtcblxuICAgIC8qKiBDdXJyZW50IHNlbGVjdGVkIGRhdGUuICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZERhdGU6IEQgfCB1bmRlZmluZWQ7XG5cbiAgICBASW5wdXQoKVxuICAgIGRhdGVGb3JtYXQ6IHN0cmluZztcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwaWNrZXJzIGluY2x1ZGUgdGhlIGNhbGVuZGFyLCB0aW1lIHNlbGVjdG9yLCBvciBib3RoLiBEZWZhdWx0cyB0byBgZGF0ZWAuICovXG4gICAgQElucHV0KClcbiAgICBtb2RlOiAnZGF0ZScgfCAndGltZScgfCAnZGF0ZS10aW1lJyA9ICdkYXRlJztcblxuICAgIC8qKiBXaGV0aGVyIHRoZSB0aW1lIHBpY2tlciBzaG91bGQgdXNlIGEgMTIgb3IgMjQgaG91ciBjbG9jay4gRGVmYXVsdHMgdG8gMTIuICovXG4gICAgQElucHV0KClcbiAgICBob3VyQ3ljbGU6IG51bWJlciA9IDEyO1xuXG4gICAgLyoqIFByZWZpeCBsYWJlbCBvbiB0b3Agb2YgY29tcG9uZW50LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJlZml4TGFiZWw6IHN0cmluZztcblxuICAgIC8qKiBGbGFnIHRvIGZpbHRlciBvdXQgd2Vla2VuZHMuICovXG4gICAgQElucHV0KClcbiAgICBleGNsdWRlV2Vla2VuZHM6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluRGF0ZTogRCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gICAgQElucHV0KClcbiAgICBtYXhEYXRlOiBEIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqIE1lc3NhZ2UgZGlzcGxheWVkIHdoZW4gYSBkYXRlIGlzIGludmFsaWQuICovXG4gICAgQElucHV0KClcbiAgICBpbnZhbGlkRGF0ZUxhYmVsOiBzdHJpbmc7XG5cbiAgICB3ZWVrZW5kRmlsdGVyID0gKCkgPT4gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb25maWdTdG9yZTogQ29uZmlnU3RvcmVTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICAvLyBOZWNlc3NhcnkgdG8gZm9yY2UgdmlldyByZWZyZXNoXG4gICAgICAgIGlmIChjaGFuZ2VzLnNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZTogRCA9IGNoYW5nZXMuc2VsZWN0ZWREYXRlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oY0NhbGVuZGFyLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlcklucHV0LnNldERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vbkNhbGVuZGFyQ2hhbmdlKGRhdGU6IEQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICB9XG5cbiAgICBfb25JbnB1dENoYW5nZShldmVudDogSGNEYXRlcGlja2VySW5wdXRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGxldCB0ZW1wVmFsID0gZXZlbnQudmFsdWUgPyBuZXcgRGF0ZSgxOTAwLCAxLCAxLCBldmVudC52YWx1ZS5nZXRIb3VycygpLCBldmVudC52YWx1ZS5nZXRNaW51dGVzKCkpIDogbmV3IERhdGUoMTkwMCwgMSwgMSk7XG4gICAgICAgICAgICBsZXQgbWluVmFsID0gdGhpcy5taW5EYXRlID8gbmV3IERhdGUoMTkwMCwgMSwgMSwgdGhpcy5taW5EYXRlLmdldEhvdXJzKCksIHRoaXMubWluRGF0ZS5nZXRNaW51dGVzKCkpIDogbmV3IERhdGUoMTkwMCwgMSwgMSk7XG4gICAgICAgICAgICBsZXQgbWF4VmFsID0gdGhpcy5tYXhEYXRlID8gbmV3IERhdGUoMTkwMCwgMSwgMSwgdGhpcy5tYXhEYXRlLmdldEhvdXJzKCksIHRoaXMubWF4RGF0ZS5nZXRNaW51dGVzKCkpIDogbmV3IERhdGUoMTkwMCwgMSwgMik7XG5cbiAgICAgICAgICAgIGlmICh0ZW1wVmFsIDwgbWluVmFsIHx8IHRlbXBWYWwgPiBtYXhWYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZUNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlQ2hhbmdlLmVtaXQoZXZlbnQudmFsdWUgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChldmVudC52YWx1ZSAmJiAoKHRoaXMubWluRGF0ZSAmJiBldmVudC52YWx1ZSA8IHRoaXMubWluRGF0ZSkgfHwgKHRoaXMubWF4RGF0ZSAmJiBldmVudC52YWx1ZSA+IHRoaXMubWF4RGF0ZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZUNoYW5nZS5lbWl0KGV2ZW50LnZhbHVlIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRm9jdXMgaW5uZXIgaW5wdXQgKi9cbiAgICBmb2N1c0lucHV0KCkge1xuICAgICAgICB0aGlzLmRhdGVQaWNrZXJJbnB1dC5mb2N1cygpO1xuICAgIH1cbn1cbiJdfQ==