/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/tab-set/tab-set.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, Input, QueryList, Output, ViewEncapsulation } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { TabComponent } from '../tab/tab.component';
import { ActivatedRoute, Router } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { parseBooleanAttribute } from '../../util';
export class TabChangeEvent {
    /**
     * @param {?} index
     * @param {?} tab
     */
    constructor(index, tab) {
        this.index = index;
        this.tab = tab;
    }
}
if (false) {
    /** @type {?} */
    TabChangeEvent.prototype.index;
    /** @type {?} */
    TabChangeEvent.prototype.tab;
}
/**
 * @param {?} tabsWithoutRouterLink
 * @return {?}
 */
export function throwErrorForMissingRouterLink(tabsWithoutRouterLink) {
    /** @type {?} */
    const tabTitles = tabsWithoutRouterLink.map((/**
     * @param {?} tab
     * @return {?}
     */
    tab => tab.tabTitle));
    throw Error(`Routerlink missing on ${tabTitles.join(',')}`);
}
/** @type {?} */
const supportedDirections = ['horizontal', 'vertical'];
/**
 * @param {?} inputStr
 * @return {?}
 */
export function validateDirectionInput(inputStr) {
    if (supportedDirections.indexOf(inputStr) < 0) {
        throw Error('Unsupported tab direction value: ' + inputStr);
    }
}
/**
 * @return {?}
 */
export function tabComponentMissing() {
    return new Error(`TabSet must contain at least one TabComponent. Make sure to add a hc-tab to the hc-tab-set element.`);
}
/**
 * @param {?} tabVal
 * @return {?}
 */
export function invalidDefaultTab(tabVal) {
    throw Error('Invalid default tab value: ' + tabVal + ". Must be 'none' or a value less than the total number of tabs in the set.");
}
export class TabSetComponent {
    /**
     * @param {?} router
     * @param {?} route
     */
    constructor(router, route) {
        this.router = router;
        this.route = route;
        this._routerEnabled = false;
        this._direction = 'vertical';
        this._defaultTab = 0;
        this._stopTabSubscriptionSubject = new Subject();
        /**
         * Emits when the selected tab is changed
         */
        this.selectedTabChange = new EventEmitter();
        this._addContentContainer = true;
        this._tight = false;
    }
    /**
     * Specify direction of tabs as either `horizontal` or `vertical`. Defaults to `vertical`
     * @return {?}
     */
    get direction() {
        return this._direction;
    }
    /**
     * @param {?} directionType
     * @return {?}
     */
    set direction(directionType) {
        validateDirectionInput(directionType);
        this._direction = directionType;
    }
    /**
     * Zero-based numerical value specifying which tab to select by default, setting to `none` means no tab
     * will be immediately selected. Defaults to 0 (the first tab).
     * @return {?}
     */
    get defaultTab() {
        return this._defaultTab;
    }
    /**
     * @param {?} tabValue
     * @return {?}
     */
    set defaultTab(tabValue) {
        if (!isNaN(+tabValue) || tabValue === 'none') {
            this._defaultTab = tabValue;
        }
        else {
            invalidDefaultTab(tabValue);
        }
    }
    /**
     * Determines whether the tab set will create a router-outlet or ng-container for the tab content.
     * If set to false, the app will need to add its own container.  Defaults to `true`.
     * @return {?}
     */
    get addContentContainer() {
        return this._addContentContainer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set addContentContainer(value) {
        this._addContentContainer = parseBooleanAttribute(value);
    }
    /**
     * If true, condense the default padding on all included tabs. *Defaults to `false`.*
     * @return {?}
     */
    get tight() {
        return this._tight;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tight(value) {
        this._tight = parseBooleanAttribute(value);
        this.setTabDirection();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setUpTabs();
        this._tabs.changes.subscribe((/**
         * @return {?}
         */
        () => this.setUpTabs()));
    }
    /**
     * @private
     * @return {?}
     */
    setUpTabs() {
        if (this._tabs.length === 0) {
            throw tabComponentMissing();
        }
        if (this.defaultTab !== 'none') {
            this.defaultToFirstTab();
        }
        this.checkForRouterUse();
        this.setTabDirection();
        this.subscribeToTabClicks();
    }
    /**
     * @private
     * @return {?}
     */
    setTabDirection() {
        setTimeout((/**
         * @return {?}
         */
        () => this._tabs.forEach((/**
         * @param {?} t
         * @return {?}
         */
        t => {
            t._direction = this.direction;
            t._tight = this.tight;
        }))));
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToTabClicks() {
        this._stopTabSubscriptionSubject.next();
        this._tabs.forEach((/**
         * @param {?} t
         * @return {?}
         */
        t => t.tabClick.pipe(takeUntil(this._stopTabSubscriptionSubject)).subscribe((/**
         * @return {?}
         */
        () => this._setActive(t)))));
    }
    /**
     * Sets the currently selected tab by either its numerical index or `TabComponent` object
     * @param {?} tab
     * @return {?}
     */
    selectTab(tab) {
        /** @type {?} */
        const activeTab = typeof tab === 'number' ? this._tabs.toArray()[tab] : tab;
        this._setActive(activeTab);
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    _setActive(tab) {
        /** @type {?} */
        let activeIndex = 0;
        this._tabs.toArray().forEach((/**
         * @param {?} t
         * @param {?} index
         * @return {?}
         */
        (t, index) => {
            t._active = false;
            if (t === tab) {
                activeIndex = index;
            }
        }));
        tab._active = true;
        this.tabContent = tab.tabContent;
        this.selectedTabChange.emit(new TabChangeEvent(activeIndex, tab));
    }
    /**
     * @private
     * @return {?}
     */
    defaultToFirstTab() {
        if (!this._tabs.find((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._active))) {
            // setTimeout to avoid change after checked error
            // when ngFor is used as projected nodes are registered
            // and stored as part of the existing view, not
            // the view in which they are projected
            // embedded views are checked *before* AfterContentInit
            // is triggered
            /** @type {?} */
            const tabArray = this._tabs.toArray();
            if (tabArray[Number(this.defaultTab)]) {
                setTimeout((/**
                 * @return {?}
                 */
                () => this._setActive(tabArray[Number(this.defaultTab)])));
            }
            else {
                invalidDefaultTab(this.defaultTab);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkForRouterUse() {
        /** @type {?} */
        const countUsingRouter = this._tabs.filter((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab.routerLink !== undefined)).length;
        if (countUsingRouter > 0 && countUsingRouter < this._tabs.length) {
            /** @type {?} */
            const tabsMissingRouterLink = this._tabs.filter((/**
             * @param {?} tab
             * @return {?}
             */
            tab => tab.routerLink === undefined));
            throwErrorForMissingRouterLink(tabsMissingRouterLink);
        }
        if (countUsingRouter === this._tabs.length) {
            this._routerEnabled = true;
            if (this._defaultTab !== 'none') {
                this.defaultToFirstRoute();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    defaultToFirstRoute() {
        /** @type {?} */
        const foundRoute = this._tabs
            .map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab.routerLink))
            .map((/**
         * @param {?} routerLink
         * @return {?}
         */
        routerLink => this.mapRouterLinkToString(routerLink)))
            .find((/**
         * @param {?} routerLink
         * @return {?}
         */
        routerLink => {
            /** @type {?} */
            let currentRoute = this.router.url;
            return currentRoute === routerLink || currentRoute.indexOf(`${routerLink}/`) > -1;
        }));
        if (foundRoute) {
            return;
        }
        /** @type {?} */
        const tabArray = this._tabs.toArray();
        if (tabArray[Number(this.defaultTab)]) {
            /** @type {?} */
            const firstRoute = this.mapRouterLinkToString(tabArray[Number(this.defaultTab)].routerLink);
            this.router.navigate([firstRoute], { relativeTo: this.route });
        }
    }
    /**
     * @private
     * @param {?} routerLink
     * @return {?}
     */
    mapRouterLinkToString(routerLink) {
        if (routerLink instanceof Array) {
            routerLink = routerLink.join('/').replace('//', '/');
        }
        return routerLink;
    }
}
TabSetComponent.decorators = [
    { type: Component, args: [{
                selector: `hc-tab-set`,
                template: "<div class=\"hc-{{direction}}-tab-container\">\n    <div class=\"hc-tab-bar-{{direction}}\">\n        <ng-content select=\"hc-tab\"></ng-content>\n        <ng-content></ng-content>\n    </div>\n    <div *ngIf=\"_addContentContainer\" class=\"hc-tab-content-{{direction}}\">\n        <router-outlet *ngIf=\"_routerEnabled\"></router-outlet>\n        <ng-container *ngIf=\"!_routerEnabled\" [ngTemplateOutlet]=\"tabContent\"></ng-container>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".hc-horizontal-tab-container{height:auto;width:100%}.hc-tab-bar-horizontal{-webkit-box-align:baseline;align-items:baseline;background-color:inherit;border-bottom:1px solid #c0c5cc;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.hc-tab-content-horizontal{background-color:inherit;height:100%;overflow:auto;width:100%}.hc-vertical-tab-container{display:-webkit-box;display:flex;height:100%;width:100%}.hc-tab-bar-vertical{background-color:#fff;padding:15px 0;width:20%}.hc-tab-content-vertical{background-color:#f0f3f6;width:80%}"]
            }] }
];
/** @nocollapse */
TabSetComponent.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];
TabSetComponent.propDecorators = {
    _tabs: [{ type: ContentChildren, args: [TabComponent,] }],
    selectedTabChange: [{ type: Output }],
    direction: [{ type: Input }],
    defaultTab: [{ type: Input }],
    addContentContainer: [{ type: Input }],
    tight: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TabSetComponent.prototype._routerEnabled;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype._direction;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype._defaultTab;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype._stopTabSubscriptionSubject;
    /**
     * The content to be displayed for the currently selected tab.
     * This is read from the tab when it is selected.
     * Not used when this component uses routing.
     * @type {?}
     */
    TabSetComponent.prototype.tabContent;
    /** @type {?} */
    TabSetComponent.prototype._tabs;
    /**
     * Emits when the selected tab is changed
     * @type {?}
     */
    TabSetComponent.prototype.selectedTabChange;
    /** @type {?} */
    TabSetComponent.prototype._addContentContainer;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype._tight;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype.router;
    /**
     * @type {?}
     * @private
     */
    TabSetComponent.prototype.route;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLXNldC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvdGFicy90YWItc2V0L3RhYi1zZXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFtQixTQUFTLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3hILE9BQU8sRUFBQyxZQUFZLEVBQWMsTUFBTSxlQUFlLENBQUM7QUFDeEQsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxjQUFjLEVBQUUsTUFBTSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDdkQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDekMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRWpELE1BQU0sT0FBTyxjQUFjOzs7OztJQUN2QixZQUFtQixLQUFhLEVBQVMsR0FBaUI7UUFBdkMsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQWM7SUFBRyxDQUFDO0NBQ2pFOzs7SUFEZSwrQkFBb0I7O0lBQUUsNkJBQXdCOzs7Ozs7QUFHOUQsTUFBTSxVQUFVLDhCQUE4QixDQUFDLHFCQUFxQzs7VUFDMUUsU0FBUyxHQUFHLHFCQUFxQixDQUFDLEdBQUc7Ozs7SUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUM7SUFDaEUsTUFBTSxLQUFLLENBQUMseUJBQXlCLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7O01BRUssbUJBQW1CLEdBQUcsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDOzs7OztBQUV0RCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsUUFBZ0I7SUFDbkQsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzNDLE1BQU0sS0FBSyxDQUFDLG1DQUFtQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0tBQy9EO0FBQ0wsQ0FBQzs7OztBQUVELE1BQU0sVUFBVSxtQkFBbUI7SUFDL0IsT0FBTyxJQUFJLEtBQUssQ0FBQyxxR0FBcUcsQ0FBQyxDQUFDO0FBQzVILENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLE1BQXVCO0lBQ3JELE1BQU0sS0FBSyxDQUFDLDZCQUE2QixHQUFHLE1BQU0sR0FBRyw0RUFBNEUsQ0FBQyxDQUFDO0FBQ3ZJLENBQUM7QUFRRCxNQUFNLE9BQU8sZUFBZTs7Ozs7SUFxRXhCLFlBQW9CLE1BQWMsRUFBVSxLQUFxQjtRQUE3QyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFwRWpFLG1CQUFjLEdBQVksS0FBSyxDQUFDO1FBQ3hCLGVBQVUsR0FBVyxVQUFVLENBQUM7UUFDaEMsZ0JBQVcsR0FBb0IsQ0FBQyxDQUFDO1FBQ2pDLGdDQUEyQixHQUFpQixJQUFJLE9BQU8sRUFBRSxDQUFDOzs7O1FBYWxFLHNCQUFpQixHQUFpQyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBdUNyRSx5QkFBb0IsR0FBWSxJQUFJLENBQUM7UUFXN0IsV0FBTSxHQUFHLEtBQUssQ0FBQztJQUU2QyxDQUFDOzs7OztJQWpEckUsSUFDSSxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzNCLENBQUM7Ozs7O0lBRUQsSUFBSSxTQUFTLENBQUMsYUFBcUI7UUFDL0Isc0JBQXNCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7SUFDcEMsQ0FBQzs7Ozs7O0lBSUQsSUFDSSxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzVCLENBQUM7Ozs7O0lBRUQsSUFBSSxVQUFVLENBQUMsUUFBeUI7UUFDcEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsS0FBSyxNQUFNLEVBQUU7WUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUM7U0FDL0I7YUFBTTtZQUNILGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQy9CO0lBQ0wsQ0FBQzs7Ozs7O0lBSUQsSUFDSSxtQkFBbUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7SUFDckMsQ0FBQzs7Ozs7SUFFRCxJQUFJLG1CQUFtQixDQUFDLEtBQUs7UUFDekIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdELENBQUM7Ozs7O0lBS0QsSUFDSSxLQUFLO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7Ozs7O0lBQ0QsSUFBSSxLQUFLLENBQUMsS0FBSztRQUNYLElBQUksQ0FBQyxNQUFNLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQzNCLENBQUM7Ozs7SUFLRCxrQkFBa0I7UUFDZCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUzs7O1FBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFDLENBQUM7SUFDekQsQ0FBQzs7Ozs7SUFFTyxTQUFTO1FBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxtQkFBbUIsRUFBRSxDQUFDO1NBQy9CO1FBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLE1BQU0sRUFBRTtZQUM1QixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUM1QjtRQUNELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzs7OztJQUVPLGVBQWU7UUFDbkIsVUFBVTs7O1FBQUMsR0FBRyxFQUFFLENBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDbkIsQ0FBQyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQzlCLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUMxQixDQUFDLEVBQUMsRUFDTCxDQUFDO0lBQ04sQ0FBQzs7Ozs7SUFFTyxvQkFBb0I7UUFDeEIsSUFBSSxDQUFDLDJCQUEyQixDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTzs7OztRQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUMsU0FBUzs7O1FBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDLENBQUM7SUFDOUgsQ0FBQzs7Ozs7O0lBR0QsU0FBUyxDQUFDLEdBQTBCOztjQUMxQixTQUFTLEdBQUcsT0FBTyxHQUFHLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHO1FBQzNFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDL0IsQ0FBQzs7Ozs7SUFFRCxVQUFVLENBQUMsR0FBaUI7O1lBQ3BCLFdBQVcsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTzs7Ozs7UUFBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUN0QyxDQUFDLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztZQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUU7Z0JBQ1gsV0FBVyxHQUFHLEtBQUssQ0FBQzthQUN2QjtRQUNMLENBQUMsRUFBQyxDQUFDO1FBQ0gsR0FBRyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFjLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdEUsQ0FBQzs7Ozs7SUFFTyxpQkFBaUI7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTs7OztRQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBQyxFQUFFOzs7Ozs7OztrQkFPaEMsUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQ3JDLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRTtnQkFDbkMsVUFBVTs7O2dCQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUM7YUFDeEU7aUJBQU07Z0JBQ0gsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3RDO1NBQ0o7SUFDTCxDQUFDOzs7OztJQUVPLGlCQUFpQjs7Y0FDZixnQkFBZ0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07Ozs7UUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFDLENBQUMsTUFBTTtRQUN0RixJQUFJLGdCQUFnQixHQUFHLENBQUMsSUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTs7a0JBQ3hELHFCQUFxQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTTs7OztZQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsS0FBSyxTQUFTLEVBQUM7WUFDcEYsOEJBQThCLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQUksZ0JBQWdCLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDeEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7WUFDM0IsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLE1BQU0sRUFBRTtnQkFDN0IsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7YUFDOUI7U0FDSjtJQUNMLENBQUM7Ozs7O0lBRU8sbUJBQW1COztjQUNqQixVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUs7YUFDeEIsR0FBRzs7OztRQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBQzthQUMxQixHQUFHOzs7O1FBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLEVBQUM7YUFDekQsSUFBSTs7OztRQUFDLFVBQVUsQ0FBQyxFQUFFOztnQkFDWCxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHO1lBQ2xDLE9BQU8sWUFBWSxLQUFLLFVBQVUsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0RixDQUFDLEVBQUM7UUFFTixJQUFJLFVBQVUsRUFBRTtZQUNaLE9BQU87U0FDVjs7Y0FFSyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDckMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFOztrQkFDN0IsVUFBVSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMzRixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDO1NBQ2hFO0lBQ0wsQ0FBQzs7Ozs7O0lBRU8scUJBQXFCLENBQUMsVUFBMEI7UUFDcEQsSUFBSSxVQUFVLFlBQVksS0FBSyxFQUFFO1lBQzdCLFVBQVUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDeEQ7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDOzs7WUF6TEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxZQUFZO2dCQUN0Qix3ZEFBdUM7Z0JBRXZDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOzthQUN4Qzs7OztZQW5DdUIsTUFBTTtZQUF0QixjQUFjOzs7b0JBZ0RqQixlQUFlLFNBQUMsWUFBWTtnQ0FJNUIsTUFBTTt3QkFJTixLQUFLO3lCQVlMLEtBQUs7a0NBZUwsS0FBSztvQkFZTCxLQUFLOzs7O0lBMUROLHlDQUFnQzs7Ozs7SUFDaEMscUNBQXdDOzs7OztJQUN4QyxzQ0FBeUM7Ozs7O0lBQ3pDLHNEQUFrRTs7Ozs7OztJQU1sRSxxQ0FBNkI7O0lBRTdCLGdDQUMrQjs7Ozs7SUFHL0IsNENBQ3FFOztJQXVDckUsK0NBQXFDOzs7OztJQVdyQyxpQ0FBdUI7Ozs7O0lBRVgsaUNBQXNCOzs7OztJQUFFLGdDQUE2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBRdWVyeUxpc3QsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXIsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7VGFiQ29tcG9uZW50fSBmcm9tICcuLi90YWIvdGFiLmNvbXBvbmVudCc7XG5pbXBvcnQge0FjdGl2YXRlZFJvdXRlLCBSb3V0ZXJ9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHt0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7cGFyc2VCb29sZWFuQXR0cmlidXRlfSBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIFRhYkNoYW5nZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaW5kZXg6IG51bWJlciwgcHVibGljIHRhYjogVGFiQ29tcG9uZW50KSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dFcnJvckZvck1pc3NpbmdSb3V0ZXJMaW5rKHRhYnNXaXRob3V0Um91dGVyTGluazogVGFiQ29tcG9uZW50W10pIHtcbiAgICBjb25zdCB0YWJUaXRsZXMgPSB0YWJzV2l0aG91dFJvdXRlckxpbmsubWFwKHRhYiA9PiB0YWIudGFiVGl0bGUpO1xuICAgIHRocm93IEVycm9yKGBSb3V0ZXJsaW5rIG1pc3Npbmcgb24gJHt0YWJUaXRsZXMuam9pbignLCcpfWApO1xufVxuXG5jb25zdCBzdXBwb3J0ZWREaXJlY3Rpb25zID0gWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ107XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGlvbklucHV0KGlucHV0U3RyOiBzdHJpbmcpIHtcbiAgICBpZiAoc3VwcG9ydGVkRGlyZWN0aW9ucy5pbmRleE9mKGlucHV0U3RyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhYiBkaXJlY3Rpb24gdmFsdWU6ICcgKyBpbnB1dFN0cik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFiQ29tcG9uZW50TWlzc2luZygpOiBFcnJvciB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgVGFiU2V0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgVGFiQ29tcG9uZW50LiBNYWtlIHN1cmUgdG8gYWRkIGEgaGMtdGFiIHRvIHRoZSBoYy10YWItc2V0IGVsZW1lbnQuYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkRGVmYXVsdFRhYih0YWJWYWw6IHN0cmluZyB8IG51bWJlcikge1xuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGRlZmF1bHQgdGFiIHZhbHVlOiAnICsgdGFiVmFsICsgXCIuIE11c3QgYmUgJ25vbmUnIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFicyBpbiB0aGUgc2V0LlwiKTtcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IGBoYy10YWItc2V0YCxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGFiLXNldC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdGFiLXNldC5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgVGFiU2V0Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgX3JvdXRlckVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kaXJlY3Rpb246IHN0cmluZyA9ICd2ZXJ0aWNhbCc7XG4gICAgcHJpdmF0ZSBfZGVmYXVsdFRhYjogc3RyaW5nIHwgbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIF9zdG9wVGFiU3Vic2NyaXB0aW9uU3ViamVjdDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIC8qKiBUaGUgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiLlxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSB0YWIgd2hlbiBpdCBpcyBzZWxlY3RlZC5cbiAgICAgKiBOb3QgdXNlZCB3aGVuIHRoaXMgY29tcG9uZW50IHVzZXMgcm91dGluZy5cbiAgICAgKi9cbiAgICB0YWJDb250ZW50OiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihUYWJDb21wb25lbnQpXG4gICAgX3RhYnM6IFF1ZXJ5TGlzdDxUYWJDb21wb25lbnQ+O1xuXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlbGVjdGVkIHRhYiBpcyBjaGFuZ2VkICovXG4gICAgQE91dHB1dCgpXG4gICAgc2VsZWN0ZWRUYWJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUYWJDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKiogU3BlY2lmeSBkaXJlY3Rpb24gb2YgdGFicyBhcyBlaXRoZXIgYGhvcml6b250YWxgIG9yIGB2ZXJ0aWNhbGAuIERlZmF1bHRzIHRvIGB2ZXJ0aWNhbGAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvblR5cGU6IHN0cmluZykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGlvbklucHV0KGRpcmVjdGlvblR5cGUpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb25UeXBlO1xuICAgIH1cblxuICAgIC8qKiBaZXJvLWJhc2VkIG51bWVyaWNhbCB2YWx1ZSBzcGVjaWZ5aW5nIHdoaWNoIHRhYiB0byBzZWxlY3QgYnkgZGVmYXVsdCwgc2V0dGluZyB0byBgbm9uZWAgbWVhbnMgbm8gdGFiXG4gICAgICogd2lsbCBiZSBpbW1lZGlhdGVseSBzZWxlY3RlZC4gRGVmYXVsdHMgdG8gMCAodGhlIGZpcnN0IHRhYikuICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZGVmYXVsdFRhYigpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFRhYjtcbiAgICB9XG5cbiAgICBzZXQgZGVmYXVsdFRhYih0YWJWYWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XG4gICAgICAgIGlmICghaXNOYU4oK3RhYlZhbHVlKSB8fCB0YWJWYWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0VGFiID0gdGFiVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnZhbGlkRGVmYXVsdFRhYih0YWJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0YWIgc2V0IHdpbGwgY3JlYXRlIGEgcm91dGVyLW91dGxldCBvciBuZy1jb250YWluZXIgZm9yIHRoZSB0YWIgY29udGVudC5cbiAgICAgKiBJZiBzZXQgdG8gZmFsc2UsIHRoZSBhcHAgd2lsbCBuZWVkIHRvIGFkZCBpdHMgb3duIGNvbnRhaW5lci4gIERlZmF1bHRzIHRvIGB0cnVlYC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBhZGRDb250ZW50Q29udGFpbmVyKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ29udGVudENvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBzZXQgYWRkQ29udGVudENvbnRhaW5lcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hZGRDb250ZW50Q29udGFpbmVyID0gcGFyc2VCb29sZWFuQXR0cmlidXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBfYWRkQ29udGVudENvbnRhaW5lcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogSWYgdHJ1ZSwgY29uZGVuc2UgdGhlIGRlZmF1bHQgcGFkZGluZyBvbiBhbGwgaW5jbHVkZWQgdGFicy4gKkRlZmF1bHRzIHRvIGBmYWxzZWAuKiAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB0aWdodCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpZ2h0O1xuICAgIH1cbiAgICBzZXQgdGlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGlnaHQgPSBwYXJzZUJvb2xlYW5BdHRyaWJ1dGUodmFsdWUpO1xuICAgICAgICB0aGlzLnNldFRhYkRpcmVjdGlvbigpO1xuICAgIH1cbiAgICBwcml2YXRlIF90aWdodCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFJvdXRlciwgcHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0VXBUYWJzKCk7XG4gICAgICAgIHRoaXMuX3RhYnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRVcFRhYnMoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRVcFRhYnMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl90YWJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGFiQ29tcG9uZW50TWlzc2luZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRhYiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRUb0ZpcnN0VGFiKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ZvclJvdXRlclVzZSgpO1xuICAgICAgICB0aGlzLnNldFRhYkRpcmVjdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvVGFiQ2xpY2tzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUYWJEaXJlY3Rpb24oKTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgIHRoaXMuX3RhYnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICB0Ll9kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB0Ll90aWdodCA9IHRoaXMudGlnaHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9UYWJDbGlja3MoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N0b3BUYWJTdWJzY3JpcHRpb25TdWJqZWN0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fdGFicy5mb3JFYWNoKHQgPT4gdC50YWJDbGljay5waXBlKHRha2VVbnRpbCh0aGlzLl9zdG9wVGFiU3Vic2NyaXB0aW9uU3ViamVjdCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zZXRBY3RpdmUodCkpKTtcbiAgICB9XG5cbiAgICAvKiogU2V0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYiBieSBlaXRoZXIgaXRzIG51bWVyaWNhbCBpbmRleCBvciBgVGFiQ29tcG9uZW50YCBvYmplY3QgICovXG4gICAgc2VsZWN0VGFiKHRhYjogbnVtYmVyIHwgVGFiQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhYiA9IHR5cGVvZiB0YWIgPT09ICdudW1iZXInID8gdGhpcy5fdGFicy50b0FycmF5KClbdGFiXSA6IHRhYjtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlKGFjdGl2ZVRhYik7XG4gICAgfVxuXG4gICAgX3NldEFjdGl2ZSh0YWI6IFRhYkNvbXBvbmVudCkge1xuICAgICAgICBsZXQgYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl90YWJzLnRvQXJyYXkoKS5mb3JFYWNoKCh0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdC5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodCA9PT0gdGFiKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRhYi5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50YWJDb250ZW50ID0gdGFiLnRhYkNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUYWJDaGFuZ2UuZW1pdChuZXcgVGFiQ2hhbmdlRXZlbnQoYWN0aXZlSW5kZXgsIHRhYikpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVmYXVsdFRvRmlyc3RUYWIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGFicy5maW5kKHRhYiA9PiB0YWIuX2FjdGl2ZSkpIHtcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgdG8gYXZvaWQgY2hhbmdlIGFmdGVyIGNoZWNrZWQgZXJyb3JcbiAgICAgICAgICAgIC8vIHdoZW4gbmdGb3IgaXMgdXNlZCBhcyBwcm9qZWN0ZWQgbm9kZXMgYXJlIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIC8vIGFuZCBzdG9yZWQgYXMgcGFydCBvZiB0aGUgZXhpc3Rpbmcgdmlldywgbm90XG4gICAgICAgICAgICAvLyB0aGUgdmlldyBpbiB3aGljaCB0aGV5IGFyZSBwcm9qZWN0ZWRcbiAgICAgICAgICAgIC8vIGVtYmVkZGVkIHZpZXdzIGFyZSBjaGVja2VkICpiZWZvcmUqIEFmdGVyQ29udGVudEluaXRcbiAgICAgICAgICAgIC8vIGlzIHRyaWdnZXJlZFxuICAgICAgICAgICAgY29uc3QgdGFiQXJyYXkgPSB0aGlzLl90YWJzLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGlmICh0YWJBcnJheVtOdW1iZXIodGhpcy5kZWZhdWx0VGFiKV0pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3NldEFjdGl2ZSh0YWJBcnJheVtOdW1iZXIodGhpcy5kZWZhdWx0VGFiKV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZERlZmF1bHRUYWIodGhpcy5kZWZhdWx0VGFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tGb3JSb3V0ZXJVc2UoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50VXNpbmdSb3V0ZXIgPSB0aGlzLl90YWJzLmZpbHRlcih0YWIgPT4gdGFiLnJvdXRlckxpbmsgIT09IHVuZGVmaW5lZCkubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnRVc2luZ1JvdXRlciA+IDAgJiYgY291bnRVc2luZ1JvdXRlciA8IHRoaXMuX3RhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJzTWlzc2luZ1JvdXRlckxpbmsgPSB0aGlzLl90YWJzLmZpbHRlcih0YWIgPT4gdGFiLnJvdXRlckxpbmsgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yRm9yTWlzc2luZ1JvdXRlckxpbmsodGFic01pc3NpbmdSb3V0ZXJMaW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudFVzaW5nUm91dGVyID09PSB0aGlzLl90YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdFRhYiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VG9GaXJzdFJvdXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGRlZmF1bHRUb0ZpcnN0Um91dGUoKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kUm91dGUgPSB0aGlzLl90YWJzXG4gICAgICAgICAgICAubWFwKHRhYiA9PiB0YWIucm91dGVyTGluaylcbiAgICAgICAgICAgIC5tYXAocm91dGVyTGluayA9PiB0aGlzLm1hcFJvdXRlckxpbmtUb1N0cmluZyhyb3V0ZXJMaW5rKSlcbiAgICAgICAgICAgIC5maW5kKHJvdXRlckxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Um91dGUgPSB0aGlzLnJvdXRlci51cmw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSb3V0ZSA9PT0gcm91dGVyTGluayB8fCBjdXJyZW50Um91dGUuaW5kZXhPZihgJHtyb3V0ZXJMaW5rfS9gKSA+IC0xO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZvdW5kUm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhYkFycmF5ID0gdGhpcy5fdGFicy50b0FycmF5KCk7XG4gICAgICAgIGlmICh0YWJBcnJheVtOdW1iZXIodGhpcy5kZWZhdWx0VGFiKV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Um91dGUgPSB0aGlzLm1hcFJvdXRlckxpbmtUb1N0cmluZyh0YWJBcnJheVtOdW1iZXIodGhpcy5kZWZhdWx0VGFiKV0ucm91dGVyTGluayk7XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbZmlyc3RSb3V0ZV0sIHtyZWxhdGl2ZVRvOiB0aGlzLnJvdXRlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1hcFJvdXRlckxpbmtUb1N0cmluZyhyb3V0ZXJMaW5rOiBzdHJpbmcgfCBhbnlbXSk6IHN0cmluZyB7XG4gICAgICAgIGlmIChyb3V0ZXJMaW5rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJvdXRlckxpbmsgPSByb3V0ZXJMaW5rLmpvaW4oJy8nKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlckxpbms7XG4gICAgfVxufVxuIl19