/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/progress-spinner.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ViewEncapsulation } from '@angular/core';
/** @type {?} */
const supportedColors = ['blue', 'green', 'purple', 'orange', 'red', 'gray', 'white'];
/**
 * @param {?} inputStr
 * @return {?}
 */
export function validateColorInput(inputStr) {
    if (supportedColors.indexOf(inputStr) < 0) {
        throw Error('Unsupported progress spinner color value: ' + inputStr);
    }
}
export class ProgressSpinnerComponent {
    constructor() {
        this._color = 'blue';
        /**
         * If true, the spinner will center itself inside its container.
         */
        this.isCentered = true;
        /**
         * If true, include background "channel" circle.
         */
        this.hasChannel = true;
        /**
         * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
         */
        this.isDeterminate = false;
        this._rightCircleTransform = '';
        this._leftCircleTransform = '';
        this._rightCircleTransition = '';
        this._leftCircleTransition = '';
        this._progress = 0;
        this._diameter = 0;
        this._minDiameter = 20;
        this._maxDiameter = 250;
    }
    /**
     * Color of the spinner: `blue`, `green`, `purple`, `orange`, `red`, `gray`, `white`
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} colorVal
     * @return {?}
     */
    set color(colorVal) {
        validateColorInput(colorVal);
        this._color = colorVal;
    }
    /**
     * (0-100%) Only used if "isDeterminate" is set to true.
     * @param {?} progress
     * @return {?}
     */
    set progress(progress) {
        this.setProgress(progress);
    }
    /**
     * @return {?}
     */
    get progress() {
        return this._progress;
    }
    /**
     * Set the diameter of the circle, in pixels. Minimum is 20, maximum is 250.
     * @param {?} diameter
     * @return {?}
     */
    set diameter(diameter) {
        this._diameter = Math.min(Math.max(this._minDiameter, diameter), this._maxDiameter);
    }
    /**
     * @return {?}
     */
    get diameter() {
        return this._diameter;
    }
    /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    setProgress(progress) {
        progress = Math.min(100, progress);
        progress = Math.max(0, progress);
        this.setProgressTransition(progress);
        this.setProgressTransform(progress);
        this._progress = progress;
    }
    /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    setProgressTransition(progress) {
        /** @type {?} */
        const sizeBasedTime = this.diameter > 150 ? 0.6 : 0.4;
        /** @type {?} */
        const timing = Math.abs(progress - this._progress) > 40 ? sizeBasedTime : sizeBasedTime / 2;
        /** @type {?} */
        const halfTime = timing / 2;
        if ((progress <= 50 && this._progress <= 50) || (progress >= 51 && this._progress >= 51)) {
            this._leftCircleTransition = `transform ${timing}s ease-in-out 0s`;
            this._rightCircleTransition = `transform ${timing}s ease-in-out 0s`;
        }
        else if (progress <= 50 && this._progress >= 51) {
            this._leftCircleTransition = `transform ${halfTime}s ease-in 0s`;
            this._rightCircleTransition = `transform ${halfTime}s ease-out ${halfTime - 0.001}s`;
        }
        else if (progress >= 51 && this._progress <= 50) {
            this._leftCircleTransition = `transform ${halfTime}s ease-out ${halfTime - 0.001}s`;
            this._rightCircleTransition = `transform ${halfTime}s ease-in 0s`;
        }
    }
    /**
     * Using a somewhat complicated set of transforms to achive the animation.
     * For 0% to 50% the right circle element rotates from -135deg to 45deg
     * For 51% to 100% the left circle element rotates from 135deg to 315deg
     * @private
     * @param {?} progress
     * @return {?}
     */
    setProgressTransform(progress) {
        if (progress <= 50) {
            /** @type {?} */
            const rightDegrees = (progress / 50) * 180 - 135;
            this._rightCircleTransform = `rotate(${rightDegrees}deg)`;
            this._leftCircleTransform = `rotate(135deg)`;
        }
        else if (progress >= 51) {
            /** @type {?} */
            const leftDegrees = ((progress - 50) / 50) * 180 + 135;
            this._leftCircleTransform = `rotate(${leftDegrees}deg)`;
            this._rightCircleTransform = 'rotate(45deg)';
        }
    }
}
ProgressSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'hc-progress-spinner',
                template: "<div class=\"hc-spinner-container\" [ngClass]=\"{'center-spinner': isCentered }\">\n    <div class=\"hc-spinner\" \n        [ngClass]=\"{'indeterminate-spin': !isDeterminate, 'large-spinner': diameter >= 150 }\"\n        [style.width.px]=\"diameter\"\n        [style.height.px]=\"diameter\"\n        [style.marginTop.px]=\"isCentered ? diameter / -2 : 0\"\n        [style.marginLeft.px]=\"isCentered ? diameter / -2 : 0\">\n        <div class=\"spinner-layer spinner-{{color}}\" [ngClass]=\"{'spinner-base': hasChannel }\">\n            <div class=\"circle base-circle\"></div>\n            <div class=\"circle-clipper left\"><div class=\"circle\" [style.transform]=\"_leftCircleTransform\" [style.transition]=\"_leftCircleTransition\"></div>\n            </div><div class=\"gap-patch\"><div class=\"circle\"></div>\n            </div><div class=\"circle-clipper right\"><div class=\"circle\" [style.transform]=\"_rightCircleTransform\" [style.transition]=\"_rightCircleTransition\"></div></div>\n        </div>\n    </div>\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
ProgressSpinnerComponent.propDecorators = {
    color: [{ type: Input }],
    isCentered: [{ type: Input }],
    hasChannel: [{ type: Input }],
    isDeterminate: [{ type: Input }],
    progress: [{ type: Input }],
    diameter: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._color;
    /**
     * If true, the spinner will center itself inside its container.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.isCentered;
    /**
     * If true, include background "channel" circle.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.hasChannel;
    /**
     * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.isDeterminate;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._rightCircleTransform;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._leftCircleTransform;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._rightCircleTransition;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._leftCircleTransition;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._progress;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._diameter;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._minDiameter;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._maxDiameter;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvcHJvZ3Jlc3MtaW5kaWNhdG9ycy9wcm9ncmVzcy1zcGlubmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFDLE1BQU0sZUFBZSxDQUFDOztNQUU1RCxlQUFlLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUM7Ozs7O0FBRXJGLE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxRQUFnQjtJQUMvQyxJQUFJLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3ZDLE1BQU0sS0FBSyxDQUFDLDRDQUE0QyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0tBQ3hFO0FBQ0wsQ0FBQztBQU9ELE1BQU0sT0FBTyx3QkFBd0I7SUFMckM7UUFNWSxXQUFNLEdBQUcsTUFBTSxDQUFDOzs7O1FBZWpCLGVBQVUsR0FBRyxJQUFJLENBQUM7Ozs7UUFJbEIsZUFBVSxHQUFHLElBQUksQ0FBQzs7OztRQUlsQixrQkFBYSxHQUFHLEtBQUssQ0FBQztRQW9CdEIsMEJBQXFCLEdBQUcsRUFBRSxDQUFDO1FBQzNCLHlCQUFvQixHQUFHLEVBQUUsQ0FBQztRQUMxQiwyQkFBc0IsR0FBRyxFQUFFLENBQUM7UUFDNUIsMEJBQXFCLEdBQUcsRUFBRSxDQUFDO1FBQzFCLGNBQVMsR0FBRyxDQUFDLENBQUM7UUFDZCxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsaUJBQVksR0FBRyxFQUFFLENBQUM7UUFDbEIsaUJBQVksR0FBRyxHQUFHLENBQUM7SUE0Qy9CLENBQUM7Ozs7O0lBM0ZHLElBQ0ksS0FBSztRQUNM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O1lBQ2hELElBQUksQ0FBQyxxQkFBcUIsR0FBRyxVQUFVLFlBQVksTUFBTSxDQUFDO1lBQzFELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxnQkFBZ0IsQ0FBQztTQUNoRDthQUFNLElBQUksUUFBUSxJQUFJLEVBQUUsRUFBRTs7a0JBQ2pCLFdBQVcsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ3RELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxVQUFVLFdBQVcsTUFBTSxDQUFDO1lBQ3hELElBQUksQ0FBQyxxQkFBcUIsR0FBRyxlQUFlLENBQUM7U0FDaEQ7SUFDTCxDQUFDOzs7WUFuR0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLG1oQ0FBOEM7Z0JBQzlDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2FBQ3hDOzs7b0JBS0ksS0FBSzt5QkFXTCxLQUFLO3lCQUlMLEtBQUs7NEJBSUwsS0FBSzt1QkFJTCxLQUFLO3VCQVNMLEtBQUs7Ozs7Ozs7SUFuQ04sMENBQXdCOzs7OztJQWN4Qiw4Q0FDeUI7Ozs7O0lBR3pCLDhDQUN5Qjs7Ozs7SUFHekIsaURBQzZCOztJQW9CN0IseURBQWtDOztJQUNsQyx3REFBaUM7O0lBQ2pDLDBEQUFtQzs7SUFDbkMseURBQWtDOzs7OztJQUNsQyw2Q0FBc0I7Ozs7O0lBQ3RCLDZDQUFzQjs7Ozs7SUFDdEIsZ0RBQTBCOzs7OztJQUMxQixnREFBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuY29uc3Qgc3VwcG9ydGVkQ29sb3JzID0gWydibHVlJywgJ2dyZWVuJywgJ3B1cnBsZScsICdvcmFuZ2UnLCAncmVkJywgJ2dyYXknLCAnd2hpdGUnXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29sb3JJbnB1dChpbnB1dFN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHN1cHBvcnRlZENvbG9ycy5pbmRleE9mKGlucHV0U3RyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb2dyZXNzIHNwaW5uZXIgY29sb3IgdmFsdWU6ICcgKyBpbnB1dFN0cik7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hjLXByb2dyZXNzLXNwaW5uZXInLFxuICAgIHRlbXBsYXRlVXJsOiAncHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1NwaW5uZXJDb21wb25lbnQge1xuICAgIHByaXZhdGUgX2NvbG9yID0gJ2JsdWUnO1xuXG4gICAgLyoqIENvbG9yIG9mIHRoZSBzcGlubmVyOiBgYmx1ZWAsIGBncmVlbmAsIGBwdXJwbGVgLCBgb3JhbmdlYCwgYHJlZGAsIGBncmF5YCwgYHdoaXRlYCAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGNvbG9yKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3IoY29sb3JWYWw6IHN0cmluZykge1xuICAgICAgICB2YWxpZGF0ZUNvbG9ySW5wdXQoY29sb3JWYWwpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IGNvbG9yVmFsO1xuICAgIH1cblxuICAgIC8qKiBJZiB0cnVlLCB0aGUgc3Bpbm5lciB3aWxsIGNlbnRlciBpdHNlbGYgaW5zaWRlIGl0cyBjb250YWluZXIuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaXNDZW50ZXJlZCA9IHRydWU7XG5cbiAgICAvKiogSWYgdHJ1ZSwgaW5jbHVkZSBiYWNrZ3JvdW5kIFwiY2hhbm5lbFwiIGNpcmNsZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoYXNDaGFubmVsID0gdHJ1ZTtcblxuICAgIC8qKiBJZiB0cnVlLCBzd2l0Y2hlcyB0byBkZXRlcm1pbmF0ZSBtb2RlLiBNdXN0IHBhc3MgaW4gcHJvZ3Jlc3MgKDAtMTAwJSksIGluc3RlYWQgb2YgaGF2aW5nIHRoZSBsb2FkZXIgc3BpbiBmcmVlbHkuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaXNEZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqICgwLTEwMCUpIE9ubHkgdXNlZCBpZiBcImlzRGV0ZXJtaW5hdGVcIiBpcyBzZXQgdG8gdHJ1ZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3M6IG51bWJlcikge1xuICAgICAgICB0aGlzLnNldFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICB9XG4gICAgcHVibGljIGdldCBwcm9ncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGRpYW1ldGVyIG9mIHRoZSBjaXJjbGUsIGluIHBpeGVscy4gTWluaW11bSBpcyAyMCwgbWF4aW11bSBpcyAyNTAuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGRpYW1ldGVyKGRpYW1ldGVyOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLl9taW5EaWFtZXRlciwgZGlhbWV0ZXIpLCB0aGlzLl9tYXhEaWFtZXRlcik7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgZGlhbWV0ZXIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpYW1ldGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBfcmlnaHRDaXJjbGVUcmFuc2Zvcm0gPSAnJztcbiAgICBwdWJsaWMgX2xlZnRDaXJjbGVUcmFuc2Zvcm0gPSAnJztcbiAgICBwdWJsaWMgX3JpZ2h0Q2lyY2xlVHJhbnNpdGlvbiA9ICcnO1xuICAgIHB1YmxpYyBfbGVmdENpcmNsZVRyYW5zaXRpb24gPSAnJztcbiAgICBwcml2YXRlIF9wcm9ncmVzcyA9IDA7XG4gICAgcHJpdmF0ZSBfZGlhbWV0ZXIgPSAwO1xuICAgIHByaXZhdGUgX21pbkRpYW1ldGVyID0gMjA7XG4gICAgcHJpdmF0ZSBfbWF4RGlhbWV0ZXIgPSAyNTA7XG5cbiAgICBwcml2YXRlIHNldFByb2dyZXNzKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1pbigxMDAsIHByb2dyZXNzKTtcbiAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heCgwLCBwcm9ncmVzcyk7XG5cbiAgICAgICAgdGhpcy5zZXRQcm9ncmVzc1RyYW5zaXRpb24ocHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnNldFByb2dyZXNzVHJhbnNmb3JtKHByb2dyZXNzKTtcblxuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0UHJvZ3Jlc3NUcmFuc2l0aW9uKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUJhc2VkVGltZSA9IHRoaXMuZGlhbWV0ZXIgPiAxNTAgPyAwLjYgOiAwLjQ7XG4gICAgICAgIGNvbnN0IHRpbWluZyA9IE1hdGguYWJzKHByb2dyZXNzIC0gdGhpcy5fcHJvZ3Jlc3MpID4gNDAgPyBzaXplQmFzZWRUaW1lIDogc2l6ZUJhc2VkVGltZSAvIDI7XG4gICAgICAgIGNvbnN0IGhhbGZUaW1lID0gdGltaW5nIC8gMjtcbiAgICAgICAgaWYgKChwcm9ncmVzcyA8PSA1MCAmJiB0aGlzLl9wcm9ncmVzcyA8PSA1MCkgfHwgKHByb2dyZXNzID49IDUxICYmIHRoaXMuX3Byb2dyZXNzID49IDUxKSkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7dGltaW5nfXMgZWFzZS1pbi1vdXQgMHNgO1xuICAgICAgICAgICAgdGhpcy5fcmlnaHRDaXJjbGVUcmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke3RpbWluZ31zIGVhc2UtaW4tb3V0IDBzYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA8PSA1MCAmJiB0aGlzLl9wcm9ncmVzcyA+PSA1MSkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLWluIDBzYDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0Q2lyY2xlVHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtoYWxmVGltZX1zIGVhc2Utb3V0ICR7aGFsZlRpbWUgLSAwLjAwMX1zYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+PSA1MSAmJiB0aGlzLl9wcm9ncmVzcyA8PSA1MCkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLW91dCAke2hhbGZUaW1lIC0gMC4wMDF9c2A7XG4gICAgICAgICAgICB0aGlzLl9yaWdodENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLWluIDBzYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgc29tZXdoYXQgY29tcGxpY2F0ZWQgc2V0IG9mIHRyYW5zZm9ybXMgdG8gYWNoaXZlIHRoZSBhbmltYXRpb24uXG4gICAgICogRm9yIDAlIHRvIDUwJSB0aGUgcmlnaHQgY2lyY2xlIGVsZW1lbnQgcm90YXRlcyBmcm9tIC0xMzVkZWcgdG8gNDVkZWdcbiAgICAgKiBGb3IgNTElIHRvIDEwMCUgdGhlIGxlZnQgY2lyY2xlIGVsZW1lbnQgcm90YXRlcyBmcm9tIDEzNWRlZyB0byAzMTVkZWdcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFByb2dyZXNzVHJhbnNmb3JtKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzIDw9IDUwKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodERlZ3JlZXMgPSAocHJvZ3Jlc3MgLyA1MCkgKiAxODAgLSAxMzU7XG4gICAgICAgICAgICB0aGlzLl9yaWdodENpcmNsZVRyYW5zZm9ybSA9IGByb3RhdGUoJHtyaWdodERlZ3JlZXN9ZGVnKWA7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0Q2lyY2xlVHJhbnNmb3JtID0gYHJvdGF0ZSgxMzVkZWcpYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+PSA1MSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdERlZ3JlZXMgPSAoKHByb2dyZXNzIC0gNTApIC8gNTApICogMTgwICsgMTM1O1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zZm9ybSA9IGByb3RhdGUoJHtsZWZ0RGVncmVlc31kZWcpYDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0Q2lyY2xlVHJhbnNmb3JtID0gJ3JvdGF0ZSg0NWRlZyknO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19