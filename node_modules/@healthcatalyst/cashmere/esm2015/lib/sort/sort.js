/**
 * @fileoverview added by tsickle
 * Generated from: lib/sort/sort.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:no-output-rename no-input-rename directive-class-suffix */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, EventEmitter, Input, isDevMode, Output } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { getSortDuplicateSortableIdError, getSortHeaderMissingIdError, getSortInvalidDirectionError } from './sort-errors';
import { Subject } from 'rxjs';
import { Initializable } from '../shared/initializable';
/**
 * Interface for a directive that holds sorting state consumed by `HcSortHeaderComponent`.
 * @record
 */
export function HcSortable() { }
if (false) {
    /**
     * The id of the column being sorted.
     * @type {?}
     */
    HcSortable.prototype.id;
    /**
     * Starting sort direction.
     * @type {?}
     */
    HcSortable.prototype.start;
    /**
     * Whether to disable clearing the sorting state.
     * @type {?}
     */
    HcSortable.prototype.disableClear;
}
/**
 * The current sort state.
 * @record
 */
export function Sort() { }
if (false) {
    /**
     * The id of the column being sorted.
     * @type {?}
     */
    Sort.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    Sort.prototype.direction;
}
/**
 * Container for HcSortables to manage the sort state and provide default sort parameters.
 */
export class HcSort extends Initializable {
    constructor() {
        super(...arguments);
        /**
         * Collection of all registered sortables that this directive manages.
         */
        this.sortables = new Map();
        /**
         * Used to notify any child components listening to state changes.
         */
        this._stateChanges = new Subject();
        /**
         * The direction to set when an HcSortable is initially sorted.
         * May be overriden by the HcSortable's sort start.
         */
        this.start = 'asc';
        this._direction = '';
        this._disabled = false;
        /**
         * Event emitted when the user changes either the active sort or sort direction.
         */
        this.sortChange = new EventEmitter();
    }
    /**
     * The sort direction of the currently active HcSortable.
     * @return {?}
     */
    get direction() {
        return this._direction;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    set direction(direction) {
        if (isDevMode() && direction && direction !== 'asc' && direction !== 'desc') {
            throw getSortInvalidDirectionError(direction);
        }
        this._direction = direction;
    }
    /**
     * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
     * May be overriden by the HcSortable's disable clear input.
     * @return {?}
     */
    get disableClear() {
        return this._disableClear;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set disableClear(v) {
        this._disableClear = coerceBooleanProperty(v);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Register function to be used by the contained HcSortables. Adds the HcSortable to the
     * collection of HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    register(sortable) {
        if (!sortable.id) {
            throw getSortHeaderMissingIdError();
        }
        if (this.sortables.has(sortable.id)) {
            throw getSortDuplicateSortableIdError(sortable.id);
        }
        this.sortables.set(sortable.id, sortable);
    }
    /**
     * Unregister function to be used by the contained HcSortables. Removes the HcSortable from the
     * collection of contained HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    deregister(sortable) {
        this.sortables.delete(sortable.id);
    }
    /**
     * Sets the active sort id and determines the new sort direction.
     * @param {?} sortable
     * @return {?}
     */
    sort(sortable) {
        if (this.active !== sortable.id) {
            this.active = sortable.id;
            this.direction = sortable.start ? sortable.start : this.start;
        }
        else {
            this.direction = this.getNextSortDirection(sortable);
        }
        this.sortChange.emit({ active: this.active, direction: this.direction });
    }
    /**
     * Returns the next sort direction of the active sortable, checking for potential overrides.
     * @param {?} sortable
     * @return {?}
     */
    getNextSortDirection(sortable) {
        if (!sortable) {
            return '';
        }
        // Get the sort direction cycle with the potential sortable overrides.
        /** @type {?} */
        const disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
        /** @type {?} */
        let sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
        // Get and return the next direction in the cycle
        /** @type {?} */
        let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._markInitialized();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
}
HcSort.decorators = [
    { type: Directive, args: [{
                selector: '[hcSort]',
                exportAs: 'hcSort'
            },] }
];
HcSort.propDecorators = {
    active: [{ type: Input, args: ['hcSortActive',] }],
    start: [{ type: Input, args: ['hcSortStart',] }],
    direction: [{ type: Input, args: ['hcSortDirection',] }],
    disableClear: [{ type: Input, args: ['hcSortDisableClear',] }],
    disabled: [{ type: Input, args: ['hcSortDisabled',] }],
    sortChange: [{ type: Output, args: ['hcSortChange',] }]
};
if (false) {
    /**
     * Collection of all registered sortables that this directive manages.
     * @type {?}
     */
    HcSort.prototype.sortables;
    /**
     * Used to notify any child components listening to state changes.
     * @type {?}
     */
    HcSort.prototype._stateChanges;
    /**
     * The id of the most recently sorted HcSortable.
     * @type {?}
     */
    HcSort.prototype.active;
    /**
     * The direction to set when an HcSortable is initially sorted.
     * May be overriden by the HcSortable's sort start.
     * @type {?}
     */
    HcSort.prototype.start;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._direction;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._disableClear;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._disabled;
    /**
     * Event emitted when the user changes either the active sort or sort direction.
     * @type {?}
     */
    HcSort.prototype.sortChange;
}
/**
 * Returns the sort direction cycle to use given the provided parameters of order and clear.
 * @param {?} start
 * @param {?} disableClear
 * @return {?}
 */
function getSortDirectionCycle(start, disableClear) {
    /** @type {?} */
    let sortOrder = ['asc', 'desc'];
    if (start === 'desc') {
        sortOrder.reverse();
    }
    if (!disableClear) {
        sortOrder.push('');
    }
    return sortOrder;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi9zb3J0L3NvcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQVVBLE9BQU8sRUFBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQWdDLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5RyxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUU1RCxPQUFPLEVBQUMsK0JBQStCLEVBQUUsMkJBQTJCLEVBQUUsNEJBQTRCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekgsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0seUJBQXlCLENBQUM7Ozs7O0FBR3RELGdDQVNDOzs7Ozs7SUFQRyx3QkFBVzs7Ozs7SUFHWCwyQkFBc0I7Ozs7O0lBR3RCLGtDQUFzQjs7Ozs7O0FBSTFCLDBCQU1DOzs7Ozs7SUFKRyxzQkFBZTs7Ozs7SUFHZix5QkFBeUI7Ozs7O0FBUTdCLE1BQU0sT0FBTyxNQUFPLFNBQVEsYUFBYTtJQUp6Qzs7Ozs7UUFNSSxjQUFTLEdBQUcsSUFBSSxHQUFHLEVBQXNCLENBQUM7Ozs7UUFHakMsa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBUyxDQUFDOzs7OztRQVc5QyxVQUFLLEdBQW1CLEtBQUssQ0FBQztRQWF0QixlQUFVLEdBQWtCLEVBQUUsQ0FBQztRQXNCL0IsY0FBUyxHQUFZLEtBQUssQ0FBQzs7OztRQUkxQixlQUFVLEdBQXVCLElBQUksWUFBWSxFQUFRLENBQUM7SUFrRXZFLENBQUM7Ozs7O0lBdEdHLElBQ0ksU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzQixDQUFDOzs7OztJQUNELElBQUksU0FBUyxDQUFDLFNBQXdCO1FBQ2xDLElBQUksU0FBUyxF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O0lBRUQsV0FBVztRQUNQLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQzs7OztJQUVELFdBQVc7UUFDUCxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2xDLENBQUM7OztZQTVISixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLFFBQVEsRUFBRSxRQUFRO2FBQ3JCOzs7cUJBU0ksS0FBSyxTQUFDLGNBQWM7b0JBT3BCLEtBQUssU0FBQyxhQUFhO3dCQUluQixLQUFLLFNBQUMsaUJBQWlCOzJCQWdCdkIsS0FBSyxTQUFDLG9CQUFvQjt1QkFTMUIsS0FBSyxTQUFDLGdCQUFnQjt5QkFVdEIsTUFBTSxTQUFDLGNBQWM7Ozs7Ozs7SUFwRHRCLDJCQUEwQzs7Ozs7SUFHMUMsK0JBQThDOzs7OztJQUc5Qyx3QkFDZTs7Ozs7O0lBTWYsdUJBQzhCOzs7OztJQWE5Qiw0QkFBdUM7Ozs7O0lBYXZDLCtCQUErQjs7Ozs7SUFTL0IsMkJBQW1DOzs7OztJQUduQyw0QkFDbUU7Ozs7Ozs7O0FBcUV2RSxTQUFTLHFCQUFxQixDQUFDLEtBQXFCLEVBQUUsWUFBcUI7O1FBQ25FLFNBQVMsR0FBb0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDO0lBQ2hELElBQUksS0FBSyxLQUFLLE1BQU0sRUFBRTtRQUNsQixTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDdkI7SUFDRCxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2YsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN0QjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ3JCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZTpuby1vdXRwdXQtcmVuYW1lIG5vLWlucHV0LXJlbmFtZSBkaXJlY3RpdmUtY2xhc3Mtc3VmZml4ICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0RpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgaXNEZXZNb2RlLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1NvcnREaXJlY3Rpb259IGZyb20gJy4vc29ydC1kaXJlY3Rpb24nO1xuaW1wb3J0IHtnZXRTb3J0RHVwbGljYXRlU29ydGFibGVJZEVycm9yLCBnZXRTb3J0SGVhZGVyTWlzc2luZ0lkRXJyb3IsIGdldFNvcnRJbnZhbGlkRGlyZWN0aW9uRXJyb3J9IGZyb20gJy4vc29ydC1lcnJvcnMnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7SW5pdGlhbGl6YWJsZX0gZnJvbSAnLi4vc2hhcmVkL2luaXRpYWxpemFibGUnO1xuXG4vKiogSW50ZXJmYWNlIGZvciBhIGRpcmVjdGl2ZSB0aGF0IGhvbGRzIHNvcnRpbmcgc3RhdGUgY29uc3VtZWQgYnkgYEhjU29ydEhlYWRlckNvbXBvbmVudGAuICovXG5leHBvcnQgaW50ZXJmYWNlIEhjU29ydGFibGUge1xuICAgIC8qKiBUaGUgaWQgb2YgdGhlIGNvbHVtbiBiZWluZyBzb3J0ZWQuICovXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBTdGFydGluZyBzb3J0IGRpcmVjdGlvbi4gKi9cbiAgICBzdGFydDogJ2FzYycgfCAnZGVzYyc7XG5cbiAgICAvKiogV2hldGhlciB0byBkaXNhYmxlIGNsZWFyaW5nIHRoZSBzb3J0aW5nIHN0YXRlLiAqL1xuICAgIGRpc2FibGVDbGVhcjogYm9vbGVhbjtcbn1cblxuLyoqIFRoZSBjdXJyZW50IHNvcnQgc3RhdGUuICovXG5leHBvcnQgaW50ZXJmYWNlIFNvcnQge1xuICAgIC8qKiBUaGUgaWQgb2YgdGhlIGNvbHVtbiBiZWluZyBzb3J0ZWQuICovXG4gICAgYWN0aXZlOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIHNvcnQgZGlyZWN0aW9uLiAqL1xuICAgIGRpcmVjdGlvbjogU29ydERpcmVjdGlvbjtcbn1cblxuLyoqIENvbnRhaW5lciBmb3IgSGNTb3J0YWJsZXMgdG8gbWFuYWdlIHRoZSBzb3J0IHN0YXRlIGFuZCBwcm92aWRlIGRlZmF1bHQgc29ydCBwYXJhbWV0ZXJzLiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaGNTb3J0XScsXG4gICAgZXhwb3J0QXM6ICdoY1NvcnQnXG59KVxuZXhwb3J0IGNsYXNzIEhjU29ydCBleHRlbmRzIEluaXRpYWxpemFibGUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICAvKiogQ29sbGVjdGlvbiBvZiBhbGwgcmVnaXN0ZXJlZCBzb3J0YWJsZXMgdGhhdCB0aGlzIGRpcmVjdGl2ZSBtYW5hZ2VzLiAqL1xuICAgIHNvcnRhYmxlcyA9IG5ldyBNYXA8c3RyaW5nLCBIY1NvcnRhYmxlPigpO1xuXG4gICAgLyoqIFVzZWQgdG8gbm90aWZ5IGFueSBjaGlsZCBjb21wb25lbnRzIGxpc3RlbmluZyB0byBzdGF0ZSBjaGFuZ2VzLiAqL1xuICAgIHJlYWRvbmx5IF9zdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDxuZXZlcj4oKTtcblxuICAgIC8qKiBUaGUgaWQgb2YgdGhlIG1vc3QgcmVjZW50bHkgc29ydGVkIEhjU29ydGFibGUuICovXG4gICAgQElucHV0KCdoY1NvcnRBY3RpdmUnKVxuICAgIGFjdGl2ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpcmVjdGlvbiB0byBzZXQgd2hlbiBhbiBIY1NvcnRhYmxlIGlzIGluaXRpYWxseSBzb3J0ZWQuXG4gICAgICogTWF5IGJlIG92ZXJyaWRlbiBieSB0aGUgSGNTb3J0YWJsZSdzIHNvcnQgc3RhcnQuXG4gICAgICovXG4gICAgQElucHV0KCdoY1NvcnRTdGFydCcpXG4gICAgc3RhcnQ6ICdhc2MnIHwgJ2Rlc2MnID0gJ2FzYyc7XG5cbiAgICAvKiogVGhlIHNvcnQgZGlyZWN0aW9uIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIEhjU29ydGFibGUuICovXG4gICAgQElucHV0KCdoY1NvcnREaXJlY3Rpb24nKVxuICAgIGdldCBkaXJlY3Rpb24oKTogU29ydERpcmVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb247XG4gICAgfVxuICAgIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uOiBTb3J0RGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiBkaXJlY3Rpb24gJiYgZGlyZWN0aW9uICE9PSAnYXNjJyAmJiBkaXJlY3Rpb24gIT09ICdkZXNjJykge1xuICAgICAgICAgICAgdGhyb3cgZ2V0U29ydEludmFsaWREaXJlY3Rpb25FcnJvcihkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9XG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uOiBTb3J0RGlyZWN0aW9uID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRpc2FibGUgdGhlIHVzZXIgZnJvbSBjbGVhcmluZyB0aGUgc29ydCBieSBmaW5pc2hpbmcgdGhlIHNvcnQgZGlyZWN0aW9uIGN5Y2xlLlxuICAgICAqIE1heSBiZSBvdmVycmlkZW4gYnkgdGhlIEhjU29ydGFibGUncyBkaXNhYmxlIGNsZWFyIGlucHV0LlxuICAgICAqL1xuICAgIEBJbnB1dCgnaGNTb3J0RGlzYWJsZUNsZWFyJylcbiAgICBnZXQgZGlzYWJsZUNsZWFyKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZUNsZWFyO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZUNsZWFyKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZUNsZWFyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpO1xuICAgIH1cbiAgICBwcml2YXRlIF9kaXNhYmxlQ2xlYXI6IGJvb2xlYW47XG5cbiAgICBASW5wdXQoJ2hjU29ydERpc2FibGVkJylcbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIGVpdGhlciB0aGUgYWN0aXZlIHNvcnQgb3Igc29ydCBkaXJlY3Rpb24uICovXG4gICAgQE91dHB1dCgnaGNTb3J0Q2hhbmdlJylcbiAgICByZWFkb25seSBzb3J0Q2hhbmdlOiBFdmVudEVtaXR0ZXI8U29ydD4gPSBuZXcgRXZlbnRFbWl0dGVyPFNvcnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBmdW5jdGlvbiB0byBiZSB1c2VkIGJ5IHRoZSBjb250YWluZWQgSGNTb3J0YWJsZXMuIEFkZHMgdGhlIEhjU29ydGFibGUgdG8gdGhlXG4gICAgICogY29sbGVjdGlvbiBvZiBIY1NvcnRhYmxlcy5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihzb3J0YWJsZTogSGNTb3J0YWJsZSk6IHZvaWQge1xuICAgICAgICBpZiAoIXNvcnRhYmxlLmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRTb3J0SGVhZGVyTWlzc2luZ0lkRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNvcnRhYmxlcy5oYXMoc29ydGFibGUuaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRTb3J0RHVwbGljYXRlU29ydGFibGVJZEVycm9yKHNvcnRhYmxlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnRhYmxlcy5zZXQoc29ydGFibGUuaWQsIHNvcnRhYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYnkgdGhlIGNvbnRhaW5lZCBIY1NvcnRhYmxlcy4gUmVtb3ZlcyB0aGUgSGNTb3J0YWJsZSBmcm9tIHRoZVxuICAgICAqIGNvbGxlY3Rpb24gb2YgY29udGFpbmVkIEhjU29ydGFibGVzLlxuICAgICAqL1xuICAgIGRlcmVnaXN0ZXIoc29ydGFibGU6IEhjU29ydGFibGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zb3J0YWJsZXMuZGVsZXRlKHNvcnRhYmxlLmlkKTtcbiAgICB9XG5cbiAgICAvKiogU2V0cyB0aGUgYWN0aXZlIHNvcnQgaWQgYW5kIGRldGVybWluZXMgdGhlIG5ldyBzb3J0IGRpcmVjdGlvbi4gKi9cbiAgICBzb3J0KHNvcnRhYmxlOiBIY1NvcnRhYmxlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gc29ydGFibGUuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gc29ydGFibGUuaWQ7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHNvcnRhYmxlLnN0YXJ0ID8gc29ydGFibGUuc3RhcnQgOiB0aGlzLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmdldE5leHRTb3J0RGlyZWN0aW9uKHNvcnRhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KHthY3RpdmU6IHRoaXMuYWN0aXZlLCBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9ufSk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG5leHQgc29ydCBkaXJlY3Rpb24gb2YgdGhlIGFjdGl2ZSBzb3J0YWJsZSwgY2hlY2tpbmcgZm9yIHBvdGVudGlhbCBvdmVycmlkZXMuICovXG4gICAgZ2V0TmV4dFNvcnREaXJlY3Rpb24oc29ydGFibGU6IEhjU29ydGFibGUpOiBTb3J0RGlyZWN0aW9uIHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzb3J0IGRpcmVjdGlvbiBjeWNsZSB3aXRoIHRoZSBwb3RlbnRpYWwgc29ydGFibGUgb3ZlcnJpZGVzLlxuICAgICAgICBjb25zdCBkaXNhYmxlQ2xlYXIgPSBzb3J0YWJsZS5kaXNhYmxlQ2xlYXIgIT0gbnVsbCA/IHNvcnRhYmxlLmRpc2FibGVDbGVhciA6IHRoaXMuZGlzYWJsZUNsZWFyO1xuICAgICAgICBsZXQgc29ydERpcmVjdGlvbkN5Y2xlID0gZ2V0U29ydERpcmVjdGlvbkN5Y2xlKHNvcnRhYmxlLnN0YXJ0IHx8IHRoaXMuc3RhcnQsIGRpc2FibGVDbGVhcik7XG5cbiAgICAgICAgLy8gR2V0IGFuZCByZXR1cm4gdGhlIG5leHQgZGlyZWN0aW9uIGluIHRoZSBjeWNsZVxuICAgICAgICBsZXQgbmV4dERpcmVjdGlvbkluZGV4ID0gc29ydERpcmVjdGlvbkN5Y2xlLmluZGV4T2YodGhpcy5kaXJlY3Rpb24pICsgMTtcbiAgICAgICAgaWYgKG5leHREaXJlY3Rpb25JbmRleCA+PSBzb3J0RGlyZWN0aW9uQ3ljbGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0RGlyZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3J0RGlyZWN0aW9uQ3ljbGVbbmV4dERpcmVjdGlvbkluZGV4XTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fbWFya0luaXRpYWxpemVkKCk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuLyoqIFJldHVybnMgdGhlIHNvcnQgZGlyZWN0aW9uIGN5Y2xlIHRvIHVzZSBnaXZlbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycyBvZiBvcmRlciBhbmQgY2xlYXIuICovXG5mdW5jdGlvbiBnZXRTb3J0RGlyZWN0aW9uQ3ljbGUoc3RhcnQ6ICdhc2MnIHwgJ2Rlc2MnLCBkaXNhYmxlQ2xlYXI6IGJvb2xlYW4pOiBTb3J0RGlyZWN0aW9uW10ge1xuICAgIGxldCBzb3J0T3JkZXI6IFNvcnREaXJlY3Rpb25bXSA9IFsnYXNjJywgJ2Rlc2MnXTtcbiAgICBpZiAoc3RhcnQgPT09ICdkZXNjJykge1xuICAgICAgICBzb3J0T3JkZXIucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBpZiAoIWRpc2FibGVDbGVhcikge1xuICAgICAgICBzb3J0T3JkZXIucHVzaCgnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRPcmRlcjtcbn1cbiJdfQ==