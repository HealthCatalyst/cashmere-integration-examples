/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/picklist.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, forwardRef, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { PicklistOptionsSource, PicklistSettings } from './picklist.model';
/** @type {?} */
const supportedSortModes = ['asc', 'desc', 'none'];
/**
 * @param {?} inputStr
 * @return {?}
 */
export function validateSortInput(inputStr) {
    if (supportedSortModes.indexOf(inputStr) < 0) {
        throw Error('Unsupported sort input value: ' + inputStr);
    }
}
export class PicklistComponent {
    constructor() {
        /**
         * Fired when a change is made to the picklist selection.
         */
        this.changed = new EventEmitter();
        this.picklistSettings = new PicklistSettings();
        this.stringOptions = null;
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Settings for the picklist. Internally, this will trigger a call to `reset()`.
     * @param {?} settings
     * @return {?}
     */
    set settings(settings) {
        this.reset(settings);
    }
    /**
     * @return {?}
     */
    get settings() {
        return this.picklistSettings;
    }
    /**
     * An array of unique strings to be used as the picklist options.
     * @param {?} options
     * @return {?}
     */
    set simpleOptions(options) {
        this.updateStateFromStringOptions(options);
    }
    /**
     * @return {?}
     */
    get simpleOptions() {
        return this.stringOptions;
    }
    /**
     * Set to true to show text in the header. *Defaults to true.*
     * @param {?} shouldShow
     * @return {?}
     */
    set showHeaderText(shouldShow) {
        this.update({ showHeaderText: shouldShow });
    }
    /**
     * @return {?}
     */
    get showHeaderText() {
        return this.picklistSettings.showHeaderText;
    }
    /**
     * Text for left header. *Defaults to "Available".*
     * @param {?} text
     * @return {?}
     */
    set leftHeaderText(text) {
        this.update({ leftHeaderText: text });
    }
    /**
     * @return {?}
     */
    get leftHeaderText() {
        return this.picklistSettings.leftHeaderText;
    }
    /**
     * Text for right header. *Defaults to "Selected".*
     * @param {?} text
     * @return {?}
     */
    set rightHeaderText(text) {
        this.update({ rightHeaderText: text });
    }
    /**
     * @return {?}
     */
    get rightHeaderText() {
        return this.picklistSettings.rightHeaderText;
    }
    /**
     * How to sort options in the pane. Options: `asc` | `desc` | `none`; *Defaults to `none`.*
     * @param {?} sort
     * @return {?}
     */
    set sort(sort) {
        validateSortInput(sort);
        this.update({ sort: sort });
    }
    /**
     * @return {?}
     */
    get sort() {
        return this.picklistSettings.sort;
    }
    /**
     * @return {?}
     */
    get _leftToRightMoveBtnIsDisabled() {
        return this._available ? !this._available.isAnySelected() : false;
    }
    /**
     * Current selected value of the picklist. Will be either `IPicklistOptions` or `string[]` depending on the type of options provided.
     * @param {?} model
     * @return {?}
     */
    set value(model) {
        /** @type {?} */
        const selectedValues = { values: [], valueSets: [] };
        if (this.picklistModelisArray(model)) {
            /** @type {?} */
            const selected = this.convertStringsToValueOptions(model);
            selectedValues.values = selected || [];
        }
        else {
            selectedValues.values = model.values || [];
            selectedValues.valueSets = model.valueSets || [];
        }
        this.update({ selected: selectedValues });
    }
    /**
     * @return {?}
     */
    get value() {
        if (this.stringOptions) {
            return this.picklistSettings.selected.values.map((/**
             * @param {?} v
             * @return {?}
             */
            v => v.title));
        }
        else {
            return this.picklistSettings.selected;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.value = value;
        }
    }
    /**
     * Will update the picklist with the given settings, maintaining any previous settings that have not been overridden.
     * @param {?} settings
     * @return {?}
     */
    update(settings) {
        /** @type {?} */
        const updatedSettings = Object.assign(this.picklistSettings, settings);
        this.reset(updatedSettings);
    }
    /**
     * Will reset the picklist settings with the given settings. (Clears out any previous settings.)
     * @param {?=} settings
     * @return {?}
     */
    reset(settings = new PicklistSettings()) {
        this.picklistSettings = Object.assign(new PicklistSettings(), settings);
        this.resetPanes(this.picklistSettings);
        this.setActiveValueType(this.picklistSettings.useValuesets ? 'valueSets' : 'values');
        this.applyChangeToModel();
    }
    /**
     * Will change the active tab. (Will do nothing if `settings.useValuesets` is false.)
     * @param {?} type
     * @return {?}
     */
    setActiveValueType(type) {
        if (!this._available) {
            console.warn('Available picklist pane not available yet.');
            return;
        }
        if (!this.settings.useValuesets) {
            type = 'values';
        }
        this._available.valueList.isActive = type === 'values';
        this._available.valueSetList.isActive = type === 'valueSets';
        this._available.selectNone();
        this._available.scrollToTop();
    }
    /**
     * Will move all selected items from the given pane into its companion pane. Used internally by the left and right arrow buttons.
     * @param {?} pane the pane from which we are moving items out of
     * @return {?}
     */
    moveSelectedItems(pane) {
        /** @type {?} */
        const shouldBreakValuesets = pane === this._confirmed;
        /** @type {?} */
        const selectedOptions = pane.listService.moveOutSelectedOptions(shouldBreakValuesets);
        if (pane.companion) {
            pane.companion.listService.addOptions(selectedOptions);
        }
        else {
            console.warn('This pane does not have a companion pane to move the select options in to.');
        }
        pane.filterService.reloadIfEmpty();
        this.applyChangeToModel();
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    updateStateFromStringOptions(options) {
        /** @type {?} */
        const valueOptions = this.convertStringsToValueOptions(options);
        this.stringOptions = options;
        this.update({ options: { values: valueOptions || [] } });
    }
    /**
     * @private
     * @param {?} settings
     * @return {?}
     */
    resetPanes(settings) {
        if (!(this._available && this._confirmed)) {
            console.warn('Picklist panes not available yet.');
            return;
        }
        /** @type {?} */
        const confirmedSource = new PicklistOptionsSource();
        confirmedSource.values = this.picklistSettings.selected.values.slice(0);
        confirmedSource.valueSets = this.picklistSettings.selected.valueSets.slice(0);
        confirmedSource.getValuesForValueset = this.picklistSettings.options.getValuesForValueset;
        this._confirmed.reset(confirmedSource, this.picklistSettings, this._available, false);
        /** @type {?} */
        const availableSource = Object.assign(new PicklistOptionsSource(), this.picklistSettings.options);
        this._available.reset(availableSource, this.picklistSettings, this._confirmed, true);
    }
    /**
     * @private
     * @return {?}
     */
    applyChangeToModel() {
        if (!(this._available && this._confirmed)) {
            console.warn('Picklist panes not available yet.');
            return;
        }
        this.picklistSettings.selected.values.length = 0;
        this.picklistSettings.selected.valueSets.length = 0;
        this._confirmed.valueList.options.forEach((/**
         * @param {?} e
         * @return {?}
         */
        e => this.picklistSettings.selected.values.push(e.option)));
        this._confirmed.valueSetList.options.forEach((/**
         * @param {?} e
         * @return {?}
         */
        e => this.picklistSettings.selected.valueSets.push(e.option)));
        this.changed.emit();
        this.onChange(this.value);
        this.onTouched();
    }
    /**
     * @private
     * @param {?} vals
     * @return {?}
     */
    convertStringsToValueOptions(vals) {
        return vals ? vals.map((/**
         * @param {?} o
         * @return {?}
         */
        o => ({ code: `${o}`, title: `${o}` }))) : null;
    }
    /**
     * @private
     * @param {?} model
     * @return {?}
     */
    picklistModelisArray(model) {
        /** @type {?} */
        const array = (/** @type {?} */ (model));
        return array && array.length !== undefined;
    }
}
PicklistComponent.decorators = [
    { type: Component, args: [{
                selector: 'hc-picklist',
                template: "<div class=\"hc-picklist\">\n    <div class=\"pane-wrap\">\n        <div class=\"pane-header\">\n            <h2 *ngIf=\"settings.showHeaderText\">{{settings.leftHeaderText}}</h2>\n            <div *ngIf=\"settings.useValuesets\" class=\"pane-tabs hc-tab-bar-horizontal\">\n                <a title=\"Search for Value Sets\"\n                        (click)=\"setActiveValueType('valueSets')\"\n                        class=\"hc-tab-horizontal\"\n                        [ngClass]=\"{'active': _available?.valueSetList.isActive}\">Value Sets</a>\n                <a title=\"Search for Values\"\n                    (click)=\"setActiveValueType('values')\"\n                    class=\"hc-tab-horizontal\"\n                    [ngClass]=\"{'active': _available?.valueList.isActive}\">Values</a>\n            </div>\n        </div>\n        <hc-picklist-pane #availableList\n            emptyMsg=\"No options available.\"\n            (moveSelectedItems)=\"moveSelectedItems($event);\">\n        </hc-picklist-pane>\n    </div>\n\n    <div class=\"move-btns-wrap\">\n        <button hc-button color=\"primary-alt\" type=\"button\" name=\"addBtn\"\n                (click)=\"moveSelectedItems(availableList);\"\n                [disabled]=\"_leftToRightMoveBtnIsDisabled\">\n            <hc-icon hcIconSm fontSet=\"fa\" fontIcon=\"fa-arrow-right\"></hc-icon>\n        </button>\n        <button hc-button color=\"primary-alt\" type=\"button\" name=\"removeBtn\"\n                (click)=\"moveSelectedItems(confirmedList);\"\n                [disabled]=\"!_confirmed?.isAnySelected()\">\n            <hc-icon hcIconSm fontSet=\"fa\" fontIcon=\"fa-arrow-left\"></hc-icon>\n        </button>\n    </div>\n\n    <div class=\"pane-wrap\">\n        <div class=\"pane-header\">\n            <h2 *ngIf=\"settings.showHeaderText\">{{settings.rightHeaderText}}</h2>\n        </div>\n        <hc-picklist-pane #confirmedList\n            emptyMsg=\"No options selected.\"\n            (moveSelectedItems)=\"moveSelectedItems($event);\">\n        </hc-picklist-pane>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PicklistComponent)),
                        multi: true
                    }
                ],
                styles: [".hc-picklist{-webkit-box-align:stretch;align-items:stretch;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row;height:100%;-webkit-box-pack:justify;justify-content:space-between;min-width:650px;overflow:hidden}.hc-picklist .pane-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;width:45%}.hc-picklist .pane-header{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 30px;-webkit-box-pack:justify;justify-content:space-between}.hc-picklist .pane-header h2{font-size:16px;font-weight:700;margin:3px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-picklist .pane-tabs{border-bottom:none;-webkit-box-flex:0;flex:0 0 auto}.hc-picklist .pane-tabs a{font-size:13px}.hc-picklist hc-picklist-pane{display:block;-webkit-box-flex:1;flex:1 1 auto;height:calc(100% - 30px)}.hc-picklist hc-picklist-pane.hide{display:none}.hc-picklist .move-btns-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;-webkit-box-pack:center;justify-content:center;padding-top:100px;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.hc-picklist .move-btns-wrap button{height:60px;margin-top:12px;min-width:0;padding:0;width:30px}.hc-picklist .move-btns-wrap button[disabled],.hc-picklist .move-btns-wrap button[disabled]:hover{background-color:#ccc;border-color:#ccc}.hc-picklist .move-btns-wrap .hc-icon{color:#fff}"]
            }] }
];
PicklistComponent.propDecorators = {
    settings: [{ type: Input }],
    simpleOptions: [{ type: Input }],
    showHeaderText: [{ type: Input }],
    leftHeaderText: [{ type: Input }],
    rightHeaderText: [{ type: Input }],
    sort: [{ type: Input }],
    _available: [{ type: ViewChild, args: ['availableList', { static: true },] }],
    _confirmed: [{ type: ViewChild, args: ['confirmedList', { static: true },] }],
    changed: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    PicklistComponent.prototype._available;
    /** @type {?} */
    PicklistComponent.prototype._confirmed;
    /**
     * Fired when a change is made to the picklist selection.
     * @type {?}
     */
    PicklistComponent.prototype.changed;
    /**
     * @type {?}
     * @private
     */
    PicklistComponent.prototype.picklistSettings;
    /**
     * @type {?}
     * @private
     */
    PicklistComponent.prototype.stringOptions;
    /** @type {?} */
    PicklistComponent.prototype.onChange;
    /** @type {?} */
    PicklistComponent.prototype.onTouched;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2xpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGhlYWx0aGNhdGFseXN0L2Nhc2htZXJlLyIsInNvdXJjZXMiOlsibGliL3BpY2tsaXN0L3BpY2tsaXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMvRyxPQUFPLEVBQXVCLGlCQUFpQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkUsT0FBTyxFQUFvRCxxQkFBcUIsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLGtCQUFrQixDQUFDOztNQUV0SCxrQkFBa0IsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDOzs7OztBQUNsRCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsUUFBZ0I7SUFDOUMsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzFDLE1BQU0sS0FBSyxDQUFDLGdDQUFnQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0tBQzVEO0FBQ0wsQ0FBQztBQWVELE1BQU0sT0FBTyxpQkFBaUI7SUFiOUI7Ozs7UUFtRlcsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDNUIscUJBQWdCLEdBQUcsSUFBSSxnQkFBZ0IsRUFBRSxDQUFDO1FBSTFDLGtCQUFhLEdBQXlCLElBQUksQ0FBQztRQXVCNUMsYUFBUTs7O1FBQVEsR0FBRyxFQUFFLEdBQUUsQ0FBQyxFQUFDO1FBQ3pCLGNBQVM7OztRQUFRLEdBQUcsRUFBRSxHQUFFLENBQUMsRUFBQztJQStHckMsQ0FBQzs7Ozs7O0lBOU1HLElBQ1csUUFBUSxDQUFDLFFBQTBCO1FBQzFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekIs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QUNJLE9BQU8sRUFBRSxpQkFBaUI7d0JBQzFCLFdBQVcsRUFBRSxVQUFVOzs7d0JBQUMsR0FBRyxFQUFFLENBQUMsaUJBQWlCLEVBQUM7d0JBQ2hELEtBQUssRUFBRSxJQUFJO3FCQUNkO2lCQUNKOzthQUNKOzs7dUJBS0ksS0FBSzs0QkFVTCxLQUFLOzZCQVVMLEtBQUs7NkJBVUwsS0FBSzs4QkFVTCxLQUFLO21CQVdMLEtBQUs7eUJBU0wsU0FBUyxTQUFDLGVBQWUsRUFBRSxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUM7eUJBRXpDLFNBQVMsU0FBQyxlQUFlLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDO3NCQUd6QyxNQUFNOzs7O0lBTFAsdUNBQ3FEOztJQUNyRCx1Q0FDcUQ7Ozs7O0lBRXJELG9DQUNvQzs7Ozs7SUFDcEMsNkNBQWtEOzs7OztJQUlsRCwwQ0FBbUQ7O0lBdUJuRCxxQ0FBZ0M7O0lBQ2hDLHNDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UGlja2xpc3RQYW5lQ29tcG9uZW50fSBmcm9tICcuL3BhbmUvcGlja2xpc3QtcGFuZS5jb21wb25lbnQnO1xuaW1wb3J0IHtJUGlja2xpc3RPcHRpb25zLCBJUGlja2xpc3RTZXR0aW5ncywgSVZhbHVlT3B0aW9uLCBQaWNrbGlzdE9wdGlvbnNTb3VyY2UsIFBpY2tsaXN0U2V0dGluZ3N9IGZyb20gJy4vcGlja2xpc3QubW9kZWwnO1xuXG5jb25zdCBzdXBwb3J0ZWRTb3J0TW9kZXMgPSBbJ2FzYycsICdkZXNjJywgJ25vbmUnXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNvcnRJbnB1dChpbnB1dFN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHN1cHBvcnRlZFNvcnRNb2Rlcy5pbmRleE9mKGlucHV0U3RyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvcnQgaW5wdXQgdmFsdWU6ICcgKyBpbnB1dFN0cik7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hjLXBpY2tsaXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJ3BpY2tsaXN0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsncGlja2xpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFBpY2tsaXN0Q29tcG9uZW50KSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFBpY2tsaXN0Q29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIFNldHRpbmdzIGZvciB0aGUgcGlja2xpc3QuIEludGVybmFsbHksIHRoaXMgd2lsbCB0cmlnZ2VyIGEgY2FsbCB0byBgcmVzZXQoKWAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHNldHRpbmdzKHNldHRpbmdzOiBQaWNrbGlzdFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMucmVzZXQoc2V0dGluZ3MpO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHNldHRpbmdzKCk6IFBpY2tsaXN0U2V0dGluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrbGlzdFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyB0byBiZSB1c2VkIGFzIHRoZSBwaWNrbGlzdCBvcHRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzaW1wbGVPcHRpb25zKG9wdGlvbnM6IEFycmF5PHN0cmluZz4gfCBudWxsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVGcm9tU3RyaW5nT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgcHVibGljIGdldCBzaW1wbGVPcHRpb25zKCk6IEFycmF5PHN0cmluZz4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2hvdyB0ZXh0IGluIHRoZSBoZWFkZXIuICpEZWZhdWx0cyB0byB0cnVlLipcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc2hvd0hlYWRlclRleHQoc2hvdWxkU2hvdzogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7c2hvd0hlYWRlclRleHQ6IHNob3VsZFNob3d9KTtcbiAgICB9XG4gICAgcHVibGljIGdldCBzaG93SGVhZGVyVGV4dCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2xpc3RTZXR0aW5ncy5zaG93SGVhZGVyVGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGV4dCBmb3IgbGVmdCBoZWFkZXIuICpEZWZhdWx0cyB0byBcIkF2YWlsYWJsZVwiLipcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbGVmdEhlYWRlclRleHQodGV4dDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHtsZWZ0SGVhZGVyVGV4dDogdGV4dH0pO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IGxlZnRIZWFkZXJUZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tsaXN0U2V0dGluZ3MubGVmdEhlYWRlclRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRleHQgZm9yIHJpZ2h0IGhlYWRlci4gKkRlZmF1bHRzIHRvIFwiU2VsZWN0ZWRcIi4qXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHJpZ2h0SGVhZGVyVGV4dCh0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe3JpZ2h0SGVhZGVyVGV4dDogdGV4dH0pO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHJpZ2h0SGVhZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrbGlzdFNldHRpbmdzLnJpZ2h0SGVhZGVyVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdG8gc29ydCBvcHRpb25zIGluIHRoZSBwYW5lLiBPcHRpb25zOiBgYXNjYCB8IGBkZXNjYCB8IGBub25lYDsgKkRlZmF1bHRzIHRvIGBub25lYC4qXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHNvcnQoc29ydDogc3RyaW5nKSB7XG4gICAgICAgIHZhbGlkYXRlU29ydElucHV0KHNvcnQpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7c29ydDogc29ydH0pO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHNvcnQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2xpc3RTZXR0aW5ncy5zb3J0O1xuICAgIH1cblxuICAgIEBWaWV3Q2hpbGQoJ2F2YWlsYWJsZUxpc3QnLCB7c3RhdGljOiB0cnVlfSlcbiAgICBwdWJsaWMgX2F2YWlsYWJsZTogUGlja2xpc3RQYW5lQ29tcG9uZW50IHwgdW5kZWZpbmVkO1xuICAgIEBWaWV3Q2hpbGQoJ2NvbmZpcm1lZExpc3QnLCB7c3RhdGljOiB0cnVlfSlcbiAgICBwdWJsaWMgX2NvbmZpcm1lZDogUGlja2xpc3RQYW5lQ29tcG9uZW50IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBGaXJlZCB3aGVuIGEgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIHBpY2tsaXN0IHNlbGVjdGlvbi4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBwcml2YXRlIHBpY2tsaXN0U2V0dGluZ3MgPSBuZXcgUGlja2xpc3RTZXR0aW5ncygpO1xuICAgIHB1YmxpYyBnZXQgX2xlZnRUb1JpZ2h0TW92ZUJ0bklzRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdmFpbGFibGUgPyAhdGhpcy5fYXZhaWxhYmxlLmlzQW55U2VsZWN0ZWQoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBwcml2YXRlIHN0cmluZ09wdGlvbnM6IEFycmF5PHN0cmluZz4gfCBudWxsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2VsZWN0ZWQgdmFsdWUgb2YgdGhlIHBpY2tsaXN0LiBXaWxsIGJlIGVpdGhlciBgSVBpY2tsaXN0T3B0aW9uc2Agb3IgYHN0cmluZ1tdYCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2Ygb3B0aW9ucyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHZhbHVlKG1vZGVsOiBJUGlja2xpc3RPcHRpb25zIHwgc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXM6IElQaWNrbGlzdE9wdGlvbnMgPSB7dmFsdWVzOiBbXSwgdmFsdWVTZXRzOiBbXX07XG4gICAgICAgIGlmICh0aGlzLnBpY2tsaXN0TW9kZWxpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmNvbnZlcnRTdHJpbmdzVG9WYWx1ZU9wdGlvbnMobW9kZWwpO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMudmFsdWVzID0gc2VsZWN0ZWQgfHwgW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcy52YWx1ZXMgPSBtb2RlbC52YWx1ZXMgfHwgW107XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcy52YWx1ZVNldHMgPSBtb2RlbC52YWx1ZVNldHMgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe3NlbGVjdGVkOiBzZWxlY3RlZFZhbHVlc30pO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IElQaWNrbGlzdE9wdGlvbnMgfCBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmluZ09wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBpY2tsaXN0U2V0dGluZ3Muc2VsZWN0ZWQudmFsdWVzLm1hcCh2ID0+IHYudGl0bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGlja2xpc3RTZXR0aW5ncy5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgb25DaGFuZ2U6IGFueSA9ICgpID0+IHt9O1xuICAgIHB1YmxpYyBvblRvdWNoZWQ6IGFueSA9ICgpID0+IHt9O1xuICAgIHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICBwdWJsaWMgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICBwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogSVBpY2tsaXN0T3B0aW9ucyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lsbCB1cGRhdGUgdGhlIHBpY2tsaXN0IHdpdGggdGhlIGdpdmVuIHNldHRpbmdzLCBtYWludGFpbmluZyBhbnkgcHJldmlvdXMgc2V0dGluZ3MgdGhhdCBoYXZlIG5vdCBiZWVuIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZShzZXR0aW5nczogSVBpY2tsaXN0U2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLnBpY2tsaXN0U2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5yZXNldCh1cGRhdGVkU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgcmVzZXQgdGhlIHBpY2tsaXN0IHNldHRpbmdzIHdpdGggdGhlIGdpdmVuIHNldHRpbmdzLiAoQ2xlYXJzIG91dCBhbnkgcHJldmlvdXMgc2V0dGluZ3MuKVxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldChzZXR0aW5nczogSVBpY2tsaXN0U2V0dGluZ3MgPSBuZXcgUGlja2xpc3RTZXR0aW5ncygpKSB7XG4gICAgICAgIHRoaXMucGlja2xpc3RTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24obmV3IFBpY2tsaXN0U2V0dGluZ3MoKSwgc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnJlc2V0UGFuZXModGhpcy5waWNrbGlzdFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVWYWx1ZVR5cGUodGhpcy5waWNrbGlzdFNldHRpbmdzLnVzZVZhbHVlc2V0cyA/ICd2YWx1ZVNldHMnIDogJ3ZhbHVlcycpO1xuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlVG9Nb2RlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgY2hhbmdlIHRoZSBhY3RpdmUgdGFiLiAoV2lsbCBkbyBub3RoaW5nIGlmIGBzZXR0aW5ncy51c2VWYWx1ZXNldHNgIGlzIGZhbHNlLilcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0QWN0aXZlVmFsdWVUeXBlKHR5cGU6ICd2YWx1ZXMnIHwgJ3ZhbHVlU2V0cycpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQXZhaWxhYmxlIHBpY2tsaXN0IHBhbmUgbm90IGF2YWlsYWJsZSB5ZXQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnVzZVZhbHVlc2V0cykge1xuICAgICAgICAgICAgdHlwZSA9ICd2YWx1ZXMnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlLnZhbHVlTGlzdC5pc0FjdGl2ZSA9IHR5cGUgPT09ICd2YWx1ZXMnO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGUudmFsdWVTZXRMaXN0LmlzQWN0aXZlID0gdHlwZSA9PT0gJ3ZhbHVlU2V0cyc7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZS5zZWxlY3ROb25lKCk7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZS5zY3JvbGxUb1RvcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgbW92ZSBhbGwgc2VsZWN0ZWQgaXRlbXMgZnJvbSB0aGUgZ2l2ZW4gcGFuZSBpbnRvIGl0cyBjb21wYW5pb24gcGFuZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsZWZ0IGFuZCByaWdodCBhcnJvdyBidXR0b25zLlxuICAgICAqIEBwYXJhbSBwYW5lIHRoZSBwYW5lIGZyb20gd2hpY2ggd2UgYXJlIG1vdmluZyBpdGVtcyBvdXQgb2ZcbiAgICAgKi9cbiAgICBwdWJsaWMgbW92ZVNlbGVjdGVkSXRlbXMocGFuZTogUGlja2xpc3RQYW5lQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEJyZWFrVmFsdWVzZXRzID0gcGFuZSA9PT0gdGhpcy5fY29uZmlybWVkO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSBwYW5lLmxpc3RTZXJ2aWNlLm1vdmVPdXRTZWxlY3RlZE9wdGlvbnMoc2hvdWxkQnJlYWtWYWx1ZXNldHMpO1xuICAgICAgICBpZiAocGFuZS5jb21wYW5pb24pIHtcbiAgICAgICAgICAgIHBhbmUuY29tcGFuaW9uLmxpc3RTZXJ2aWNlLmFkZE9wdGlvbnMoc2VsZWN0ZWRPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhpcyBwYW5lIGRvZXMgbm90IGhhdmUgYSBjb21wYW5pb24gcGFuZSB0byBtb3ZlIHRoZSBzZWxlY3Qgb3B0aW9ucyBpbiB0by4nKTtcbiAgICAgICAgfVxuICAgICAgICBwYW5lLmZpbHRlclNlcnZpY2UucmVsb2FkSWZFbXB0eSgpO1xuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlVG9Nb2RlbCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU3RhdGVGcm9tU3RyaW5nT3B0aW9ucyhvcHRpb25zOiBBcnJheTxzdHJpbmc+IHwgbnVsbCkge1xuICAgICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSB0aGlzLmNvbnZlcnRTdHJpbmdzVG9WYWx1ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3RyaW5nT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlKHtvcHRpb25zOiB7dmFsdWVzOiB2YWx1ZU9wdGlvbnMgfHwgW119fSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldFBhbmVzKHNldHRpbmdzOiBJUGlja2xpc3RTZXR0aW5ncykge1xuICAgICAgICBpZiAoISh0aGlzLl9hdmFpbGFibGUgJiYgdGhpcy5fY29uZmlybWVkKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQaWNrbGlzdCBwYW5lcyBub3QgYXZhaWxhYmxlIHlldC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZFNvdXJjZSA9IG5ldyBQaWNrbGlzdE9wdGlvbnNTb3VyY2UoKTtcbiAgICAgICAgY29uZmlybWVkU291cmNlLnZhbHVlcyA9IHRoaXMucGlja2xpc3RTZXR0aW5ncy5zZWxlY3RlZC52YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIGNvbmZpcm1lZFNvdXJjZS52YWx1ZVNldHMgPSB0aGlzLnBpY2tsaXN0U2V0dGluZ3Muc2VsZWN0ZWQudmFsdWVTZXRzLnNsaWNlKDApO1xuICAgICAgICBjb25maXJtZWRTb3VyY2UuZ2V0VmFsdWVzRm9yVmFsdWVzZXQgPSB0aGlzLnBpY2tsaXN0U2V0dGluZ3Mub3B0aW9ucy5nZXRWYWx1ZXNGb3JWYWx1ZXNldDtcbiAgICAgICAgdGhpcy5fY29uZmlybWVkLnJlc2V0KGNvbmZpcm1lZFNvdXJjZSwgdGhpcy5waWNrbGlzdFNldHRpbmdzLCB0aGlzLl9hdmFpbGFibGUsIGZhbHNlKTtcblxuICAgICAgICBjb25zdCBhdmFpbGFibGVTb3VyY2UgPSBPYmplY3QuYXNzaWduKG5ldyBQaWNrbGlzdE9wdGlvbnNTb3VyY2UoKSwgdGhpcy5waWNrbGlzdFNldHRpbmdzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGUucmVzZXQoYXZhaWxhYmxlU291cmNlLCB0aGlzLnBpY2tsaXN0U2V0dGluZ3MsIHRoaXMuX2NvbmZpcm1lZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseUNoYW5nZVRvTW9kZWwoKSB7XG4gICAgICAgIGlmICghKHRoaXMuX2F2YWlsYWJsZSAmJiB0aGlzLl9jb25maXJtZWQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpY2tsaXN0IHBhbmVzIG5vdCBhdmFpbGFibGUgeWV0LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5waWNrbGlzdFNldHRpbmdzLnNlbGVjdGVkLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBpY2tsaXN0U2V0dGluZ3Muc2VsZWN0ZWQudmFsdWVTZXRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbmZpcm1lZC52YWx1ZUxpc3Qub3B0aW9ucy5mb3JFYWNoKGUgPT4gdGhpcy5waWNrbGlzdFNldHRpbmdzLnNlbGVjdGVkLnZhbHVlcy5wdXNoKGUub3B0aW9uKSk7XG4gICAgICAgIHRoaXMuX2NvbmZpcm1lZC52YWx1ZVNldExpc3Qub3B0aW9ucy5mb3JFYWNoKGUgPT4gdGhpcy5waWNrbGlzdFNldHRpbmdzLnNlbGVjdGVkLnZhbHVlU2V0cy5wdXNoKGUub3B0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnZlcnRTdHJpbmdzVG9WYWx1ZU9wdGlvbnModmFsczogQXJyYXk8c3RyaW5nPiB8IG51bGwpOiBJVmFsdWVPcHRpb25bXSB8IG51bGwge1xuICAgICAgICByZXR1cm4gdmFscyA/IHZhbHMubWFwKG8gPT4gKHtjb2RlOiBgJHtvfWAsIHRpdGxlOiBgJHtvfWB9KSkgOiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGlja2xpc3RNb2RlbGlzQXJyYXkobW9kZWw6IElQaWNrbGlzdE9wdGlvbnMgfCBBcnJheTxzdHJpbmc+KTogbW9kZWwgaXMgQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gPEFycmF5PHN0cmluZz4+bW9kZWw7XG4gICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICB9XG59XG4iXX0=