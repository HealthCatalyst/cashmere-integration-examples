/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/cell-resizer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/* Based on an example posted by Paolo Caleffi at: https://github.com/angular/material2/issues/8312 */
import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, HostListener, Input, Output, ViewEncapsulation } from '@angular/core';
import { BindObservable } from './bind-observable/bind-observable';
import { untilDestroyed } from '../util';
import { fromEvent } from 'rxjs';
import { skip } from 'rxjs/operators';
var CellResizeEvent = /** @class */ (function () {
    function CellResizeEvent(width, directionLeft) {
        this.width = width;
        this.directionLeft = directionLeft;
    }
    return CellResizeEvent;
}());
export { CellResizeEvent };
if (false) {
    /** @type {?} */
    CellResizeEvent.prototype.width;
    /** @type {?} */
    CellResizeEvent.prototype.directionLeft;
}
var HcCellResizer = /** @class */ (function () {
    function HcCellResizer() {
        /**
         * Sets whether the resizer is active or not
         */
        this.disabled = false;
        this._directionModifier = 1;
        /**
         * Emits a `CellResizeEvent` when a cell has been resized
         */
        this.resized = new EventEmitter();
        this.isResizing = false;
        /**
         * Emits a boolean value of true while a cell is being resized
         */
        this.resizing = new EventEmitter();
    }
    Object.defineProperty(HcCellResizer.prototype, "width", {
        /**
         * Stores the width value for this resizer;
         * typically used with two-way binding on the cell's style.width property
         */
        get: /**
         * Stores the width value for this resizer;
         * typically used with two-way binding on the cell's style.width property
         * @return {?}
         */
        function () {
            return this._width;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value > 0) {
                this._width = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    HcCellResizer.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.isResizing$
            .pipe(
        // Skip default value
        skip(1), untilDestroyed(this))
            .subscribe((/**
         * @param {?} isResizing
         * @return {?}
         */
        function (isResizing) {
            _this.resizing.emit(isResizing);
            if (isResizing) {
                // We must use arrow function to avoid losing the context,
                //  we cannot pass directly the functions references
                _this.dragSubscription = fromEvent(window.document, 'mousemove')
                    .pipe(untilDestroyed(_this))
                    .subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this._resizeColumn(event); }));
                _this.dragSubscription.add(fromEvent(window.document, 'mouseup')
                    .pipe(untilDestroyed(_this))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._stopResizing(); })));
            }
            else {
                // When resize finishes, we emit one last "resized" event for which
                //  the corresponding "isResizing" value will be false.
                // This can be used to detect which is the final resizing event
                //  and ignore the others
                _this.resized.emit(new CellResizeEvent(_this.width, _this._directionModifier === -1));
                if (_this.dragSubscription) {
                    _this.dragSubscription.unsubscribe();
                }
            }
        }));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    HcCellResizer.prototype._resizeColumn = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var deltaX = event.screenX - this._mouseX;
        /** @type {?} */
        var newWidth = this.width + deltaX * this._directionModifier;
        this._mouseX = event.screenX;
        if (newWidth >= 0) {
            this.resized.emit(new CellResizeEvent(newWidth, this._directionModifier === -1));
        }
        // Prevent text selection while resizing
        event.preventDefault();
        event.stopPropagation();
    };
    // Same problems that mousemove listener have
    // Same problems that mousemove listener have
    /**
     * @private
     * @return {?}
     */
    HcCellResizer.prototype._stopResizing = 
    // Same problems that mousemove listener have
    /**
     * @private
     * @return {?}
     */
    function () {
        this.isResizing = false;
    };
    // isResizing can be set to true only when the component is not disabled
    // isResizing can be set to true only when the component is not disabled
    /**
     * @param {?} event
     * @return {?}
     */
    HcCellResizer.prototype._startResizing = 
    // isResizing can be set to true only when the component is not disabled
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.isResizing = !this.disabled;
        this._mouseX = event.screenX;
        if (((/** @type {?} */ (event.target))).className === 'hc-cell-resizer-left') {
            this._directionModifier = -1;
        }
        else {
            this._directionModifier = 1;
        }
        // Prevent text selection while resizing
        event.preventDefault();
        event.stopPropagation();
    };
    // Must be present for AOT compilation to work, even if empty
    // Otherwise 'ng build --prod' will optimize away any calls to ngOnDestroy,
    // even if the method is added by the untilDestroyed operator
    // Must be present for AOT compilation to work, even if empty
    // Otherwise 'ng build --prod' will optimize away any calls to ngOnDestroy,
    // even if the method is added by the untilDestroyed operator
    /**
     * @return {?}
     */
    HcCellResizer.prototype.ngOnDestroy = 
    // Must be present for AOT compilation to work, even if empty
    // Otherwise 'ng build --prod' will optimize away any calls to ngOnDestroy,
    // even if the method is added by the untilDestroyed operator
    /**
     * @return {?}
     */
    function () { };
    HcCellResizer.decorators = [
        { type: Component, args: [{
                    selector: 'hc-cell-resizer',
                    template: '<div class="hc-cell-resizer-left"></div><div class="hc-cell-resizer-right"></div>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    HcCellResizer.propDecorators = {
        disabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        width: [{ type: Input }],
        resized: [{ type: Output }],
        resizing: [{ type: Output }],
        _startResizing: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    tslib_1.__decorate([
        BindObservable(),
        tslib_1.__metadata("design:type", Object)
    ], HcCellResizer.prototype, "isResizing", void 0);
    return HcCellResizer;
}());
export { HcCellResizer };
if (false) {
    /**
     * Sets whether the resizer is active or not
     * @type {?}
     */
    HcCellResizer.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._width;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._directionModifier;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype._mouseX;
    /**
     * Emits a `CellResizeEvent` when a cell has been resized
     * @type {?}
     */
    HcCellResizer.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.isResizing;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.isResizing$;
    /**
     * Emits a boolean value of true while a cell is being resized
     * @type {?}
     */
    HcCellResizer.prototype.resizing;
    /**
     * @type {?}
     * @private
     */
    HcCellResizer.prototype.dragSubscription;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC1yZXNpemVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi90YWJsZS9jZWxsLXJlc2l6ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBR0wsTUFBTSxFQUNOLGlCQUFpQixFQUNwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDakUsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUN2QyxPQUFPLEVBQUMsU0FBUyxFQUEyQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEM7SUFDSSx5QkFBbUIsS0FBYSxFQUFTLGFBQXNCO1FBQTVDLFVBQUssR0FBTCxLQUFLLENBQVE7UUFBUyxrQkFBYSxHQUFiLGFBQWEsQ0FBUztJQUFHLENBQUM7SUFDdkUsc0JBQUM7QUFBRCxDQUFDLEFBRkQsSUFFQzs7OztJQURlLGdDQUFvQjs7SUFBRSx3Q0FBNkI7O0FBR25FO0lBQUE7Ozs7UUFXNEMsYUFBUSxHQUFHLEtBQUssQ0FBQztRQWlCakQsdUJBQWtCLEdBQVcsQ0FBQyxDQUFDOzs7O1FBT3RCLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBbUIsQ0FBQztRQUVyQyxlQUFVLEdBQUcsS0FBSyxDQUFDOzs7O1FBTTVCLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO0lBOEU1RCxDQUFDO0lBeEdHLHNCQUNJLGdDQUFLO1FBTFQ7OztXQUdHOzs7Ozs7UUFDSDtZQUVJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDOzs7OztRQUNELFVBQVUsS0FB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WUFDOUQsSUFBSSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO2FBQU07WUFDSCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO1NBQy9CO1FBRUQsd0NBQXdDO1FBQ3hDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELDZEQUE2RDtJQUM3RCwyRUFBMkU7SUFDM0UsNkRBQTZEOzs7Ozs7O0lBQ3RELG1DQUFXOzs7Ozs7O0lBQWxCLGNBQXNCLENBQUM7O2dCQXhIMUIsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFFBQVEsRUFBRSxtRkFBbUY7b0JBRTdGLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtpQkFDeEM7OzsyQkFLSSxXQUFXLFNBQUMsZ0JBQWdCLGNBQUcsS0FBSzt3QkFNcEMsS0FBSzswQkFrQkwsTUFBTTsyQkFRTixNQUFNO2lDQTBETixZQUFZLFNBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDOztJQWhFbkI7UUFBakIsY0FBYyxFQUFFOztxREFBNEI7SUFvRmpELG9CQUFDO0NBQUEsQUF6SEQsSUF5SEM7U0FsSFksYUFBYTs7Ozs7O0lBSXRCLGlDQUF5RDs7Ozs7SUFlekQsK0JBQXdCOzs7OztJQUV4QiwyQ0FBdUM7Ozs7O0lBRXZDLGdDQUF3Qjs7Ozs7SUFLeEIsZ0NBQStEOzs7OztJQUUvRCxtQ0FBNkM7Ozs7O0lBQzdDLG9DQUEwQzs7Ozs7SUFLMUMsaUNBQXdEOzs7OztJQUV4RCx5Q0FBd0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBCYXNlZCBvbiBhbiBleGFtcGxlIHBvc3RlZCBieSBQYW9sbyBDYWxlZmZpIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9tYXRlcmlhbDIvaXNzdWVzLzgzMTIgKi9cblxuaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmluZE9ic2VydmFibGV9IGZyb20gJy4vYmluZC1vYnNlcnZhYmxlL2JpbmQtb2JzZXJ2YWJsZSc7XG5pbXBvcnQge3VudGlsRGVzdHJveWVkfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7ZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtza2lwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBDZWxsUmVzaXplRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB3aWR0aDogbnVtYmVyLCBwdWJsaWMgZGlyZWN0aW9uTGVmdDogYm9vbGVhbikge31cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdoYy1jZWxsLXJlc2l6ZXInLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cImhjLWNlbGwtcmVzaXplci1sZWZ0XCI+PC9kaXY+PGRpdiBjbGFzcz1cImhjLWNlbGwtcmVzaXplci1yaWdodFwiPjwvZGl2PicsXG4gICAgc3R5bGVVcmxzOiBbXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIEhjQ2VsbFJlc2l6ZXIgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSByZXNpemVyIGlzIGFjdGl2ZSBvciBub3RcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmRpc2FibGVkJykgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgd2lkdGggdmFsdWUgZm9yIHRoaXMgcmVzaXplcjtcbiAgICAgKiB0eXBpY2FsbHkgdXNlZCB3aXRoIHR3by13YXkgYmluZGluZyBvbiB0aGUgY2VsbCdzIHN0eWxlLndpZHRoIHByb3BlcnR5XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgd2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICBzZXQgd2lkdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgX3dpZHRoITogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uTW9kaWZpZXI6IG51bWJlciA9IDE7XG5cbiAgICBwcml2YXRlIF9tb3VzZVg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgYENlbGxSZXNpemVFdmVudGAgd2hlbiBhIGNlbGwgaGFzIGJlZW4gcmVzaXplZFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVzaXplZCA9IG5ldyBFdmVudEVtaXR0ZXI8Q2VsbFJlc2l6ZUV2ZW50PigpO1xuXG4gICAgQEJpbmRPYnNlcnZhYmxlKCkgcHJpdmF0ZSBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBpc1Jlc2l6aW5nJCE6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIGJvb2xlYW4gdmFsdWUgb2YgdHJ1ZSB3aGlsZSBhIGNlbGwgaXMgYmVpbmcgcmVzaXplZFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVzaXppbmcgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBwcml2YXRlIGRyYWdTdWJzY3JpcHRpb24/OiBTdWJzY3JpcHRpb247XG5cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNSZXNpemluZyRcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIC8vIFNraXAgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgIHNraXAoMSksXG4gICAgICAgICAgICAgICAgdW50aWxEZXN0cm95ZWQodGhpcylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaXNSZXNpemluZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZy5lbWl0KGlzUmVzaXppbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCB1c2UgYXJyb3cgZnVuY3Rpb24gdG8gYXZvaWQgbG9zaW5nIHRoZSBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAvLyAgd2UgY2Fubm90IHBhc3MgZGlyZWN0bHkgdGhlIGZ1bmN0aW9ucyByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N1YnNjcmlwdGlvbiA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih3aW5kb3cuZG9jdW1lbnQsICdtb3VzZW1vdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUodW50aWxEZXN0cm95ZWQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGV2ZW50ID0+IHRoaXMuX3Jlc2l6ZUNvbHVtbihldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KHdpbmRvdy5kb2N1bWVudCwgJ21vdXNldXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKHVudGlsRGVzdHJveWVkKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fc3RvcFJlc2l6aW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiByZXNpemUgZmluaXNoZXMsIHdlIGVtaXQgb25lIGxhc3QgXCJyZXNpemVkXCIgZXZlbnQgZm9yIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgIC8vICB0aGUgY29ycmVzcG9uZGluZyBcImlzUmVzaXppbmdcIiB2YWx1ZSB3aWxsIGJlIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVjdCB3aGljaCBpcyB0aGUgZmluYWwgcmVzaXppbmcgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFuZCBpZ25vcmUgdGhlIG90aGVyc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZWQuZW1pdChuZXcgQ2VsbFJlc2l6ZUV2ZW50KHRoaXMud2lkdGgsIHRoaXMuX2RpcmVjdGlvbk1vZGlmaWVyID09PSAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFnU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3Jlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSBldmVudC5zY3JlZW5YIC0gdGhpcy5fbW91c2VYO1xuICAgICAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGggKyBkZWx0YVggKiB0aGlzLl9kaXJlY3Rpb25Nb2RpZmllcjtcblxuICAgICAgICB0aGlzLl9tb3VzZVggPSBldmVudC5zY3JlZW5YO1xuXG4gICAgICAgIGlmIChuZXdXaWR0aCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZWQuZW1pdChuZXcgQ2VsbFJlc2l6ZUV2ZW50KG5ld1dpZHRoLCB0aGlzLl9kaXJlY3Rpb25Nb2RpZmllciA9PT0gLTEpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoaWxlIHJlc2l6aW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIFNhbWUgcHJvYmxlbXMgdGhhdCBtb3VzZW1vdmUgbGlzdGVuZXIgaGF2ZVxuICAgIHByaXZhdGUgX3N0b3BSZXNpemluZygpIHtcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaXNSZXNpemluZyBjYW4gYmUgc2V0IHRvIHRydWUgb25seSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGRpc2FibGVkXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJywgWyckZXZlbnQnXSkgX3N0YXJ0UmVzaXppbmcoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gIXRoaXMuZGlzYWJsZWQ7XG5cbiAgICAgICAgdGhpcy5fbW91c2VYID0gZXZlbnQuc2NyZWVuWDtcblxuICAgICAgICBpZiAoKDxFbGVtZW50PmV2ZW50LnRhcmdldCkuY2xhc3NOYW1lID09PSAnaGMtY2VsbC1yZXNpemVyLWxlZnQnKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25Nb2RpZmllciA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uTW9kaWZpZXIgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGlsZSByZXNpemluZ1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IGJlIHByZXNlbnQgZm9yIEFPVCBjb21waWxhdGlvbiB0byB3b3JrLCBldmVuIGlmIGVtcHR5XG4gICAgLy8gT3RoZXJ3aXNlICduZyBidWlsZCAtLXByb2QnIHdpbGwgb3B0aW1pemUgYXdheSBhbnkgY2FsbHMgdG8gbmdPbkRlc3Ryb3ksXG4gICAgLy8gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGFkZGVkIGJ5IHRoZSB1bnRpbERlc3Ryb3llZCBvcGVyYXRvclxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHt9XG59XG4iXX0=