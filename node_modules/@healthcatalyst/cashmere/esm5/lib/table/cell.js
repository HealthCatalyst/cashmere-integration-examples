/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/cell.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/* tslint:disable:directive-class-suffix directive-selector no-host-metadata-property no-input-rename*/
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, ElementRef, Input } from '@angular/core';
import { CdkCell, CdkCellDef, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkHeaderCell, CdkHeaderCellDef } from '@angular/cdk/table';
/**
 * Cell definition for the hc-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
var HcCellDef = /** @class */ (function (_super) {
    tslib_1.__extends(HcCellDef, _super);
    function HcCellDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HcCellDef.decorators = [
        { type: Directive, args: [{
                    selector: '[hcCellDef]',
                    providers: [{ provide: CdkCellDef, useExisting: HcCellDef }]
                },] }
    ];
    return HcCellDef;
}(CdkCellDef));
export { HcCellDef };
/**
 * Header cell definition for the hc-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
var HcHeaderCellDef = /** @class */ (function (_super) {
    tslib_1.__extends(HcHeaderCellDef, _super);
    function HcHeaderCellDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HcHeaderCellDef.decorators = [
        { type: Directive, args: [{
                    selector: '[hcHeaderCellDef]',
                    providers: [{ provide: CdkHeaderCellDef, useExisting: HcHeaderCellDef }]
                },] }
    ];
    return HcHeaderCellDef;
}(CdkHeaderCellDef));
export { HcHeaderCellDef };
/**
 * Footer cell definition for the hc-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
var HcFooterCellDef = /** @class */ (function (_super) {
    tslib_1.__extends(HcFooterCellDef, _super);
    function HcFooterCellDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HcFooterCellDef.decorators = [
        { type: Directive, args: [{
                    selector: '[hcFooterCellDef]',
                    providers: [{ provide: CdkFooterCellDef, useExisting: HcFooterCellDef }]
                },] }
    ];
    return HcFooterCellDef;
}(CdkFooterCellDef));
export { HcFooterCellDef };
/**
 * Column definition for the hc-table.
 * Defines a set of cells available for a table column.
 */
var HcColumnDef = /** @class */ (function (_super) {
    tslib_1.__extends(HcColumnDef, _super);
    function HcColumnDef() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._justify = 'left';
        return _this;
    }
    Object.defineProperty(HcColumnDef.prototype, "justify", {
        /** Sets the text alignment for this column: `left` (default), `center` or `right` */
        get: /**
         * Sets the text alignment for this column: `left` (default), `center` or `right`
         * @return {?}
         */
        function () {
            return this._justify;
        },
        set: /**
         * @param {?} justifyVal
         * @return {?}
         */
        function (justifyVal) {
            if (justifyVal === 'left' || justifyVal === 'center' || justifyVal === 'right') {
                this._justify = justifyVal;
            }
            else {
                throw Error('Unsupported table column alignment value: ' + justifyVal);
            }
        },
        enumerable: true,
        configurable: true
    });
    HcColumnDef.decorators = [
        { type: Directive, args: [{
                    selector: '[hcColumnDef]',
                    providers: [{ provide: CdkColumnDef, useExisting: HcColumnDef }]
                },] }
    ];
    HcColumnDef.propDecorators = {
        name: [{ type: Input, args: ['hcColumnDef',] }],
        justify: [{ type: Input }],
        sticky: [{ type: Input }],
        stickyEnd: [{ type: Input }]
    };
    return HcColumnDef;
}(CdkColumnDef));
export { HcColumnDef };
if (false) {
    /**
     * @type {?}
     * @private
     */
    HcColumnDef.prototype._justify;
    /**
     * Unique name for this column.
     * @type {?}
     */
    HcColumnDef.prototype.name;
    /**
     * Whether this column should be sticky positioned at the start of the row
     * @type {?}
     */
    HcColumnDef.prototype.sticky;
    /**
     * Whether this column should be sticky positioned on the end of the row
     * @type {?}
     */
    HcColumnDef.prototype.stickyEnd;
}
/**
 * Header cell template container that adds the right classes and role.
 */
var HcHeaderCell = /** @class */ (function (_super) {
    tslib_1.__extends(HcHeaderCell, _super);
    function HcHeaderCell(columnDef, elementRef) {
        var _this = _super.call(this, columnDef, elementRef) || this;
        elementRef.nativeElement.classList.add("hc-column-" + columnDef.cssClassFriendlyName);
        elementRef.nativeElement.classList.add("hc-table-justify-" + columnDef.justify);
        return _this;
    }
    HcHeaderCell.decorators = [
        { type: Directive, args: [{
                    selector: 'hc-header-cell, th[hc-header-cell]',
                    host: {
                        class: 'hc-header-cell',
                        role: 'columnheader'
                    }
                },] }
    ];
    /** @nocollapse */
    HcHeaderCell.ctorParameters = function () { return [
        { type: HcColumnDef },
        { type: ElementRef }
    ]; };
    return HcHeaderCell;
}(CdkHeaderCell));
export { HcHeaderCell };
/**
 * Footer cell template container that adds the right classes and role.
 */
var HcFooterCell = /** @class */ (function (_super) {
    tslib_1.__extends(HcFooterCell, _super);
    function HcFooterCell(columnDef, elementRef) {
        var _this = _super.call(this, columnDef, elementRef) || this;
        elementRef.nativeElement.classList.add("hc-column-" + columnDef.cssClassFriendlyName);
        elementRef.nativeElement.classList.add("hc-table-justify-" + columnDef.justify);
        return _this;
    }
    HcFooterCell.decorators = [
        { type: Directive, args: [{
                    selector: 'hc-footer-cell, td[hc-footer-cell]',
                    host: {
                        class: 'hc-footer-cell',
                        role: 'gridcell'
                    }
                },] }
    ];
    /** @nocollapse */
    HcFooterCell.ctorParameters = function () { return [
        { type: HcColumnDef },
        { type: ElementRef }
    ]; };
    return HcFooterCell;
}(CdkFooterCell));
export { HcFooterCell };
/**
 * Cell template container that adds the right classes and role.
 */
var HcCell = /** @class */ (function (_super) {
    tslib_1.__extends(HcCell, _super);
    function HcCell(columnDef, elementRef) {
        var _this = _super.call(this, columnDef, elementRef) || this;
        elementRef.nativeElement.classList.add("hc-column-" + columnDef.cssClassFriendlyName);
        elementRef.nativeElement.classList.add("hc-table-justify-" + columnDef.justify);
        return _this;
    }
    HcCell.decorators = [
        { type: Directive, args: [{
                    selector: 'hc-cell, td[hc-cell]',
                    host: {
                        class: 'hc-cell',
                        role: 'gridcell'
                    }
                },] }
    ];
    /** @nocollapse */
    HcCell.ctorParameters = function () { return [
        { type: HcColumnDef },
        { type: ElementRef }
    ]; };
    return HcCell;
}(CdkCell));
export { HcCell };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi90YWJsZS9jZWxsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBVUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzNELE9BQU8sRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7Ozs7O0FBTXZJO0lBSStCLHFDQUFVO0lBSnpDOztJQUkyQyxDQUFDOztnQkFKM0MsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxhQUFhO29CQUN2QixTQUFTLEVBQUUsQ0FBQyxFQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBQyxDQUFDO2lCQUM3RDs7SUFDMEMsZ0JBQUM7Q0FBQSxBQUo1QyxDQUkrQixVQUFVLEdBQUc7U0FBL0IsU0FBUzs7Ozs7QUFNdEI7SUFJcUMsMkNBQWdCO0lBSnJEOztJQUl1RCxDQUFDOztnQkFKdkQsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFNBQVMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUMsQ0FBQztpQkFDekU7O0lBQ3NELHNCQUFDO0NBQUEsQUFKeEQsQ0FJcUMsZ0JBQWdCLEdBQUc7U0FBM0MsZUFBZTs7Ozs7QUFNNUI7SUFJcUMsMkNBQWdCO0lBSnJEOztJQUl1RCxDQUFDOztnQkFKdkQsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFNBQVMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUMsQ0FBQztpQkFDekU7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QyxDQUFDO1FBQ3RGLFVBQVUsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7O0lBQ3BGLENBQUM7O2dCQVpKLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsc0JBQXNCO29CQUNoQyxJQUFJLEVBQUU7d0JBQ0YsS0FBSyxFQUFFLFNBQVM7d0JBQ2hCLElBQUksRUFBRSxVQUFVO3FCQUNuQjtpQkFDSjs7OztnQkFFMEIsV0FBVztnQkFoSG5CLFVBQVU7O0lBcUg3QixhQUFDO0NBQUEsQUFiRCxDQU80QixPQUFPLEdBTWxDO1NBTlksTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXggZGlyZWN0aXZlLXNlbGVjdG9yIG5vLWhvc3QtbWV0YWRhdGEtcHJvcGVydHkgbm8taW5wdXQtcmVuYW1lKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Nka0NlbGwsIENka0NlbGxEZWYsIENka0NvbHVtbkRlZiwgQ2RrRm9vdGVyQ2VsbCwgQ2RrRm9vdGVyQ2VsbERlZiwgQ2RrSGVhZGVyQ2VsbCwgQ2RrSGVhZGVyQ2VsbERlZn0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RhYmxlJztcblxuLyoqXG4gKiBDZWxsIGRlZmluaXRpb24gZm9yIHRoZSBoYy10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2hjQ2VsbERlZl0nLFxuICAgIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtDZWxsRGVmLCB1c2VFeGlzdGluZzogSGNDZWxsRGVmfV1cbn0pXG5leHBvcnQgY2xhc3MgSGNDZWxsRGVmIGV4dGVuZHMgQ2RrQ2VsbERlZiB7fVxuXG4vKipcbiAqIEhlYWRlciBjZWxsIGRlZmluaXRpb24gZm9yIHRoZSBoYy10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGhlYWRlciBjZWxsIGFuZCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaGNIZWFkZXJDZWxsRGVmXScsXG4gICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IENka0hlYWRlckNlbGxEZWYsIHVzZUV4aXN0aW5nOiBIY0hlYWRlckNlbGxEZWZ9XVxufSlcbmV4cG9ydCBjbGFzcyBIY0hlYWRlckNlbGxEZWYgZXh0ZW5kcyBDZGtIZWFkZXJDZWxsRGVmIHt9XG5cbi8qKlxuICogRm9vdGVyIGNlbGwgZGVmaW5pdGlvbiBmb3IgdGhlIGhjLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZm9vdGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1toY0Zvb3RlckNlbGxEZWZdJyxcbiAgICBwcm92aWRlcnM6IFt7cHJvdmlkZTogQ2RrRm9vdGVyQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IEhjRm9vdGVyQ2VsbERlZn1dXG59KVxuZXhwb3J0IGNsYXNzIEhjRm9vdGVyQ2VsbERlZiBleHRlbmRzIENka0Zvb3RlckNlbGxEZWYge31cblxuLyoqXG4gKiBDb2x1bW4gZGVmaW5pdGlvbiBmb3IgdGhlIGhjLXRhYmxlLlxuICogRGVmaW5lcyBhIHNldCBvZiBjZWxscyBhdmFpbGFibGUgZm9yIGEgdGFibGUgY29sdW1uLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1toY0NvbHVtbkRlZl0nLFxuICAgIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtDb2x1bW5EZWYsIHVzZUV4aXN0aW5nOiBIY0NvbHVtbkRlZn1dXG59KVxuZXhwb3J0IGNsYXNzIEhjQ29sdW1uRGVmIGV4dGVuZHMgQ2RrQ29sdW1uRGVmIHtcbiAgICBwcml2YXRlIF9qdXN0aWZ5OiBzdHJpbmcgPSAnbGVmdCc7XG5cbiAgICAvKiogVW5pcXVlIG5hbWUgZm9yIHRoaXMgY29sdW1uLiAqL1xuICAgIEBJbnB1dCgnaGNDb2x1bW5EZWYnKVxuICAgIG5hbWU6IHN0cmluZztcblxuICAgIC8qKiBTZXRzIHRoZSB0ZXh0IGFsaWdubWVudCBmb3IgdGhpcyBjb2x1bW46IGBsZWZ0YCAoZGVmYXVsdCksIGBjZW50ZXJgIG9yIGByaWdodGAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBqdXN0aWZ5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0aWZ5O1xuICAgIH1cblxuICAgIHNldCBqdXN0aWZ5KGp1c3RpZnlWYWw6IHN0cmluZykge1xuICAgICAgICBpZiAoanVzdGlmeVZhbCA9PT0gJ2xlZnQnIHx8IGp1c3RpZnlWYWwgPT09ICdjZW50ZXInIHx8IGp1c3RpZnlWYWwgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2p1c3RpZnkgPSBqdXN0aWZ5VmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhYmxlIGNvbHVtbiBhbGlnbm1lbnQgdmFsdWU6ICcgKyBqdXN0aWZ5VmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBXaGV0aGVyIHRoaXMgY29sdW1uIHNob3VsZCBiZSBzdGlja3kgcG9zaXRpb25lZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJvdyAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RpY2t5OiBib29sZWFuO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBjb2x1bW4gc2hvdWxkIGJlIHN0aWNreSBwb3NpdGlvbmVkIG9uIHRoZSBlbmQgb2YgdGhlIHJvdyAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RpY2t5RW5kOiBib29sZWFuO1xufVxuXG4vKiogSGVhZGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaGMtaGVhZGVyLWNlbGwsIHRoW2hjLWhlYWRlci1jZWxsXScsXG4gICAgaG9zdDoge1xuICAgICAgICBjbGFzczogJ2hjLWhlYWRlci1jZWxsJyxcbiAgICAgICAgcm9sZTogJ2NvbHVtbmhlYWRlcidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhjSGVhZGVyQ2VsbCBleHRlbmRzIENka0hlYWRlckNlbGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZjogSGNDb2x1bW5EZWYsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgc3VwZXIoY29sdW1uRGVmLCBlbGVtZW50UmVmKTtcbiAgICAgICAgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoYGhjLWNvbHVtbi0ke2NvbHVtbkRlZi5jc3NDbGFzc0ZyaWVuZGx5TmFtZX1gKTtcbiAgICAgICAgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoYGhjLXRhYmxlLWp1c3RpZnktYCArIGNvbHVtbkRlZi5qdXN0aWZ5KTtcbiAgICB9XG59XG5cbi8qKiBGb290ZXIgY2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdoYy1mb290ZXItY2VsbCwgdGRbaGMtZm9vdGVyLWNlbGxdJyxcbiAgICBob3N0OiB7XG4gICAgICAgIGNsYXNzOiAnaGMtZm9vdGVyLWNlbGwnLFxuICAgICAgICByb2xlOiAnZ3JpZGNlbGwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIY0Zvb3RlckNlbGwgZXh0ZW5kcyBDZGtGb290ZXJDZWxsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5EZWY6IEhjQ29sdW1uRGVmLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBoYy1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBoYy10YWJsZS1qdXN0aWZ5LWAgKyBjb2x1bW5EZWYuanVzdGlmeSk7XG4gICAgfVxufVxuXG4vKiogQ2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdoYy1jZWxsLCB0ZFtoYy1jZWxsXScsXG4gICAgaG9zdDoge1xuICAgICAgICBjbGFzczogJ2hjLWNlbGwnLFxuICAgICAgICByb2xlOiAnZ3JpZGNlbGwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIY0NlbGwgZXh0ZW5kcyBDZGtDZWxsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5EZWY6IEhjQ29sdW1uRGVmLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBoYy1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBoYy10YWJsZS1qdXN0aWZ5LWAgKyBjb2x1bW5EZWYuanVzdGlmeSk7XG4gICAgfVxufVxuIl19