/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/progress-spinner.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ViewEncapsulation } from '@angular/core';
/** @type {?} */
var supportedColors = ['blue', 'green', 'purple', 'orange', 'red', 'gray', 'white'];
/**
 * @param {?} inputStr
 * @return {?}
 */
export function validateColorInput(inputStr) {
    if (supportedColors.indexOf(inputStr) < 0) {
        throw Error('Unsupported progress spinner color value: ' + inputStr);
    }
}
var ProgressSpinnerComponent = /** @class */ (function () {
    function ProgressSpinnerComponent() {
        this._color = 'blue';
        /**
         * If true, the spinner will center itself inside its container.
         */
        this.isCentered = true;
        /**
         * If true, include background "channel" circle.
         */
        this.hasChannel = true;
        /**
         * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
         */
        this.isDeterminate = false;
        this._rightCircleTransform = '';
        this._leftCircleTransform = '';
        this._rightCircleTransition = '';
        this._leftCircleTransition = '';
        this._progress = 0;
        this._diameter = 0;
        this._minDiameter = 20;
        this._maxDiameter = 250;
    }
    Object.defineProperty(ProgressSpinnerComponent.prototype, "color", {
        /** Color of the spinner: `blue`, `green`, `purple`, `orange`, `red`, `gray`, `white` */
        get: /**
         * Color of the spinner: `blue`, `green`, `purple`, `orange`, `red`, `gray`, `white`
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} colorVal
         * @return {?}
         */
        function (colorVal) {
            validateColorInput(colorVal);
            this._color = colorVal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressSpinnerComponent.prototype, "progress", {
        get: /**
         * @return {?}
         */
        function () {
            return this._progress;
        },
        /** (0-100%) Only used if "isDeterminate" is set to true. */
        set: /**
         * (0-100%) Only used if "isDeterminate" is set to true.
         * @param {?} progress
         * @return {?}
         */
        function (progress) {
            this.setProgress(progress);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressSpinnerComponent.prototype, "diameter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._diameter;
        },
        /** Set the diameter of the circle, in pixels. Minimum is 20, maximum is 250. */
        set: /**
         * Set the diameter of the circle, in pixels. Minimum is 20, maximum is 250.
         * @param {?} diameter
         * @return {?}
         */
        function (diameter) {
            this._diameter = Math.min(Math.max(this._minDiameter, diameter), this._maxDiameter);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    ProgressSpinnerComponent.prototype.setProgress = /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        progress = Math.min(100, progress);
        progress = Math.max(0, progress);
        this.setProgressTransition(progress);
        this.setProgressTransform(progress);
        this._progress = progress;
    };
    /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    ProgressSpinnerComponent.prototype.setProgressTransition = /**
     * @private
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        /** @type {?} */
        var sizeBasedTime = this.diameter > 150 ? 0.6 : 0.4;
        /** @type {?} */
        var timing = Math.abs(progress - this._progress) > 40 ? sizeBasedTime : sizeBasedTime / 2;
        /** @type {?} */
        var halfTime = timing / 2;
        if ((progress <= 50 && this._progress <= 50) || (progress >= 51 && this._progress >= 51)) {
            this._leftCircleTransition = "transform " + timing + "s ease-in-out 0s";
            this._rightCircleTransition = "transform " + timing + "s ease-in-out 0s";
        }
        else if (progress <= 50 && this._progress >= 51) {
            this._leftCircleTransition = "transform " + halfTime + "s ease-in 0s";
            this._rightCircleTransition = "transform " + halfTime + "s ease-out " + (halfTime - 0.001) + "s";
        }
        else if (progress >= 51 && this._progress <= 50) {
            this._leftCircleTransition = "transform " + halfTime + "s ease-out " + (halfTime - 0.001) + "s";
            this._rightCircleTransition = "transform " + halfTime + "s ease-in 0s";
        }
    };
    /**
     * Using a somewhat complicated set of transforms to achive the animation.
     * For 0% to 50% the right circle element rotates from -135deg to 45deg
     * For 51% to 100% the left circle element rotates from 135deg to 315deg
     */
    /**
     * Using a somewhat complicated set of transforms to achive the animation.
     * For 0% to 50% the right circle element rotates from -135deg to 45deg
     * For 51% to 100% the left circle element rotates from 135deg to 315deg
     * @private
     * @param {?} progress
     * @return {?}
     */
    ProgressSpinnerComponent.prototype.setProgressTransform = /**
     * Using a somewhat complicated set of transforms to achive the animation.
     * For 0% to 50% the right circle element rotates from -135deg to 45deg
     * For 51% to 100% the left circle element rotates from 135deg to 315deg
     * @private
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        if (progress <= 50) {
            /** @type {?} */
            var rightDegrees = (progress / 50) * 180 - 135;
            this._rightCircleTransform = "rotate(" + rightDegrees + "deg)";
            this._leftCircleTransform = "rotate(135deg)";
        }
        else if (progress >= 51) {
            /** @type {?} */
            var leftDegrees = ((progress - 50) / 50) * 180 + 135;
            this._leftCircleTransform = "rotate(" + leftDegrees + "deg)";
            this._rightCircleTransform = 'rotate(45deg)';
        }
    };
    ProgressSpinnerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'hc-progress-spinner',
                    template: "<div class=\"hc-spinner-container\" [ngClass]=\"{'center-spinner': isCentered }\">\n    <div class=\"hc-spinner\" \n        [ngClass]=\"{'indeterminate-spin': !isDeterminate, 'large-spinner': diameter >= 150 }\"\n        [style.width.px]=\"diameter\"\n        [style.height.px]=\"diameter\"\n        [style.marginTop.px]=\"isCentered ? diameter / -2 : 0\"\n        [style.marginLeft.px]=\"isCentered ? diameter / -2 : 0\">\n        <div class=\"spinner-layer spinner-{{color}}\" [ngClass]=\"{'spinner-base': hasChannel }\">\n            <div class=\"circle base-circle\"></div>\n            <div class=\"circle-clipper left\"><div class=\"circle\" [style.transform]=\"_leftCircleTransform\" [style.transition]=\"_leftCircleTransition\"></div>\n            </div><div class=\"gap-patch\"><div class=\"circle\"></div>\n            </div><div class=\"circle-clipper right\"><div class=\"circle\" [style.transform]=\"_rightCircleTransform\" [style.transition]=\"_rightCircleTransition\"></div></div>\n        </div>\n    </div>\n</div>",
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    ProgressSpinnerComponent.propDecorators = {
        color: [{ type: Input }],
        isCentered: [{ type: Input }],
        hasChannel: [{ type: Input }],
        isDeterminate: [{ type: Input }],
        progress: [{ type: Input }],
        diameter: [{ type: Input }]
    };
    return ProgressSpinnerComponent;
}());
export { ProgressSpinnerComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._color;
    /**
     * If true, the spinner will center itself inside its container.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.isCentered;
    /**
     * If true, include background "channel" circle.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.hasChannel;
    /**
     * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
     * @type {?}
     */
    ProgressSpinnerComponent.prototype.isDeterminate;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._rightCircleTransform;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._leftCircleTransform;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._rightCircleTransition;
    /** @type {?} */
    ProgressSpinnerComponent.prototype._leftCircleTransition;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._progress;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._diameter;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._minDiameter;
    /**
     * @type {?}
     * @private
     */
    ProgressSpinnerComponent.prototype._maxDiameter;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvcHJvZ3Jlc3MtaW5kaWNhdG9ycy9wcm9ncmVzcy1zcGlubmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFDLE1BQU0sZUFBZSxDQUFDOztJQUU1RCxlQUFlLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUM7Ozs7O0FBRXJGLE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxRQUFnQjtJQUMvQyxJQUFJLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3ZDLE1BQU0sS0FBSyxDQUFDLDRDQUE0QyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0tBQ3hFO0FBQ0wsQ0FBQztBQUVEO0lBQUE7UUFNWSxXQUFNLEdBQUcsTUFBTSxDQUFDOzs7O1FBZWpCLGVBQVUsR0FBRyxJQUFJLENBQUM7Ozs7UUFJbEIsZUFBVSxHQUFHLElBQUksQ0FBQzs7OztRQUlsQixrQkFBYSxHQUFHLEtBQUssQ0FBQztRQW9CdEIsMEJBQXFCLEdBQUcsRUFBRSxDQUFDO1FBQzNCLHlCQUFvQixHQUFHLEVBQUUsQ0FBQztRQUMxQiwyQkFBc0IsR0FBRyxFQUFFLENBQUM7UUFDNUIsMEJBQXFCLEdBQUcsRUFBRSxDQUFDO1FBQzFCLGNBQVMsR0FBRyxDQUFDLENBQUM7UUFDZCxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsaUJBQVksR0FBRyxFQUFFLENBQUM7UUFDbEIsaUJBQVksR0FBRyxHQUFHLENBQUM7SUE0Qy9CLENBQUM7SUEzRkcsc0JBQ0ksMkNBQUs7UUFGVCx3RkFBd0Y7Ozs7O1FBQ3hGO1lB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UUFDekMsSUFBSSxRQUFRLElBQUksRUFBRSxFQUFFOztnQkFDVixZQUFZLEdBQUcsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7WUFDaEQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLFlBQVUsWUFBWSxTQUFNLENBQUM7WUFDMUQsSUFBSSxDQUFDLG9CQUFvQixHQUFHLGdCQUFnQixDQUFDO1NBQ2hEO2FBQU0sSUFBSSxRQUFRLElBQUksRUFBRSxFQUFFOztnQkFDakIsV0FBVyxHQUFHLENBQUMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7WUFDdEQsSUFBSSxDQUFDLG9CQUFvQixHQUFHLFlBQVUsV0FBVyxTQUFNLENBQUM7WUFDeEQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLGVBQWUsQ0FBQztTQUNoRDtJQUNMLENBQUM7O2dCQW5HSixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLHFCQUFxQjtvQkFDL0IsbWhDQUE4QztvQkFDOUMsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7aUJBQ3hDOzs7d0JBS0ksS0FBSzs2QkFXTCxLQUFLOzZCQUlMLEtBQUs7Z0NBSUwsS0FBSzsyQkFJTCxLQUFLOzJCQVNMLEtBQUs7O0lBMkRWLCtCQUFDO0NBQUEsQUFwR0QsSUFvR0M7U0EvRlksd0JBQXdCOzs7Ozs7SUFDakMsMENBQXdCOzs7OztJQWN4Qiw4Q0FDeUI7Ozs7O0lBR3pCLDhDQUN5Qjs7Ozs7SUFHekIsaURBQzZCOztJQW9CN0IseURBQWtDOztJQUNsQyx3REFBaUM7O0lBQ2pDLDBEQUFtQzs7SUFDbkMseURBQWtDOzs7OztJQUNsQyw2Q0FBc0I7Ozs7O0lBQ3RCLDZDQUFzQjs7Ozs7SUFDdEIsZ0RBQTBCOzs7OztJQUMxQixnREFBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuY29uc3Qgc3VwcG9ydGVkQ29sb3JzID0gWydibHVlJywgJ2dyZWVuJywgJ3B1cnBsZScsICdvcmFuZ2UnLCAncmVkJywgJ2dyYXknLCAnd2hpdGUnXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29sb3JJbnB1dChpbnB1dFN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHN1cHBvcnRlZENvbG9ycy5pbmRleE9mKGlucHV0U3RyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb2dyZXNzIHNwaW5uZXIgY29sb3IgdmFsdWU6ICcgKyBpbnB1dFN0cik7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hjLXByb2dyZXNzLXNwaW5uZXInLFxuICAgIHRlbXBsYXRlVXJsOiAncHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1NwaW5uZXJDb21wb25lbnQge1xuICAgIHByaXZhdGUgX2NvbG9yID0gJ2JsdWUnO1xuXG4gICAgLyoqIENvbG9yIG9mIHRoZSBzcGlubmVyOiBgYmx1ZWAsIGBncmVlbmAsIGBwdXJwbGVgLCBgb3JhbmdlYCwgYHJlZGAsIGBncmF5YCwgYHdoaXRlYCAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGNvbG9yKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3IoY29sb3JWYWw6IHN0cmluZykge1xuICAgICAgICB2YWxpZGF0ZUNvbG9ySW5wdXQoY29sb3JWYWwpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IGNvbG9yVmFsO1xuICAgIH1cblxuICAgIC8qKiBJZiB0cnVlLCB0aGUgc3Bpbm5lciB3aWxsIGNlbnRlciBpdHNlbGYgaW5zaWRlIGl0cyBjb250YWluZXIuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaXNDZW50ZXJlZCA9IHRydWU7XG5cbiAgICAvKiogSWYgdHJ1ZSwgaW5jbHVkZSBiYWNrZ3JvdW5kIFwiY2hhbm5lbFwiIGNpcmNsZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoYXNDaGFubmVsID0gdHJ1ZTtcblxuICAgIC8qKiBJZiB0cnVlLCBzd2l0Y2hlcyB0byBkZXRlcm1pbmF0ZSBtb2RlLiBNdXN0IHBhc3MgaW4gcHJvZ3Jlc3MgKDAtMTAwJSksIGluc3RlYWQgb2YgaGF2aW5nIHRoZSBsb2FkZXIgc3BpbiBmcmVlbHkuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaXNEZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqICgwLTEwMCUpIE9ubHkgdXNlZCBpZiBcImlzRGV0ZXJtaW5hdGVcIiBpcyBzZXQgdG8gdHJ1ZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3M6IG51bWJlcikge1xuICAgICAgICB0aGlzLnNldFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICB9XG4gICAgcHVibGljIGdldCBwcm9ncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGRpYW1ldGVyIG9mIHRoZSBjaXJjbGUsIGluIHBpeGVscy4gTWluaW11bSBpcyAyMCwgbWF4aW11bSBpcyAyNTAuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGRpYW1ldGVyKGRpYW1ldGVyOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLl9taW5EaWFtZXRlciwgZGlhbWV0ZXIpLCB0aGlzLl9tYXhEaWFtZXRlcik7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgZGlhbWV0ZXIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpYW1ldGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBfcmlnaHRDaXJjbGVUcmFuc2Zvcm0gPSAnJztcbiAgICBwdWJsaWMgX2xlZnRDaXJjbGVUcmFuc2Zvcm0gPSAnJztcbiAgICBwdWJsaWMgX3JpZ2h0Q2lyY2xlVHJhbnNpdGlvbiA9ICcnO1xuICAgIHB1YmxpYyBfbGVmdENpcmNsZVRyYW5zaXRpb24gPSAnJztcbiAgICBwcml2YXRlIF9wcm9ncmVzcyA9IDA7XG4gICAgcHJpdmF0ZSBfZGlhbWV0ZXIgPSAwO1xuICAgIHByaXZhdGUgX21pbkRpYW1ldGVyID0gMjA7XG4gICAgcHJpdmF0ZSBfbWF4RGlhbWV0ZXIgPSAyNTA7XG5cbiAgICBwcml2YXRlIHNldFByb2dyZXNzKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1pbigxMDAsIHByb2dyZXNzKTtcbiAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heCgwLCBwcm9ncmVzcyk7XG5cbiAgICAgICAgdGhpcy5zZXRQcm9ncmVzc1RyYW5zaXRpb24ocHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnNldFByb2dyZXNzVHJhbnNmb3JtKHByb2dyZXNzKTtcblxuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0UHJvZ3Jlc3NUcmFuc2l0aW9uKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUJhc2VkVGltZSA9IHRoaXMuZGlhbWV0ZXIgPiAxNTAgPyAwLjYgOiAwLjQ7XG4gICAgICAgIGNvbnN0IHRpbWluZyA9IE1hdGguYWJzKHByb2dyZXNzIC0gdGhpcy5fcHJvZ3Jlc3MpID4gNDAgPyBzaXplQmFzZWRUaW1lIDogc2l6ZUJhc2VkVGltZSAvIDI7XG4gICAgICAgIGNvbnN0IGhhbGZUaW1lID0gdGltaW5nIC8gMjtcbiAgICAgICAgaWYgKChwcm9ncmVzcyA8PSA1MCAmJiB0aGlzLl9wcm9ncmVzcyA8PSA1MCkgfHwgKHByb2dyZXNzID49IDUxICYmIHRoaXMuX3Byb2dyZXNzID49IDUxKSkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7dGltaW5nfXMgZWFzZS1pbi1vdXQgMHNgO1xuICAgICAgICAgICAgdGhpcy5fcmlnaHRDaXJjbGVUcmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke3RpbWluZ31zIGVhc2UtaW4tb3V0IDBzYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA8PSA1MCAmJiB0aGlzLl9wcm9ncmVzcyA+PSA1MSkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLWluIDBzYDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0Q2lyY2xlVHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtoYWxmVGltZX1zIGVhc2Utb3V0ICR7aGFsZlRpbWUgLSAwLjAwMX1zYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+PSA1MSAmJiB0aGlzLl9wcm9ncmVzcyA8PSA1MCkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLW91dCAke2hhbGZUaW1lIC0gMC4wMDF9c2A7XG4gICAgICAgICAgICB0aGlzLl9yaWdodENpcmNsZVRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7aGFsZlRpbWV9cyBlYXNlLWluIDBzYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgc29tZXdoYXQgY29tcGxpY2F0ZWQgc2V0IG9mIHRyYW5zZm9ybXMgdG8gYWNoaXZlIHRoZSBhbmltYXRpb24uXG4gICAgICogRm9yIDAlIHRvIDUwJSB0aGUgcmlnaHQgY2lyY2xlIGVsZW1lbnQgcm90YXRlcyBmcm9tIC0xMzVkZWcgdG8gNDVkZWdcbiAgICAgKiBGb3IgNTElIHRvIDEwMCUgdGhlIGxlZnQgY2lyY2xlIGVsZW1lbnQgcm90YXRlcyBmcm9tIDEzNWRlZyB0byAzMTVkZWdcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFByb2dyZXNzVHJhbnNmb3JtKHByb2dyZXNzOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzIDw9IDUwKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodERlZ3JlZXMgPSAocHJvZ3Jlc3MgLyA1MCkgKiAxODAgLSAxMzU7XG4gICAgICAgICAgICB0aGlzLl9yaWdodENpcmNsZVRyYW5zZm9ybSA9IGByb3RhdGUoJHtyaWdodERlZ3JlZXN9ZGVnKWA7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0Q2lyY2xlVHJhbnNmb3JtID0gYHJvdGF0ZSgxMzVkZWcpYDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+PSA1MSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdERlZ3JlZXMgPSAoKHByb2dyZXNzIC0gNTApIC8gNTApICogMTgwICsgMTM1O1xuICAgICAgICAgICAgdGhpcy5fbGVmdENpcmNsZVRyYW5zZm9ybSA9IGByb3RhdGUoJHtsZWZ0RGVncmVlc31kZWcpYDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0Q2lyY2xlVHJhbnNmb3JtID0gJ3JvdGF0ZSg0NWRlZyknO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19