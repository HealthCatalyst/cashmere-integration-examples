/**
 * @fileoverview added by tsickle
 * Generated from: lib/sort/sort.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/* tslint:disable:no-output-rename no-input-rename directive-class-suffix */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, EventEmitter, Input, isDevMode, Output } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { getSortDuplicateSortableIdError, getSortHeaderMissingIdError, getSortInvalidDirectionError } from './sort-errors';
import { Subject } from 'rxjs';
import { Initializable } from '../shared/initializable';
/**
 * Interface for a directive that holds sorting state consumed by `HcSortHeaderComponent`.
 * @record
 */
export function HcSortable() { }
if (false) {
    /**
     * The id of the column being sorted.
     * @type {?}
     */
    HcSortable.prototype.id;
    /**
     * Starting sort direction.
     * @type {?}
     */
    HcSortable.prototype.start;
    /**
     * Whether to disable clearing the sorting state.
     * @type {?}
     */
    HcSortable.prototype.disableClear;
}
/**
 * The current sort state.
 * @record
 */
export function Sort() { }
if (false) {
    /**
     * The id of the column being sorted.
     * @type {?}
     */
    Sort.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    Sort.prototype.direction;
}
/**
 * Container for HcSortables to manage the sort state and provide default sort parameters.
 */
var HcSort = /** @class */ (function (_super) {
    tslib_1.__extends(HcSort, _super);
    function HcSort() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Collection of all registered sortables that this directive manages.
         */
        _this.sortables = new Map();
        /**
         * Used to notify any child components listening to state changes.
         */
        _this._stateChanges = new Subject();
        /**
         * The direction to set when an HcSortable is initially sorted.
         * May be overriden by the HcSortable's sort start.
         */
        _this.start = 'asc';
        _this._direction = '';
        _this._disabled = false;
        /**
         * Event emitted when the user changes either the active sort or sort direction.
         */
        _this.sortChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(HcSort.prototype, "direction", {
        /** The sort direction of the currently active HcSortable. */
        get: /**
         * The sort direction of the currently active HcSortable.
         * @return {?}
         */
        function () {
            return this._direction;
        },
        set: /**
         * @param {?} direction
         * @return {?}
         */
        function (direction) {
            if (isDevMode() && direction && direction !== 'asc' && direction !== 'desc') {
                throw getSortInvalidDirectionError(direction);
            }
            this._direction = direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcSort.prototype, "disableClear", {
        /**
         * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
         * May be overriden by the HcSortable's disable clear input.
         */
        get: /**
         * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
         * May be overriden by the HcSortable's disable clear input.
         * @return {?}
         */
        function () {
            return this._disableClear;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._disableClear = coerceBooleanProperty(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcSort.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register function to be used by the contained HcSortables. Adds the HcSortable to the
     * collection of HcSortables.
     */
    /**
     * Register function to be used by the contained HcSortables. Adds the HcSortable to the
     * collection of HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    HcSort.prototype.register = /**
     * Register function to be used by the contained HcSortables. Adds the HcSortable to the
     * collection of HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (!sortable.id) {
            throw getSortHeaderMissingIdError();
        }
        if (this.sortables.has(sortable.id)) {
            throw getSortDuplicateSortableIdError(sortable.id);
        }
        this.sortables.set(sortable.id, sortable);
    };
    /**
     * Unregister function to be used by the contained HcSortables. Removes the HcSortable from the
     * collection of contained HcSortables.
     */
    /**
     * Unregister function to be used by the contained HcSortables. Removes the HcSortable from the
     * collection of contained HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    HcSort.prototype.deregister = /**
     * Unregister function to be used by the contained HcSortables. Removes the HcSortable from the
     * collection of contained HcSortables.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        this.sortables.delete(sortable.id);
    };
    /** Sets the active sort id and determines the new sort direction. */
    /**
     * Sets the active sort id and determines the new sort direction.
     * @param {?} sortable
     * @return {?}
     */
    HcSort.prototype.sort = /**
     * Sets the active sort id and determines the new sort direction.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (this.active !== sortable.id) {
            this.active = sortable.id;
            this.direction = sortable.start ? sortable.start : this.start;
        }
        else {
            this.direction = this.getNextSortDirection(sortable);
        }
        this.sortChange.emit({ active: this.active, direction: this.direction });
    };
    /** Returns the next sort direction of the active sortable, checking for potential overrides. */
    /**
     * Returns the next sort direction of the active sortable, checking for potential overrides.
     * @param {?} sortable
     * @return {?}
     */
    HcSort.prototype.getNextSortDirection = /**
     * Returns the next sort direction of the active sortable, checking for potential overrides.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (!sortable) {
            return '';
        }
        // Get the sort direction cycle with the potential sortable overrides.
        /** @type {?} */
        var disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
        /** @type {?} */
        var sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
        // Get and return the next direction in the cycle
        /** @type {?} */
        var nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    };
    /**
     * @return {?}
     */
    HcSort.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._markInitialized();
    };
    /**
     * @return {?}
     */
    HcSort.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this._stateChanges.next();
    };
    /**
     * @return {?}
     */
    HcSort.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    HcSort.decorators = [
        { type: Directive, args: [{
                    selector: '[hcSort]',
                    exportAs: 'hcSort'
                },] }
    ];
    HcSort.propDecorators = {
        active: [{ type: Input, args: ['hcSortActive',] }],
        start: [{ type: Input, args: ['hcSortStart',] }],
        direction: [{ type: Input, args: ['hcSortDirection',] }],
        disableClear: [{ type: Input, args: ['hcSortDisableClear',] }],
        disabled: [{ type: Input, args: ['hcSortDisabled',] }],
        sortChange: [{ type: Output, args: ['hcSortChange',] }]
    };
    return HcSort;
}(Initializable));
export { HcSort };
if (false) {
    /**
     * Collection of all registered sortables that this directive manages.
     * @type {?}
     */
    HcSort.prototype.sortables;
    /**
     * Used to notify any child components listening to state changes.
     * @type {?}
     */
    HcSort.prototype._stateChanges;
    /**
     * The id of the most recently sorted HcSortable.
     * @type {?}
     */
    HcSort.prototype.active;
    /**
     * The direction to set when an HcSortable is initially sorted.
     * May be overriden by the HcSortable's sort start.
     * @type {?}
     */
    HcSort.prototype.start;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._direction;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._disableClear;
    /**
     * @type {?}
     * @private
     */
    HcSort.prototype._disabled;
    /**
     * Event emitted when the user changes either the active sort or sort direction.
     * @type {?}
     */
    HcSort.prototype.sortChange;
}
/**
 * Returns the sort direction cycle to use given the provided parameters of order and clear.
 * @param {?} start
 * @param {?} disableClear
 * @return {?}
 */
function getSortDirectionCycle(start, disableClear) {
    /** @type {?} */
    var sortOrder = ['asc', 'desc'];
    if (start === 'desc') {
        sortOrder.reverse();
    }
    if (!disableClear) {
        sortOrder.push('');
    }
    return sortOrder;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi9zb3J0L3NvcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFVQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFnQyxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDOUcsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFNUQsT0FBTyxFQUFDLCtCQUErQixFQUFFLDJCQUEyQixFQUFFLDRCQUE0QixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pILE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLHlCQUF5QixDQUFDOzs7OztBQUd0RCxnQ0FTQzs7Ozs7O0lBUEcsd0JBQVc7Ozs7O0lBR1gsMkJBQXNCOzs7OztJQUd0QixrQ0FBc0I7Ozs7OztBQUkxQiwwQkFNQzs7Ozs7O0lBSkcsc0JBQWU7Ozs7O0lBR2YseUJBQXlCOzs7OztBQUk3QjtJQUk0QixrQ0FBYTtJQUp6QztRQUFBLHFFQTZIQzs7OztRQXZIRyxlQUFTLEdBQUcsSUFBSSxHQUFHLEVBQXNCLENBQUM7Ozs7UUFHakMsbUJBQWEsR0FBRyxJQUFJLE9BQU8sRUFBUyxDQUFDOzs7OztRQVc5QyxXQUFLLEdBQW1CLEtBQUssQ0FBQztRQWF0QixnQkFBVSxHQUFrQixFQUFFLENBQUM7UUFzQi9CLGVBQVMsR0FBWSxLQUFLLENBQUM7Ozs7UUFJMUIsZ0JBQVUsR0FBdUIsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7SUFrRXZFLENBQUM7SUF0R0csc0JBQ0ksNkJBQVM7UUFGYiw2REFBNkQ7Ozs7O1FBQzdEO1lBRUksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzNCLENBQUM7Ozs7O1FBQ0QsVUFBYyxTQUF3QjtZQUNs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LENBQUM7S0FDdEI7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGU6bm8tb3V0cHV0LXJlbmFtZSBuby1pbnB1dC1yZW5hbWUgZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeCAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSW5wdXQsIGlzRGV2TW9kZSwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtTb3J0RGlyZWN0aW9ufSBmcm9tICcuL3NvcnQtZGlyZWN0aW9uJztcbmltcG9ydCB7Z2V0U29ydER1cGxpY2F0ZVNvcnRhYmxlSWRFcnJvciwgZ2V0U29ydEhlYWRlck1pc3NpbmdJZEVycm9yLCBnZXRTb3J0SW52YWxpZERpcmVjdGlvbkVycm9yfSBmcm9tICcuL3NvcnQtZXJyb3JzJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0luaXRpYWxpemFibGV9IGZyb20gJy4uL3NoYXJlZC9pbml0aWFsaXphYmxlJztcblxuLyoqIEludGVyZmFjZSBmb3IgYSBkaXJlY3RpdmUgdGhhdCBob2xkcyBzb3J0aW5nIHN0YXRlIGNvbnN1bWVkIGJ5IGBIY1NvcnRIZWFkZXJDb21wb25lbnRgLiAqL1xuZXhwb3J0IGludGVyZmFjZSBIY1NvcnRhYmxlIHtcbiAgICAvKiogVGhlIGlkIG9mIHRoZSBjb2x1bW4gYmVpbmcgc29ydGVkLiAqL1xuICAgIGlkOiBzdHJpbmc7XG5cbiAgICAvKiogU3RhcnRpbmcgc29ydCBkaXJlY3Rpb24uICovXG4gICAgc3RhcnQ6ICdhc2MnIHwgJ2Rlc2MnO1xuXG4gICAgLyoqIFdoZXRoZXIgdG8gZGlzYWJsZSBjbGVhcmluZyB0aGUgc29ydGluZyBzdGF0ZS4gKi9cbiAgICBkaXNhYmxlQ2xlYXI6IGJvb2xlYW47XG59XG5cbi8qKiBUaGUgY3VycmVudCBzb3J0IHN0YXRlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTb3J0IHtcbiAgICAvKiogVGhlIGlkIG9mIHRoZSBjb2x1bW4gYmVpbmcgc29ydGVkLiAqL1xuICAgIGFjdGl2ZTogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBzb3J0IGRpcmVjdGlvbi4gKi9cbiAgICBkaXJlY3Rpb246IFNvcnREaXJlY3Rpb247XG59XG5cbi8qKiBDb250YWluZXIgZm9yIEhjU29ydGFibGVzIHRvIG1hbmFnZSB0aGUgc29ydCBzdGF0ZSBhbmQgcHJvdmlkZSBkZWZhdWx0IHNvcnQgcGFyYW1ldGVycy4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2hjU29ydF0nLFxuICAgIGV4cG9ydEFzOiAnaGNTb3J0J1xufSlcbmV4cG9ydCBjbGFzcyBIY1NvcnQgZXh0ZW5kcyBJbml0aWFsaXphYmxlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gICAgLyoqIENvbGxlY3Rpb24gb2YgYWxsIHJlZ2lzdGVyZWQgc29ydGFibGVzIHRoYXQgdGhpcyBkaXJlY3RpdmUgbWFuYWdlcy4gKi9cbiAgICBzb3J0YWJsZXMgPSBuZXcgTWFwPHN0cmluZywgSGNTb3J0YWJsZT4oKTtcblxuICAgIC8qKiBVc2VkIHRvIG5vdGlmeSBhbnkgY2hpbGQgY29tcG9uZW50cyBsaXN0ZW5pbmcgdG8gc3RhdGUgY2hhbmdlcy4gKi9cbiAgICByZWFkb25seSBfc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8bmV2ZXI+KCk7XG5cbiAgICAvKiogVGhlIGlkIG9mIHRoZSBtb3N0IHJlY2VudGx5IHNvcnRlZCBIY1NvcnRhYmxlLiAqL1xuICAgIEBJbnB1dCgnaGNTb3J0QWN0aXZlJylcbiAgICBhY3RpdmU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXJlY3Rpb24gdG8gc2V0IHdoZW4gYW4gSGNTb3J0YWJsZSBpcyBpbml0aWFsbHkgc29ydGVkLlxuICAgICAqIE1heSBiZSBvdmVycmlkZW4gYnkgdGhlIEhjU29ydGFibGUncyBzb3J0IHN0YXJ0LlxuICAgICAqL1xuICAgIEBJbnB1dCgnaGNTb3J0U3RhcnQnKVxuICAgIHN0YXJ0OiAnYXNjJyB8ICdkZXNjJyA9ICdhc2MnO1xuXG4gICAgLyoqIFRoZSBzb3J0IGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBIY1NvcnRhYmxlLiAqL1xuICAgIEBJbnB1dCgnaGNTb3J0RGlyZWN0aW9uJylcbiAgICBnZXQgZGlyZWN0aW9uKCk6IFNvcnREaXJlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbjogU29ydERpcmVjdGlvbikge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgZGlyZWN0aW9uICYmIGRpcmVjdGlvbiAhPT0gJ2FzYycgJiYgZGlyZWN0aW9uICE9PSAnZGVzYycpIHtcbiAgICAgICAgICAgIHRocm93IGdldFNvcnRJbnZhbGlkRGlyZWN0aW9uRXJyb3IoZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgfVxuICAgIHByaXZhdGUgX2RpcmVjdGlvbjogU29ydERpcmVjdGlvbiA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkaXNhYmxlIHRoZSB1c2VyIGZyb20gY2xlYXJpbmcgdGhlIHNvcnQgYnkgZmluaXNoaW5nIHRoZSBzb3J0IGRpcmVjdGlvbiBjeWNsZS5cbiAgICAgKiBNYXkgYmUgb3ZlcnJpZGVuIGJ5IHRoZSBIY1NvcnRhYmxlJ3MgZGlzYWJsZSBjbGVhciBpbnB1dC5cbiAgICAgKi9cbiAgICBASW5wdXQoJ2hjU29ydERpc2FibGVDbGVhcicpXG4gICAgZ2V0IGRpc2FibGVDbGVhcigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVDbGVhcjtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVDbGVhcih2OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVDbGVhciA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfZGlzYWJsZUNsZWFyOiBib29sZWFuO1xuXG4gICAgQElucHV0KCdoY1NvcnREaXNhYmxlZCcpXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyBlaXRoZXIgdGhlIGFjdGl2ZSBzb3J0IG9yIHNvcnQgZGlyZWN0aW9uLiAqL1xuICAgIEBPdXRwdXQoJ2hjU29ydENoYW5nZScpXG4gICAgcmVhZG9ubHkgc29ydENoYW5nZTogRXZlbnRFbWl0dGVyPFNvcnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxTb3J0PigpO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBieSB0aGUgY29udGFpbmVkIEhjU29ydGFibGVzLiBBZGRzIHRoZSBIY1NvcnRhYmxlIHRvIHRoZVxuICAgICAqIGNvbGxlY3Rpb24gb2YgSGNTb3J0YWJsZXMuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoc29ydGFibGU6IEhjU29ydGFibGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZS5pZCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0U29ydEhlYWRlck1pc3NpbmdJZEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZXMuaGFzKHNvcnRhYmxlLmlkKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0U29ydER1cGxpY2F0ZVNvcnRhYmxlSWRFcnJvcihzb3J0YWJsZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0YWJsZXMuc2V0KHNvcnRhYmxlLmlkLCBzb3J0YWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBmdW5jdGlvbiB0byBiZSB1c2VkIGJ5IHRoZSBjb250YWluZWQgSGNTb3J0YWJsZXMuIFJlbW92ZXMgdGhlIEhjU29ydGFibGUgZnJvbSB0aGVcbiAgICAgKiBjb2xsZWN0aW9uIG9mIGNvbnRhaW5lZCBIY1NvcnRhYmxlcy5cbiAgICAgKi9cbiAgICBkZXJlZ2lzdGVyKHNvcnRhYmxlOiBIY1NvcnRhYmxlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc29ydGFibGVzLmRlbGV0ZShzb3J0YWJsZS5pZCk7XG4gICAgfVxuXG4gICAgLyoqIFNldHMgdGhlIGFjdGl2ZSBzb3J0IGlkIGFuZCBkZXRlcm1pbmVzIHRoZSBuZXcgc29ydCBkaXJlY3Rpb24uICovXG4gICAgc29ydChzb3J0YWJsZTogSGNTb3J0YWJsZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgIT09IHNvcnRhYmxlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHNvcnRhYmxlLmlkO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBzb3J0YWJsZS5zdGFydCA/IHNvcnRhYmxlLnN0YXJ0IDogdGhpcy5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5nZXROZXh0U29ydERpcmVjdGlvbihzb3J0YWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvcnRDaGFuZ2UuZW1pdCh7YWN0aXZlOiB0aGlzLmFjdGl2ZSwgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbn0pO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBuZXh0IHNvcnQgZGlyZWN0aW9uIG9mIHRoZSBhY3RpdmUgc29ydGFibGUsIGNoZWNraW5nIGZvciBwb3RlbnRpYWwgb3ZlcnJpZGVzLiAqL1xuICAgIGdldE5leHRTb3J0RGlyZWN0aW9uKHNvcnRhYmxlOiBIY1NvcnRhYmxlKTogU29ydERpcmVjdGlvbiB7XG4gICAgICAgIGlmICghc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgc29ydCBkaXJlY3Rpb24gY3ljbGUgd2l0aCB0aGUgcG90ZW50aWFsIHNvcnRhYmxlIG92ZXJyaWRlcy5cbiAgICAgICAgY29uc3QgZGlzYWJsZUNsZWFyID0gc29ydGFibGUuZGlzYWJsZUNsZWFyICE9IG51bGwgPyBzb3J0YWJsZS5kaXNhYmxlQ2xlYXIgOiB0aGlzLmRpc2FibGVDbGVhcjtcbiAgICAgICAgbGV0IHNvcnREaXJlY3Rpb25DeWNsZSA9IGdldFNvcnREaXJlY3Rpb25DeWNsZShzb3J0YWJsZS5zdGFydCB8fCB0aGlzLnN0YXJ0LCBkaXNhYmxlQ2xlYXIpO1xuXG4gICAgICAgIC8vIEdldCBhbmQgcmV0dXJuIHRoZSBuZXh0IGRpcmVjdGlvbiBpbiB0aGUgY3ljbGVcbiAgICAgICAgbGV0IG5leHREaXJlY3Rpb25JbmRleCA9IHNvcnREaXJlY3Rpb25DeWNsZS5pbmRleE9mKHRoaXMuZGlyZWN0aW9uKSArIDE7XG4gICAgICAgIGlmIChuZXh0RGlyZWN0aW9uSW5kZXggPj0gc29ydERpcmVjdGlvbkN5Y2xlLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydERpcmVjdGlvbkN5Y2xlW25leHREaXJlY3Rpb25JbmRleF07XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX21hcmtJbml0aWFsaXplZCgpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMuY29tcGxldGUoKTtcbiAgICB9XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBzb3J0IGRpcmVjdGlvbiBjeWNsZSB0byB1c2UgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMgb2Ygb3JkZXIgYW5kIGNsZWFyLiAqL1xuZnVuY3Rpb24gZ2V0U29ydERpcmVjdGlvbkN5Y2xlKHN0YXJ0OiAnYXNjJyB8ICdkZXNjJywgZGlzYWJsZUNsZWFyOiBib29sZWFuKTogU29ydERpcmVjdGlvbltdIHtcbiAgICBsZXQgc29ydE9yZGVyOiBTb3J0RGlyZWN0aW9uW10gPSBbJ2FzYycsICdkZXNjJ107XG4gICAgaWYgKHN0YXJ0ID09PSAnZGVzYycpIHtcbiAgICAgICAgc29ydE9yZGVyLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaWYgKCFkaXNhYmxlQ2xlYXIpIHtcbiAgICAgICAgc29ydE9yZGVyLnB1c2goJycpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0T3JkZXI7XG59XG4iXX0=