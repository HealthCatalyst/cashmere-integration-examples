/**
 * @fileoverview added by tsickle
 * Generated from: lib/input/input.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef, HostBinding, HostListener, Input, Optional, Self, forwardRef } from '@angular/core';
import { parseBooleanAttribute } from '../util';
import { HcFormControlComponent } from '../form-field/hc-form-control.component';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
/**
 * @param {?} type
 * @return {?}
 */
export function getUnsupportedHCInputType(type) {
    return new Error("hc-input doesn't support the following type: " + type);
}
/** @type {?} */
var uniqueId = 1;
/** @type {?} */
var unsupportedTypes = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'reset'];
/**
 * Directive that allows a native input to work inside a HcFormFieldComponent
 */
var InputDirective = /** @class */ (function (_super) {
    tslib_1.__extends(InputDirective, _super);
    function InputDirective(_elementRef, _parentForm, _parentFormGroup, _ngControl) {
        var _this = _super.call(this) || this;
        _this._elementRef = _elementRef;
        _this._ngControl = _ngControl;
        _this._focused = false;
        _this._uniqueInputId = "hc-input-" + uniqueId++;
        _this._componentId = _this._uniqueInputId;
        _this._type = 'input';
        _this._readonly = false;
        _this._hostHcInputClass = true;
        _this._form = _parentForm || _parentFormGroup;
        return _this;
    }
    Object.defineProperty(InputDirective.prototype, "type", {
        /** Input type of the element. */
        get: /**
         * Input type of the element.
         * @return {?}
         */
        function () {
            return this._type;
        },
        set: /**
         * @param {?} type
         * @return {?}
         */
        function (type) {
            if (unsupportedTypes.indexOf(type) > -1) {
                throw getUnsupportedHCInputType(type);
            }
            this._type = type;
            // textArea doesn't have type property
            if (!this._isTextArea()) {
                this._elementRef.nativeElement.type = this.type;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "id", {
        /** Element id. */
        get: /**
         * Element id.
         * @return {?}
         */
        function () {
            return this._componentId || this._uniqueInputId;
        },
        set: /**
         * @param {?} idVal
         * @return {?}
         */
        function (idVal) {
            this._componentId = idVal ? idVal : this._uniqueInputId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "readonly", {
        /** Sets input element as readonly. */
        get: /**
         * Sets input element as readonly.
         * @return {?}
         */
        function () {
            return this._readonly;
        },
        set: /**
         * @param {?} isReadOnly
         * @return {?}
         */
        function (isReadOnly) {
            this._readonly = parseBooleanAttribute(isReadOnly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "disabled", {
        /** Disables the input element. */
        get: /**
         * Disables the input element.
         * @return {?}
         */
        function () {
            if (this._ngControl && this._ngControl.disabled) {
                return this._ngControl.disabled;
            }
            return this._isDisabled;
        },
        set: /**
         * @param {?} disabledInput
         * @return {?}
         */
        function (disabledInput) {
            this._isDisabled = parseBooleanAttribute(disabledInput);
            if (this._focused) {
                this._focused = false;
                // TODO: trigger state change
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "required", {
        /** Sets required attribute. */
        get: /**
         * Sets required attribute.
         * @return {?}
         */
        function () {
            return this._isRequired;
        },
        set: /**
         * @param {?} requiredInput
         * @return {?}
         */
        function (requiredInput) {
            this._isRequired = parseBooleanAttribute(requiredInput);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "_hostId", {
        get: /**
         * @return {?}
         */
        function () {
            return this._componentId || this._uniqueInputId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "_hostReadOnly", {
        get: /**
         * @return {?}
         */
        function () {
            return this.readonly;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "_hostDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputDirective.prototype, "_hostRequired", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isRequired;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InputDirective.prototype._onBlur = /**
     * @return {?}
     */
    function () {
        this._changeFocus(false);
    };
    /**
     * @return {?}
     */
    InputDirective.prototype._onFocus = /**
     * @return {?}
     */
    function () {
        this._changeFocus(true);
    };
    Object.defineProperty(InputDirective.prototype, "value", {
        /** Sets value of the input element */
        get: /**
         * Sets value of the input element
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this.value) {
                this._elementRef.nativeElement.value = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InputDirective.prototype._inputEvent = /**
     * @return {?}
     */
    function () {
        // causes angular to run change detection on input event
    };
    /**
     * @return {?}
     */
    InputDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        // This needs to be checked every cycle because we can't subscribe to form submissions
        if (this._ngControl) {
            this._updateErrorState();
        }
    };
    /** Sets the focus on the input element */
    /**
     * Sets the focus on the input element
     * @return {?}
     */
    InputDirective.prototype.focus = /**
     * Sets the focus on the input element
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @private
     * @param {?} focused
     * @return {?}
     */
    InputDirective.prototype._changeFocus = /**
     * @private
     * @param {?} focused
     * @return {?}
     */
    function (focused) {
        if (this._focused !== focused && !this.readonly) {
            this._focused = focused;
            // TODO: trigger state change
        }
    };
    /**
     * @private
     * @return {?}
     */
    InputDirective.prototype._isTextArea = /**
     * @private
     * @return {?}
     */
    function () {
        return this._elementRef.nativeElement.nodeName.toLowerCase() !== 'textarea';
    };
    /**
     * @private
     * @return {?}
     */
    InputDirective.prototype._updateErrorState = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this._errorState;
        // TODO: this could be abstracted out as an @Input() if we need this to be configurable
        /** @type {?} */
        var newState = !!(this._ngControl &&
            this._ngControl.invalid &&
            (this._ngControl.touched || (this._form && this._form.submitted)));
        if (oldState !== newState) {
            this._errorState = newState;
        }
    };
    InputDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[hcInput]',
                    providers: [{ provide: HcFormControlComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return InputDirective; })) }]
                },] }
    ];
    /** @nocollapse */
    InputDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
    ]; };
    InputDirective.propDecorators = {
        type: [{ type: Input }],
        id: [{ type: Input }],
        readonly: [{ type: Input }],
        disabled: [{ type: Input }],
        required: [{ type: Input }],
        _hostHcInputClass: [{ type: HostBinding, args: ['class.hc-input',] }],
        _hostId: [{ type: HostBinding, args: ['attr.id',] }],
        _hostReadOnly: [{ type: HostBinding, args: ['readonly',] }],
        _hostDisabled: [{ type: HostBinding, args: ['disabled',] }],
        _hostRequired: [{ type: HostBinding, args: ['required',] }],
        _onBlur: [{ type: HostListener, args: ['blur',] }],
        _onFocus: [{ type: HostListener, args: ['focus',] }],
        value: [{ type: Input }],
        _inputEvent: [{ type: HostListener, args: ['input',] }]
    };
    return InputDirective;
}(HcFormControlComponent));
export { InputDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._focused;
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._uniqueInputId;
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._form;
    /** @type {?} */
    InputDirective.prototype._componentId;
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._type;
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._readonly;
    /** @type {?} */
    InputDirective.prototype._hostHcInputClass;
    /**
     * @type {?}
     * @private
     */
    InputDirective.prototype._elementRef;
    /** @type {?} */
    InputDirective.prototype._ngControl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGhlYWx0aGNhdGFseXN0L2Nhc2htZXJlLyIsInNvdXJjZXMiOlsibGliL2lucHV0L2lucHV0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFXLFVBQVUsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMzSCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUMsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0seUNBQXlDLENBQUM7QUFDL0UsT0FBTyxFQUFDLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFFckUsTUFBTSxVQUFVLHlCQUF5QixDQUFDLElBQVk7SUFDbEQsT0FBTyxJQUFJLEtBQUssQ0FBQyxrREFBZ0QsSUFBTSxDQUFDLENBQUM7QUFDN0UsQ0FBQzs7SUFFRyxRQUFRLEdBQUcsQ0FBQzs7SUFFVixnQkFBZ0IsR0FBRyxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQzs7OztBQUc1RjtJQUlvQywwQ0FBc0I7SUErSHRELHdCQUNZLFdBQXVCLEVBQ25CLFdBQW1CLEVBQ25CLGdCQUFvQyxFQUd6QyxVQUFxQjtRQU5oQyxZQVFJLGlCQUFPLFNBR1Y7UUFWVyxpQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUt4QixnQkFBVSxHQUFWLFVBQVUsQ0FBVztRQXBJeEIsY0FBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixvQkFBYyxHQUFHLGNBQVksUUFBUSxFQUFJLENBQUM7UUFHbEQsa0JBQVksR0FBRyxLQUFJLENBQUMsY0FBYyxDQUFDO1FBb0IzQixXQUFLLEdB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Ozs7SUFDbEQsK0JBQWtEOztJQUVsRCxzQ0FBbUM7Ozs7O0lBb0JuQywrQkFBd0I7Ozs7O0lBc0J4QixtQ0FBMEI7O0lBOEIxQiwyQ0FDeUI7Ozs7O0lBa0RyQixxQ0FBK0I7O0lBRy9CLG9DQUU0QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGlyZWN0aXZlLCBEb0NoZWNrLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3B0aW9uYWwsIFNlbGYsIGZvcndhcmRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtwYXJzZUJvb2xlYW5BdHRyaWJ1dGV9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHtIY0Zvcm1Db250cm9sQ29tcG9uZW50fSBmcm9tICcuLi9mb3JtLWZpZWxkL2hjLWZvcm0tY29udHJvbC5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtR3JvdXBEaXJlY3RpdmUsIE5nQ29udHJvbCwgTmdGb3JtfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbnN1cHBvcnRlZEhDSW5wdXRUeXBlKHR5cGU6IHN0cmluZyk6IEVycm9yIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBoYy1pbnB1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZvbGxvd2luZyB0eXBlOiAke3R5cGV9YCk7XG59XG5cbmxldCB1bmlxdWVJZCA9IDE7XG5cbmNvbnN0IHVuc3VwcG9ydGVkVHlwZXMgPSBbJ2J1dHRvbicsICdjaGVja2JveCcsICdmaWxlJywgJ2hpZGRlbicsICdpbWFnZScsICdyYWRpbycsICdyZXNldCddO1xuXG4vKiogRGlyZWN0aXZlIHRoYXQgYWxsb3dzIGEgbmF0aXZlIGlucHV0IHRvIHdvcmsgaW5zaWRlIGEgSGNGb3JtRmllbGRDb21wb25lbnQgKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2hjSW5wdXRdJyxcbiAgICBwcm92aWRlcnM6IFt7cHJvdmlkZTogSGNGb3JtQ29udHJvbENvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSW5wdXREaXJlY3RpdmUpfV1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXREaXJlY3RpdmUgZXh0ZW5kcyBIY0Zvcm1Db250cm9sQ29tcG9uZW50IGltcGxlbWVudHMgRG9DaGVjayB7XG4gICAgcHJpdmF0ZSBfZm9jdXNlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3VuaXF1ZUlucHV0SWQgPSBgaGMtaW5wdXQtJHt1bmlxdWVJZCsrfWA7XG4gICAgcHJpdmF0ZSBfZm9ybTogTmdGb3JtIHwgRm9ybUdyb3VwRGlyZWN0aXZlIHwgbnVsbDtcblxuICAgIF9jb21wb25lbnRJZCA9IHRoaXMuX3VuaXF1ZUlucHV0SWQ7XG5cbiAgICAvKiogSW5wdXQgdHlwZSBvZiB0aGUgZWxlbWVudC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cblxuICAgIHNldCB0eXBlKHR5cGU6IHN0cmluZykge1xuICAgICAgICBpZiAodW5zdXBwb3J0ZWRUeXBlcy5pbmRleE9mKHR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGdldFVuc3VwcG9ydGVkSENJbnB1dFR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgICAgICAgLy8gdGV4dEFyZWEgZG9lc24ndCBoYXZlIHR5cGUgcHJvcGVydHlcbiAgICAgICAgaWYgKCF0aGlzLl9pc1RleHRBcmVhKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHlwZSA9ICdpbnB1dCc7XG5cbiAgICAvKiogRWxlbWVudCBpZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50SWQgfHwgdGhpcy5fdW5pcXVlSW5wdXRJZDtcbiAgICB9XG5cbiAgICBzZXQgaWQoaWRWYWw6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRJZCA9IGlkVmFsID8gaWRWYWwgOiB0aGlzLl91bmlxdWVJbnB1dElkO1xuICAgIH1cblxuICAgIC8qKiBTZXRzIGlucHV0IGVsZW1lbnQgYXMgcmVhZG9ubHkuICovXG4gICAgQElucHV0KClcbiAgICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkb25seTtcbiAgICB9XG5cbiAgICBzZXQgcmVhZG9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLl9yZWFkb25seSA9IHBhcnNlQm9vbGVhbkF0dHJpYnV0ZShpc1JlYWRPbmx5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWFkb25seSA9IGZhbHNlO1xuXG4gICAgLyoqIERpc2FibGVzIHRoZSBpbnB1dCBlbGVtZW50LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5fbmdDb250cm9sICYmIHRoaXMuX25nQ29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nQ29udHJvbC5kaXNhYmxlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNhYmxlZDtcbiAgICB9XG5cbiAgICBzZXQgZGlzYWJsZWQoZGlzYWJsZWRJbnB1dCkge1xuICAgICAgICB0aGlzLl9pc0Rpc2FibGVkID0gcGFyc2VCb29sZWFuQXR0cmlidXRlKGRpc2FibGVkSW5wdXQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9mb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiB0cmlnZ2VyIHN0YXRlIGNoYW5nZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNldHMgcmVxdWlyZWQgYXR0cmlidXRlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHJlcXVpcmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSZXF1aXJlZDtcbiAgICB9XG5cbiAgICBzZXQgcmVxdWlyZWQocmVxdWlyZWRJbnB1dCkge1xuICAgICAgICB0aGlzLl9pc1JlcXVpcmVkID0gcGFyc2VCb29sZWFuQXR0cmlidXRlKHJlcXVpcmVkSW5wdXQpO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaGMtaW5wdXQnKVxuICAgIF9ob3N0SGNJbnB1dENsYXNzID0gdHJ1ZTtcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgZ2V0IF9ob3N0SWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudElkIHx8IHRoaXMuX3VuaXF1ZUlucHV0SWQ7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdyZWFkb25seScpXG4gICAgZ2V0IF9ob3N0UmVhZE9ubHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRvbmx5O1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnZGlzYWJsZWQnKVxuICAgIGdldCBfaG9zdERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ3JlcXVpcmVkJylcbiAgICBnZXQgX2hvc3RSZXF1aXJlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gICAgX29uQmx1cigpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRm9jdXMoZmFsc2UpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBfb25Gb2N1cygpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRm9jdXModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqIFNldHMgdmFsdWUgb2YgdGhlIGlucHV0IGVsZW1lbnQgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gICAgX2lucHV0RXZlbnQoKSB7XG4gICAgICAgIC8vIGNhdXNlcyBhbmd1bGFyIHRvIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uIG9uIGlucHV0IGV2ZW50XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIF9wYXJlbnRGb3JtOiBOZ0Zvcm0sXG4gICAgICAgIEBPcHRpb25hbCgpIF9wYXJlbnRGb3JtR3JvdXA6IEZvcm1Hcm91cERpcmVjdGl2ZSxcbiAgICAgICAgQE9wdGlvbmFsKClcbiAgICAgICAgQFNlbGYoKVxuICAgICAgICBwdWJsaWMgX25nQ29udHJvbDogTmdDb250cm9sXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fZm9ybSA9IF9wYXJlbnRGb3JtIHx8IF9wYXJlbnRGb3JtR3JvdXA7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNoZWNrZWQgZXZlcnkgY3ljbGUgYmVjYXVzZSB3ZSBjYW4ndCBzdWJzY3JpYmUgdG8gZm9ybSBzdWJtaXNzaW9uc1xuICAgICAgICBpZiAodGhpcy5fbmdDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFcnJvclN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2V0cyB0aGUgZm9jdXMgb24gdGhlIGlucHV0IGVsZW1lbnQgKi9cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2hhbmdlRm9jdXMoZm9jdXNlZDogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fZm9jdXNlZCAhPT0gZm9jdXNlZCAmJiAhdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZvY3VzZWQ7XG4gICAgICAgICAgICAvLyBUT0RPOiB0cmlnZ2VyIHN0YXRlIGNoYW5nZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXNUZXh0QXJlYSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGV4dGFyZWEnO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3VwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5fZXJyb3JTdGF0ZTtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIGFic3RyYWN0ZWQgb3V0IGFzIGFuIEBJbnB1dCgpIGlmIHdlIG5lZWQgdGhpcyB0byBiZSBjb25maWd1cmFibGVcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSAhIShcbiAgICAgICAgICAgIHRoaXMuX25nQ29udHJvbCAmJlxuICAgICAgICAgICAgdGhpcy5fbmdDb250cm9sLmludmFsaWQgJiZcbiAgICAgICAgICAgICh0aGlzLl9uZ0NvbnRyb2wudG91Y2hlZCB8fCAodGhpcy5fZm9ybSAmJiB0aGlzLl9mb3JtLnN1Ym1pdHRlZCkpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9sZFN0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19