/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/date-range/date-range.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Output, EventEmitter, Input, ElementRef, Directive, HostListener } from '@angular/core';
import { DatePipe } from '@angular/common';
import { CalendarOverlayService } from '../services/calendar-overlay.service';
import { ConfigStoreService } from '../services/config-store.service';
var DateRangeDirective = /** @class */ (function () {
    function DateRangeDirective(_elementRef, calendarOverlayService, configStoreService) {
        var _this = this;
        this._elementRef = _elementRef;
        this.calendarOverlayService = calendarOverlayService;
        this.configStoreService = configStoreService;
        /**
         * Emits when date range is been changed.
         */
        this.selectedDateRangeChanged = new EventEmitter();
        /**
         * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
         */
        this.selectedPresetChanged = new EventEmitter();
        configStoreService.rangeUpdate$.subscribe((/**
         * @param {?} daterange
         * @return {?}
         */
        function (daterange) {
            _this.selectedDateRangeChanged.emit(daterange);
        }));
        configStoreService.presetUpdate$.subscribe((/**
         * @param {?} preset
         * @return {?}
         */
        function (preset) {
            _this.selectedPresetChanged.emit(preset);
        }));
    }
    /**
     * @return {?}
     */
    DateRangeDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    DateRangeDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    DateRangeDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['options']) {
            /** @type {?} */
            var options = changes['options'].currentValue;
            this.configStoreService.updateDateRangeOptions(options);
        }
        if (changes['selectedDate']) {
            /** @type {?} */
            var selectedDate = changes['selectedDate'].currentValue;
            if (typeof selectedDate === 'number') {
                this.configStoreService.updatePreset(selectedDate);
            }
            else {
                this.configStoreService.updateRange(selectedDate);
            }
        }
    };
    /**
     * @return {?}
     */
    DateRangeDirective.prototype._onClick = /**
     * @return {?}
     */
    function () {
        this._overlayRef = this.calendarOverlayService.open(this._elementRef);
    };
    DateRangeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[hcDateRange]',
                    providers: [CalendarOverlayService, ConfigStoreService, DatePipe]
                },] }
    ];
    /** @nocollapse */
    DateRangeDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: CalendarOverlayService },
        { type: ConfigStoreService }
    ]; };
    DateRangeDirective.propDecorators = {
        selectedDateRangeChanged: [{ type: Output }],
        selectedDate: [{ type: Input }],
        selectedPresetChanged: [{ type: Output }],
        options: [{ type: Input }],
        _onClick: [{ type: HostListener, args: ['click',] }]
    };
    return DateRangeDirective;
}());
export { DateRangeDirective };
if (false) {
    /**
     * Emits when date range is been changed.
     * @type {?}
     */
    DateRangeDirective.prototype.selectedDateRangeChanged;
    /**
     * Sets the selected date range. Accepts either a `DateRange` or a numerical index for preset.
     * @type {?}
     */
    DateRangeDirective.prototype.selectedDate;
    /**
     * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
     * @type {?}
     */
    DateRangeDirective.prototype.selectedPresetChanged;
    /**
     * Configuration to setup behavior of component.
     * @type {?}
     */
    DateRangeDirective.prototype.options;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DateRangeDirective.prototype.calendarOverlayService;
    /** @type {?} */
    DateRangeDirective.prototype.configStoreService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvZGF0ZS1yYW5nZS9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFTLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFhLFVBQVUsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUEyQixNQUFNLGVBQWUsQ0FBQztBQUM1SSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekMsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sc0NBQXNDLENBQUM7QUFFNUUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFFcEU7SUF1QkksNEJBQ1ksV0FBeUMsRUFDekMsc0JBQThDLEVBQy9DLGtCQUFzQztRQUhqRCxpQkFXQztRQVZXLGdCQUFXLEdBQVgsV0FBVyxDQUE4QjtRQUN6QywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBQy9DLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7Ozs7UUFuQnhDLDZCQUF3QixHQUE0QixJQUFJLFlBQVksRUFBYSxDQUFDOzs7O1FBUWxGLDBCQUFxQixHQUFxQyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQWF0RyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsU0FBUzs7OztRQUFDLFVBQUMsU0FBb0I7WUFDM0QsS0FBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNsRCxDQUFDLEVBQUMsQ0FBQztRQUNILGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxTQUFTOzs7O1FBQUMsVUFBQyxNQUEwQjtZQUNsRSxLQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQzs7OztJQUVELHFDQUFROzs7SUFBUixjQUFZLENBQUM7Ozs7SUFFYix3Q0FBVzs7O0lBQVg7UUFDSSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUM3QjtJQUNMLENBQUM7Ozs7O0lBRUQsd0NBQVc7Ozs7SUFBWCxVQUFZLE9BQXNCO1FBQzlCLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFOztnQkFDZCxPQUFPLEdBQXFCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFZO1lBQ2pFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMzRDtRQUNELElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFOztnQkFDbkIsWUFBWSxHQUF1QixPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsWUFBWTtZQUU3RSxJQUFLLE9BQU8sWUFBWSxLQUFLLFFBQVEsRUFBRztnQkFDcEMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ3JEO1NBQ0o7SUFDTCxDQUFDOzs7O0lBR0QscUNBQVE7OztJQURSO1FBRUksSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxRSxDQUFDOztnQkEvREosU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxlQUFlO29CQUN6QixTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxrQkFBa0IsRUFBRSxRQUFRLENBQUM7aUJBQ3BFOzs7O2dCQVZ1RCxVQUFVO2dCQUcxRCxzQkFBc0I7Z0JBRXRCLGtCQUFrQjs7OzJDQVFyQixNQUFNOytCQUlOLEtBQUs7d0NBSUwsTUFBTTswQkFJTixLQUFLOzJCQTBDTCxZQUFZLFNBQUMsT0FBTzs7SUFJekIseUJBQUM7Q0FBQSxBQWhFRCxJQWdFQztTQTVEWSxrQkFBa0I7Ozs7OztJQUUzQixzREFDMkY7Ozs7O0lBRzNGLDBDQUNpQzs7Ozs7SUFHakMsbURBQzBHOzs7OztJQUcxRyxxQ0FDMEI7Ozs7O0lBRTFCLHlDQUFnQzs7Ozs7SUFHNUIseUNBQWlEOzs7OztJQUNqRCxvREFBc0Q7O0lBQ3RELGdEQUE2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T25Jbml0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgRWxlbWVudFJlZiwgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGVQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtPdmVybGF5UmVmfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge0NhbGVuZGFyT3ZlcmxheVNlcnZpY2V9IGZyb20gJy4uL3NlcnZpY2VzL2NhbGVuZGFyLW92ZXJsYXkuc2VydmljZSc7XG5pbXBvcnQge0RhdGVSYW5nZSwgRGF0ZVJhbmdlT3B0aW9uc30gZnJvbSAnLi4vbW9kZWwvbW9kZWwnO1xuaW1wb3J0IHtDb25maWdTdG9yZVNlcnZpY2V9IGZyb20gJy4uL3NlcnZpY2VzL2NvbmZpZy1zdG9yZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaGNEYXRlUmFuZ2VdJyxcbiAgICBwcm92aWRlcnM6IFtDYWxlbmRhck92ZXJsYXlTZXJ2aWNlLCBDb25maWdTdG9yZVNlcnZpY2UsIERhdGVQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgICAvKiogRW1pdHMgd2hlbiBkYXRlIHJhbmdlIGlzIGJlZW4gY2hhbmdlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBzZWxlY3RlZERhdGVSYW5nZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxEYXRlUmFuZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlUmFuZ2U+KCk7XG5cbiAgICAvKiogU2V0cyB0aGUgc2VsZWN0ZWQgZGF0ZSByYW5nZS4gQWNjZXB0cyBlaXRoZXIgYSBgRGF0ZVJhbmdlYCBvciBhIG51bWVyaWNhbCBpbmRleCBmb3IgcHJlc2V0LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWREYXRlOiBudW1iZXIgfCBEYXRlUmFuZ2U7XG5cbiAgICAvKiogRW1pdHMgZWl0aGVyIGEgbnVtZXJpY2FsIGluZGV4IGZvciB0aGUgc2VsZWN0ZWQgcHJlc2V0LCBvciBhIGBEYXRlUmFuZ2VgIGlmIHRoZSBzZWxlY3RlZCB2YWx1ZSBpcyBub3QgYSBwcmVzZXQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBzZWxlY3RlZFByZXNldENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxudW1iZXIgfCBEYXRlUmFuZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXIgfCBEYXRlUmFuZ2U+KCk7XG5cbiAgICAvKiogQ29uZmlndXJhdGlvbiB0byBzZXR1cCBiZWhhdmlvciBvZiBjb21wb25lbnQuICovXG4gICAgQElucHV0KClcbiAgICBvcHRpb25zOiBEYXRlUmFuZ2VPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgICAgICBwcml2YXRlIGNhbGVuZGFyT3ZlcmxheVNlcnZpY2U6IENhbGVuZGFyT3ZlcmxheVNlcnZpY2UsXG4gICAgICAgIHB1YmxpYyBjb25maWdTdG9yZVNlcnZpY2U6IENvbmZpZ1N0b3JlU2VydmljZVxuICAgICkge1xuICAgICAgICBjb25maWdTdG9yZVNlcnZpY2UucmFuZ2VVcGRhdGUkLnN1YnNjcmliZSgoZGF0ZXJhbmdlOiBEYXRlUmFuZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlUmFuZ2VDaGFuZ2VkLmVtaXQoZGF0ZXJhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ1N0b3JlU2VydmljZS5wcmVzZXRVcGRhdGUkLnN1YnNjcmliZSgocHJlc2V0OiBudW1iZXIgfCBEYXRlUmFuZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRQcmVzZXRDaGFuZ2VkLmVtaXQocHJlc2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7fVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBpZiAoY2hhbmdlc1snb3B0aW9ucyddKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBEYXRlUmFuZ2VPcHRpb25zID0gY2hhbmdlc1snb3B0aW9ucyddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU3RvcmVTZXJ2aWNlLnVwZGF0ZURhdGVSYW5nZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3NlbGVjdGVkRGF0ZSddKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZERhdGU6IG51bWJlciB8IERhdGVSYW5nZSA9IGNoYW5nZXNbJ3NlbGVjdGVkRGF0ZSddLmN1cnJlbnRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0ZWREYXRlID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1N0b3JlU2VydmljZS51cGRhdGVQcmVzZXQoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTdG9yZVNlcnZpY2UudXBkYXRlUmFuZ2Uoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBfb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuY2FsZW5kYXJPdmVybGF5U2VydmljZS5vcGVuKHRoaXMuX2VsZW1lbnRSZWYpO1xuICAgIH1cbn1cbiJdfQ==