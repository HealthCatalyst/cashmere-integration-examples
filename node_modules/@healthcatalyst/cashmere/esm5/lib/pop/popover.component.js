/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, ContentChildren, QueryList } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { transformPopover } from './popover.animations';
import { NotificationAction, PopoverNotification } from './notification.service';
import { getUnanchoredPopoverError, getInvalidHorizontalAlignError, getInvalidVerticalAlignError, getInvalidScrollStrategyError } from './popover.errors';
import { VALID_SCROLL, VALID_HORIZ_ALIGN, VALID_VERT_ALIGN } from './types';
import { MenuItemDirective } from './directives/menu-item.directive';
import { Subject } from 'rxjs';
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
var DEFAULT_TRANSITION = '100ms linear';
/** @type {?} */
var EMPTY_TRANSITION = '0ms linear';
var HcPopComponent = /** @class */ (function () {
    function HcPopComponent(_elementRef, _focusTrapFactory, _document) {
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        /**
         * Whether or not to disable default popover container styles. *Defaults to `false`.*
         */
        this.disableStyle = false;
        /**
         * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
         */
        this.showArrow = true;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'below';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = false;
        this._autoFocusOverride = false;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = true;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Should the popover animate? *Defaults to `true`.*
         */
        this.shouldAnimate = true;
        /**
         * Optional backdrop class. *Defaults to `''`.*
         */
        this.backdropClass = '';
        /**
         * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
         */
        this.autoCloseOnContentClick = false;
        /**
         * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Stores the click coordinates for mouse-based positioning
         */
        this._offsetPos = [0, 0];
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        this._yAlignClass = '';
        this._xAlignClass = '';
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
        /**
         * If this menu has children, keep track of whether any of them are open
         */
        this._subMenuOpen = false;
        /**
         * Reference to subscription of parent popover close events
         */
        this._parentClose = new Subject();
        /**
         * Block this popover from closing its parent on close
         */
        this._parentCloseBlock = false;
    }
    Object.defineProperty(HcPopComponent.prototype, "horizontalAlign", {
        /** Alignment of the popover on the horizontal axis. Can be `before`, `start`, `center`, `end`, `after`, or `mouse`.
         * *Defaults to `center`.* */
        get: /**
         * Alignment of the popover on the horizontal axis. Can be `before`, `start`, `center`, `end`, `after`, or `mouse`.
         * *Defaults to `center`.*
         * @return {?}
         */
        function () {
            return this._horizontalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateHorizontalAlign(val);
            if (this._horizontalAlign !== val) {
                this._horizontalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "xAlign", {
        /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. *Defaults to `"center"`.* */
        get: /**
         * Alignment of the popover on the x axis. Alias for `horizontalAlign`. *Defaults to `"center"`.*
         * @return {?}
         */
        function () {
            return this.horizontalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.horizontalAlign = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "verticalAlign", {
        /** Alignment of the popover on the vertical axis. Can be `above`, `start`, `center`, `end`, `below`, or `mouse`.
         * *Defaults to `"below"`.* */
        get: /**
         * Alignment of the popover on the vertical axis. Can be `above`, `start`, `center`, `end`, `below`, or `mouse`.
         * *Defaults to `"below"`.*
         * @return {?}
         */
        function () {
            return this._verticalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateVerticalAlign(val);
            if (this._verticalAlign !== val) {
                this._verticalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "yAlign", {
        /** Alignment of the popover on the y axis. Alias for `verticalAlign`. *Defaults to `"below"`.* */
        get: /**
         * Alignment of the popover on the y axis. Alias for `verticalAlign`. *Defaults to `"below"`.*
         * @return {?}
         */
        function () {
            return this.verticalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.verticalAlign = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "forceAlignment", {
        /** Whether the popover always opens with the specified alignment. *Defaults to `false`.* */
        get: /**
         * Whether the popover always opens with the specified alignment. *Defaults to `false`.*
         * @return {?}
         */
        function () {
            return this._forceAlignment;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._forceAlignment !== coercedVal) {
                this._forceAlignment = coercedVal;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "lockAlignment", {
        /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         * *Defaults to `false`.*
         */
        get: /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         * *Defaults to `false`.*
         * @return {?}
         */
        function () {
            return this._lockAlignment;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._lockAlignment !== coercedVal) {
                this._lockAlignment = coerceBooleanProperty(val);
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "autoFocus", {
        /** Whether the first focusable element should be focused on open. *Defaults to `false`.* */
        get: /**
         * Whether the first focusable element should be focused on open. *Defaults to `false`.*
         * @return {?}
         */
        function () {
            return this._autoFocus && this._autoFocusOverride;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._autoFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "restoreFocus", {
        /** Whether the popover should return focus to the previously focused element after closing. *Defaults to `true`.* */
        get: /**
         * Whether the popover should return focus to the previously focused element after closing. *Defaults to `true`.*
         * @return {?}
         */
        function () {
            return this._restoreFocus && this._restoreFocusOverride;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._restoreFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "scrollStrategy", {
        /** How the popover should handle scrolling. *Defaults to `"reposition"`.* */
        get: /**
         * How the popover should handle scrolling. *Defaults to `"reposition"`.*
         * @return {?}
         */
        function () {
            return this._scrollStrategy;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateScrollStrategy(val);
            if (this._scrollStrategy !== val) {
                this._scrollStrategy = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "hasBackdrop", {
        /** Whether the popover should have a backdrop (includes closing on click). *Defaults to `true`.* */
        get: /**
         * Whether the popover should have a backdrop (includes closing on click). *Defaults to `true`.*
         * @return {?}
         */
        function () {
            return this._hasBackdrop;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._hasBackdrop = coerceBooleanProperty(val);
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "interactiveClose", {
        /** Whether the popover should close when the user clicks the backdrop or presses ESC. *Defaults to `true`.* */
        get: /**
         * Whether the popover should close when the user clicks the backdrop or presses ESC. *Defaults to `true`.*
         * @return {?}
         */
        function () {
            return this._interactiveClose;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._interactiveClose = coerceBooleanProperty(val);
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "openTransition", {
        /** Custom transition to use while opening. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.* */
        get: /**
         * Custom transition to use while opening. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
         * @return {?}
         */
        function () {
            return this._openTransition;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._openTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "closeTransition", {
        /** Custom transition to use while closing. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.* */
        get: /**
         * Custom transition to use while closing. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
         * @return {?}
         */
        function () {
            return this._closeTransition;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._closeTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HcPopComponent.prototype, "parent", {
        /** A link to an associated parent menu that will be closed when this menu closes. */
        get: /**
         * A link to an associated parent menu that will be closed when this menu closes.
         * @return {?}
         */
        function () {
            return this._parentMenu;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            if (this._parentMenu) {
                this._parentClose.unsubscribe();
            }
            this._parentMenu = val;
            this._parentClose = this._parentMenu.closed.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (_this.isOpen()) {
                    _this.close();
                }
            }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    HcPopComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._setAlignmentClasses();
    };
    /**
     * @return {?}
     */
    HcPopComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._notifications) {
            this._notifications.dispose();
        }
        if (this._parentMenu) {
            this._parentClose.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    HcPopComponent.prototype._popContainerClicked = /**
     * @return {?}
     */
    function () {
        if (this.autoCloseOnContentClick) {
            this.close();
        }
    };
    /** Open this popover. */
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    HcPopComponent.prototype.open = /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.OPEN, options);
        this._dispatchActionNotification(notification);
    };
    /** Close this popover and its parent (if linked). */
    /**
     * Close this popover and its parent (if linked).
     * @param {?=} value
     * @return {?}
     */
    HcPopComponent.prototype.close = /**
     * Close this popover and its parent (if linked).
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
        if (this.parent && !this._parentCloseBlock) {
            this.parent.close();
        }
    };
    /** Toggle this popover open or closed. */
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    HcPopComponent.prototype.toggle = /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    function () {
        if (this.parent) {
            this.parent._subMenuOpen = !this.isOpen();
        }
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    HcPopComponent.prototype.realign = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.REALIGN);
        this._dispatchActionNotification(notification);
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    HcPopComponent.prototype.isOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._open;
    };
    /** Gets an animation config with customized (or default) transition values. */
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    HcPopComponent.prototype._getAnimation = /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    function () {
        return {
            value: 'visible',
            params: {
                openTransition: this.shouldAnimate ? this.openTransition : EMPTY_TRANSITION,
                closeTransition: this.shouldAnimate ? this.closeTransition : EMPTY_TRANSITION
            }
        };
    };
    /** Callback for when the popover is finished animating in or out. */
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    HcPopComponent.prototype._onAnimationDone = /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    };
    /** Apply alignment classes based on alignment inputs. */
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    HcPopComponent.prototype._setAlignmentClasses = /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    function (horizAlign, vertAlign) {
        if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
        if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
        this._setAlignmentClassesForAnimation(horizAlign, vertAlign);
        this._setAlignmentClassesForArrow();
    };
    /**
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    HcPopComponent.prototype._setAlignmentClassesForAnimation = /**
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    function (horizAlign, vertAlign) {
        if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
        if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
        this._classList['hc-pop-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['hc-pop-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['hc-pop-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['hc-pop-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['hc-pop-center'] = horizAlign === 'center' || vertAlign === 'center';
    };
    /**
     * @param {?=} xAlign
     * @param {?=} yAlign
     * @return {?}
     */
    HcPopComponent.prototype._setAlignmentClassesForArrow = /**
     * @param {?=} xAlign
     * @param {?=} yAlign
     * @return {?}
     */
    function (xAlign, yAlign) {
        if (xAlign === void 0) { xAlign = this.horizontalAlign; }
        if (yAlign === void 0) { yAlign = this.verticalAlign; }
        this._classList['hc-pop-show-arrow'] =
            (this.showArrow &&
                (xAlign === 'start' || xAlign === 'center' || xAlign === 'end') &&
                (yAlign === 'above' || yAlign === 'below')) ||
                ((yAlign === 'start' || yAlign === 'center' || yAlign === 'end') && (xAlign === 'before' || xAlign === 'after'));
        this._yAlignClass = this._classList['hc-pop-show-arrow'] ? "hc-pop-arrow-y-" + yAlign : '';
        this._xAlignClass = this._classList['hc-pop-show-arrow'] ? "hc-pop-arrow-x-" + xAlign : '';
    };
    /** Set the focus of an hcMenu based on a keyboard arrow press */
    /**
     * Set the focus of an hcMenu based on a keyboard arrow press
     * @param {?} downPress
     * @return {?}
     */
    HcPopComponent.prototype._keyFocus = /**
     * Set the focus of an hcMenu based on a keyboard arrow press
     * @param {?} downPress
     * @return {?}
     */
    function (downPress) {
        /** @type {?} */
        var itemArray = this._menuItems.toArray();
        if (!downPress) {
            itemArray.reverse();
        }
        /** @type {?} */
        var selected = false;
        // Determine if any item in the menu is currently focused, and select the next (or previous)
        for (var i = 0; i < itemArray.length; i++) {
            if (selected && !itemArray[i].ref.nativeElement.classList.contains('hc-divider') && !itemArray[i].ref.nativeElement.disabled) {
                itemArray[i].focus();
                return;
            }
            if (itemArray[i].ref.nativeElement === document.activeElement) {
                selected = true;
            }
        }
        // If no item is focused, selected the first (or last) item that isn't a divider or disabled
        for (var i = 0; i < itemArray.length; i++) {
            if (!itemArray[i].ref.nativeElement.classList.contains('hc-divider') && !itemArray[i].ref.nativeElement.disabled) {
                itemArray[i].focus();
                return;
            }
        }
    };
    /** Restore focus to the element focused before the popover opened. Also destroy trap. */
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    HcPopComponent.prototype._restoreFocusAndDestroyTrap = /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus && this._previouslyFocusedElement) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    };
    /** Save a reference to the element focused before the popover was opened. */
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    HcPopComponent.prototype._savePreviouslyFocusedElement = /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    function () {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    };
    /** Move the focus inside the focus trap and remember where to return later. */
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    HcPopComponent.prototype._trapFocus = /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    function () {
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus && this._focusTrap) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    };
    /** Dispatch a notification to the notification service, if possible. */
    /**
     * Dispatch a notification to the notification service, if possible.
     * @private
     * @param {?} notification
     * @return {?}
     */
    HcPopComponent.prototype._dispatchConfigNotification = /**
     * Dispatch a notification to the notification service, if possible.
     * @private
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    };
    /** Dispatch a notification to the notification service and throw if unable to. */
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @private
     * @param {?} notification
     * @return {?}
     */
    HcPopComponent.prototype._dispatchActionNotification = /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @private
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    };
    /** Throws an error if the alignment is not a valid horizontalAlign. */
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    HcPopComponent.prototype._validateHorizontalAlign = /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    };
    /** Throws an error if the alignment is not a valid verticalAlign. */
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    HcPopComponent.prototype._validateVerticalAlign = /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    };
    /** Throws an error if the scroll strategy is not a valid strategy. */
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    HcPopComponent.prototype._validateScrollStrategy = /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    };
    HcPopComponent.decorators = [
        { type: Component, args: [{
                    selector: 'hc-pop',
                    encapsulation: ViewEncapsulation.None,
                    animations: [transformPopover],
                    template: "<ng-template>\n  <div class=\"hc-pop-container\"\n      #focusTrapElement\n      class=\"{{_yAlignClass}} {{_xAlignClass}}\"\n      [class.hc-pop-container-basic]=\"!disableStyle\"\n      [ngClass]=\"_classList\"\n      (click)=\"_popContainerClicked()\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n    <div *ngIf=\"showArrow\" class=\"hc-pop-arrow {{_yAlignClass}} {{_xAlignClass}}\"></div>\n  </div>\n</ng-template>\n",
                    styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-pop-before.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .hc-pop-before.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.hc-pop-before.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .hc-pop-before.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}.hc-pop-before.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .hc-pop-before.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}.hc-pop-center.hc-pop-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.hc-pop-center.hc-pop-below{-webkit-transform-origin:center top;transform-origin:center top}.hc-pop-after.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .hc-pop-after.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.hc-pop-after.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .hc-pop-after.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}.hc-pop-after.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .hc-pop-after.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}.hc-pop-container-basic{background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;padding:12px}.hc-pop-show-arrow .hc-pop-arrow{background-color:#fff;border-style:solid;border-width:1px;display:block;height:10px;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:10px}.hc-pop-arrow-x-start .hc-pop-arrow{left:5px}.hc-pop-arrow-x-center .hc-pop-arrow{left:calc(50% - 6px)}.hc-pop-arrow-x-end .hc-pop-arrow{left:calc(100% - 15px)}.hc-pop-arrow-y-start .hc-pop-arrow{top:5px}.hc-pop-arrow-y-center .hc-pop-arrow{top:calc(50% - 6px)}.hc-pop-arrow-y-end .hc-pop-arrow{top:calc(100% - 15px)}.hc-pop-arrow-y-above .hc-pop-arrow{border-color:transparent #ccc #ccc transparent;bottom:-6px}.hc-pop-arrow-y-below .hc-pop-arrow{border-color:#ccc transparent transparent #ccc;top:-6px}.hc-pop-arrow-x-before .hc-pop-arrow{border-color:#ccc #ccc transparent transparent;right:-6px}.hc-pop-arrow-x-after .hc-pop-arrow{border-color:transparent transparent #ccc #ccc;left:-6px}.hc-pop-arrow-y-above.hc-pop-show-arrow,.hc-pop-arrow-y-below.hc-pop-show-arrow{margin:6px 0;position:relative}.hc-pop-arrow-x-after.hc-pop-show-arrow,.hc-pop-arrow-x-before.hc-pop-show-arrow{margin:0 6px;position:relative}"]
                }] }
    ];
    /** @nocollapse */
    HcPopComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FocusTrapFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    HcPopComponent.propDecorators = {
        disableStyle: [{ type: Input }],
        showArrow: [{ type: Input }],
        horizontalAlign: [{ type: Input }],
        xAlign: [{ type: Input }],
        verticalAlign: [{ type: Input }],
        yAlign: [{ type: Input }],
        forceAlignment: [{ type: Input }],
        lockAlignment: [{ type: Input }],
        autoFocus: [{ type: Input }],
        restoreFocus: [{ type: Input }],
        scrollStrategy: [{ type: Input }],
        hasBackdrop: [{ type: Input }],
        interactiveClose: [{ type: Input }],
        openTransition: [{ type: Input }],
        closeTransition: [{ type: Input }],
        parent: [{ type: Input }],
        shouldAnimate: [{ type: Input }],
        backdropClass: [{ type: Input }],
        autoCloseOnContentClick: [{ type: Input }],
        opened: [{ type: Output }],
        closed: [{ type: Output }],
        afterOpen: [{ type: Output }],
        afterClose: [{ type: Output }],
        backdropClicked: [{ type: Output }],
        overlayKeydown: [{ type: Output }],
        _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
        _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement', { static: false },] }],
        _menuItems: [{ type: ContentChildren, args: [MenuItemDirective, { descendants: true },] }]
    };
    return HcPopComponent;
}());
export { HcPopComponent };
if (false) {
    /**
     * Whether or not to disable default popover container styles. *Defaults to `false`.*
     * @type {?}
     */
    HcPopComponent.prototype.disableStyle;
    /**
     * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
     * @type {?}
     */
    HcPopComponent.prototype.showArrow;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._horizontalAlign;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._verticalAlign;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._forceAlignment;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._lockAlignment;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._autoFocus;
    /** @type {?} */
    HcPopComponent.prototype._autoFocusOverride;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._restoreFocus;
    /** @type {?} */
    HcPopComponent.prototype._restoreFocusOverride;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._hasBackdrop;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._interactiveClose;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._openTransition;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._closeTransition;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._parentMenu;
    /**
     * Should the popover animate? *Defaults to `true`.*
     * @type {?}
     */
    HcPopComponent.prototype.shouldAnimate;
    /**
     * Optional backdrop class. *Defaults to `''`.*
     * @type {?}
     */
    HcPopComponent.prototype.backdropClass;
    /**
     * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
     * @type {?}
     */
    HcPopComponent.prototype.autoCloseOnContentClick;
    /**
     * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
     * @type {?}
     */
    HcPopComponent.prototype.opened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    HcPopComponent.prototype.closed;
    /**
     * Emits when the popover has finished opening.
     * @type {?}
     */
    HcPopComponent.prototype.afterOpen;
    /**
     * Emits when the popover has finished closing.
     * @type {?}
     */
    HcPopComponent.prototype.afterClose;
    /**
     * Emits when the backdrop is clicked.
     * @type {?}
     */
    HcPopComponent.prototype.backdropClicked;
    /**
     * Emits when a keydown event is targeted to this popover's overlay.
     * @type {?}
     */
    HcPopComponent.prototype.overlayKeydown;
    /**
     * Reference to template so it can be placed within a portal.
     * @type {?}
     */
    HcPopComponent.prototype._templateRef;
    /**
     * Stores the click coordinates for mouse-based positioning
     * @type {?}
     */
    HcPopComponent.prototype._offsetPos;
    /**
     * Stores a reference to the associated overlay
     * @type {?}
     */
    HcPopComponent.prototype._componentOverlay;
    /**
     * Classes to be added to the popover for setting the correct transform origin.
     * @type {?}
     */
    HcPopComponent.prototype._classList;
    /** @type {?} */
    HcPopComponent.prototype._yAlignClass;
    /** @type {?} */
    HcPopComponent.prototype._xAlignClass;
    /**
     * Whether the popover is presently open.
     * @type {?}
     */
    HcPopComponent.prototype._open;
    /**
     * Instance of notification service. Will be undefined until attached to an anchor.
     * @type {?}
     */
    HcPopComponent.prototype._notifications;
    /**
     * Reference to the element to build a focus trap around.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrapElement;
    /**
     * Reference to the element that was focused before opening.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._previouslyFocusedElement;
    /**
     * Reference to a focus trap around the popover.
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrap;
    /**
     * If this menu has children, keep track of whether any of them are open
     * @type {?}
     */
    HcPopComponent.prototype._subMenuOpen;
    /**
     * Reference to subscription of parent popover close events
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._parentClose;
    /**
     * Block this popover from closing its parent on close
     * @type {?}
     */
    HcPopComponent.prototype._parentCloseBlock;
    /**
     * Reference to hcMenuItems (if the popover contains them)
     * @type {?}
     */
    HcPopComponent.prototype._menuItems;
    /** @type {?} */
    HcPopComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    HcPopComponent.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGVhbHRoY2F0YWx5c3QvY2FzaG1lcmUvIiwic291cmNlcyI6WyJsaWIvcG9wL3BvcG92ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBQ0wsU0FBUyxFQUNULGlCQUFpQixFQUNqQixXQUFXLEVBR1gsUUFBUSxFQUNSLE1BQU0sRUFDTixlQUFlLEVBQ2YsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQVksZ0JBQWdCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN0RCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQTZCLE1BQU0sd0JBQXdCLENBQUM7QUFDM0csT0FBTyxFQUNILHlCQUF5QixFQUN6Qiw4QkFBOEIsRUFDOUIsNEJBQTRCLEVBQzVCLDZCQUE2QixFQUNoQyxNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFJSCxZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUVuQixNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNuRSxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDOzs7SUFHdkIsa0JBQWtCLEdBQUcsY0FBYzs7SUFDbkMsZ0JBQWdCLEdBQUcsWUFBWTtBQUVyQztJQXVRSSx3QkFDVyxXQUF1QixFQUN0QixpQkFBbUMsRUFDTCxTQUFjO1FBRjdDLGdCQUFXLEdBQVgs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NEI7Ozs7O0lBRzVCLGlEQUF5Qzs7Ozs7SUFHekMsZ0NBQTJDOzs7OztJQUczQyxnQ0FBMkM7Ozs7O0lBRzNDLG1DQUErQzs7Ozs7SUFHL0Msb0NBQWdEOzs7OztJQUdoRCx5Q0FBcUQ7Ozs7O0lBR3JELHdDQUE2RDs7Ozs7SUFHN0Qsc0NBQXdFOzs7OztJQUd4RSxvQ0FBOEI7Ozs7O0lBRzlCLDJDQUE4Qjs7Ozs7SUFHOUIsb0NBQXFCOztJQUNyQixzQ0FBa0I7O0lBQ2xCLHNDQUFrQjs7Ozs7SUFHbEIsK0JBQWM7Ozs7O0lBR2Qsd0NBQTJDOzs7Ozs7SUFHM0MsMkNBQ3NDOzs7Ozs7SUFHdEMsbURBQXNEOzs7Ozs7SUFHdEQsb0NBQTBDOzs7OztJQUcxQyxzQ0FBcUM7Ozs7OztJQUdyQyxzQ0FBMEM7Ozs7O0lBRzFDLDJDQUFtQzs7Ozs7SUFHbkMsb0NBQWtHOztJQUc5RixxQ0FBOEI7Ozs7O0lBQzlCLDJDQUEyQzs7Ozs7SUFDM0MsbUNBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgUXVlcnlMaXN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBbmltYXRpb25FdmVudH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3Rvcnl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHt0cmFuc2Zvcm1Qb3BvdmVyfSBmcm9tICcuL3BvcG92ZXIuYW5pbWF0aW9ucyc7XG5pbXBvcnQge05vdGlmaWNhdGlvbkFjdGlvbiwgUG9wb3Zlck5vdGlmaWNhdGlvbiwgUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2V9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgICBnZXRVbmFuY2hvcmVkUG9wb3ZlckVycm9yLFxuICAgIGdldEludmFsaWRIb3Jpem9udGFsQWxpZ25FcnJvcixcbiAgICBnZXRJbnZhbGlkVmVydGljYWxBbGlnbkVycm9yLFxuICAgIGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yXG59IGZyb20gJy4vcG9wb3Zlci5lcnJvcnMnO1xuaW1wb3J0IHtcbiAgICBIY1BvcG92ZXJTY3JvbGxTdHJhdGVneSxcbiAgICBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgSGNQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgICBWQUxJRF9TQ1JPTEwsXG4gICAgVkFMSURfSE9SSVpfQUxJR04sXG4gICAgVkFMSURfVkVSVF9BTElHTixcbiAgICBIY1BvcG92ZXJPcGVuT3B0aW9uc1xufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7T3ZlcmxheVJlZn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHtNZW51SXRlbURpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL21lbnUtaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuLy8gU2VlIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMuMjUsLjgsLjI1LDEgZm9yIHJlZmVyZW5jZS5cbmNvbnN0IERFRkFVTFRfVFJBTlNJVElPTiA9ICcxMDBtcyBsaW5lYXInO1xuY29uc3QgRU1QVFlfVFJBTlNJVElPTiA9ICcwbXMgbGluZWFyJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdoYy1wb3AnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgYW5pbWF0aW9uczogW3RyYW5zZm9ybVBvcG92ZXJdLFxuICAgIHN0eWxlVXJsczogWycuL3BvcG92ZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcG9wb3Zlci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSGNQb3BDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRvIGRpc2FibGUgZGVmYXVsdCBwb3BvdmVyIGNvbnRhaW5lciBzdHlsZXMuICpEZWZhdWx0cyB0byBgZmFsc2VgLiogKi9cbiAgICBASW5wdXQoKSBkaXNhYmxlU3R5bGUgPSBmYWxzZTtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IGEgY29ubmVjdGlvbiBhcnJvdyB3aGVuIHBvc3NpYmxlLiAqRGVmYXVsdHMgdG8gYHRydWVgLiogKi9cbiAgICBASW5wdXQoKSBzaG93QXJyb3cgPSB0cnVlO1xuXG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgaG9yaXpvbnRhbCBheGlzLiBDYW4gYmUgYGJlZm9yZWAsIGBzdGFydGAsIGBjZW50ZXJgLCBgZW5kYCwgYGFmdGVyYCwgb3IgYG1vdXNlYC5cbiAgICAgKiAqRGVmYXVsdHMgdG8gYGNlbnRlcmAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhvcml6b250YWxBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWxBbGlnbjtcbiAgICB9XG4gICAgc2V0IGhvcml6b250YWxBbGlnbih2YWw6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUhvcml6b250YWxBbGlnbih2YWwpO1xuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbEFsaWduICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvcml6b250YWxBbGlnbiA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfaG9yaXpvbnRhbEFsaWduOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnY2VudGVyJztcblxuICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHggYXhpcy4gQWxpYXMgZm9yIGBob3Jpem9udGFsQWxpZ25gLiAqRGVmYXVsdHMgdG8gYFwiY2VudGVyXCJgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB4QWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvcml6b250YWxBbGlnbjtcbiAgICB9XG4gICAgc2V0IHhBbGlnbih2YWw6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgICAgICB0aGlzLmhvcml6b250YWxBbGlnbiA9IHZhbDtcbiAgICB9XG5cbiAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB2ZXJ0aWNhbCBheGlzLiBDYW4gYmUgYGFib3ZlYCwgYHN0YXJ0YCwgYGNlbnRlcmAsIGBlbmRgLCBgYmVsb3dgLCBvciBgbW91c2VgLlxuICAgICAqICpEZWZhdWx0cyB0byBgXCJiZWxvd1wiYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdmVydGljYWxBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsQWxpZ247XG4gICAgfVxuICAgIHNldCB2ZXJ0aWNhbEFsaWduKHZhbDogSGNQb3BvdmVyVmVydGljYWxBbGlnbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVZlcnRpY2FsQWxpZ24odmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZlcnRpY2FsQWxpZ24gIT09IHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljYWxBbGlnbiA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfdmVydGljYWxBbGlnbjogSGNQb3BvdmVyVmVydGljYWxBbGlnbiA9ICdiZWxvdyc7XG5cbiAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB5IGF4aXMuIEFsaWFzIGZvciBgdmVydGljYWxBbGlnbmAuICpEZWZhdWx0cyB0byBgXCJiZWxvd1wiYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgeUFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbEFsaWduO1xuICAgIH1cbiAgICBzZXQgeUFsaWduKHZhbDogSGNQb3BvdmVyVmVydGljYWxBbGlnbikge1xuICAgICAgICB0aGlzLnZlcnRpY2FsQWxpZ24gPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgYWx3YXlzIG9wZW5zIHdpdGggdGhlIHNwZWNpZmllZCBhbGlnbm1lbnQuICpEZWZhdWx0cyB0byBgZmFsc2VgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBmb3JjZUFsaWdubWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlQWxpZ25tZW50O1xuICAgIH1cbiAgICBzZXQgZm9yY2VBbGlnbm1lbnQodmFsOiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmNlQWxpZ25tZW50ICE9PSBjb2VyY2VkVmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZUFsaWdubWVudCA9IGNvZXJjZWRWYWw7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgX2ZvcmNlQWxpZ25tZW50ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwb3BvdmVyJ3MgYWxpZ25tZW50IGlzIGxvY2tlZCBhZnRlciBvcGVuaW5nLiBUaGlzIHByZXZlbnRzIHRoZSBwb3BvdmVyXG4gICAgICogZnJvbSBjaGFuZ2luZyBpdHMgYWxpZ25lbWVudCB3aGVuIHNjcm9sbGluZyBvciBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogKkRlZmF1bHRzIHRvIGBmYWxzZWAuKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGxvY2tBbGlnbm1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NrQWxpZ25tZW50O1xuICAgIH1cbiAgICBzZXQgbG9ja0FsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgICBpZiAodGhpcy5fbG9ja0FsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9ja0FsaWdubWVudCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9sb2NrQWxpZ25tZW50ID0gZmFsc2U7XG5cbiAgICAvKiogV2hldGhlciB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGJlIGZvY3VzZWQgb24gb3Blbi4gKkRlZmF1bHRzIHRvIGBmYWxzZWAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGF1dG9Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9Gb2N1cyAmJiB0aGlzLl9hdXRvRm9jdXNPdmVycmlkZTtcbiAgICB9XG4gICAgc2V0IGF1dG9Gb2N1cyh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYXV0b0ZvY3VzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIHByaXZhdGUgX2F1dG9Gb2N1cyA9IGZhbHNlO1xuICAgIF9hdXRvRm9jdXNPdmVycmlkZSA9IGZhbHNlO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIHJldHVybiBmb2N1cyB0byB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgYWZ0ZXIgY2xvc2luZy4gKkRlZmF1bHRzIHRvIGB0cnVlYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgcmVzdG9yZUZvY3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZUZvY3VzICYmIHRoaXMuX3Jlc3RvcmVGb2N1c092ZXJyaWRlO1xuICAgIH1cbiAgICBzZXQgcmVzdG9yZUZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9yZXN0b3JlRm9jdXMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzID0gdHJ1ZTtcbiAgICBfcmVzdG9yZUZvY3VzT3ZlcnJpZGUgPSB0cnVlO1xuXG4gICAgLyoqIEhvdyB0aGUgcG9wb3ZlciBzaG91bGQgaGFuZGxlIHNjcm9sbGluZy4gKkRlZmF1bHRzIHRvIGBcInJlcG9zaXRpb25cImAuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHNjcm9sbFN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsU3RyYXRlZ3k7XG4gICAgfVxuICAgIHNldCBzY3JvbGxTdHJhdGVneSh2YWw6IEhjUG9wb3ZlclNjcm9sbFN0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlU2Nyb2xsU3RyYXRlZ3kodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFN0cmF0ZWd5ICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneTogSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kgPSAncmVwb3NpdGlvbic7XG5cbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgaGF2ZSBhIGJhY2tkcm9wIChpbmNsdWRlcyBjbG9zaW5nIG9uIGNsaWNrKS4gKkRlZmF1bHRzIHRvIGB0cnVlYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaGFzQmFja2Ryb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNCYWNrZHJvcDtcbiAgICB9XG4gICAgc2V0IGhhc0JhY2tkcm9wKHZhbDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9oYXNCYWNrZHJvcCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uVVBEQVRFX0NPTkZJRykpO1xuICAgIH1cbiAgICBwcml2YXRlIF9oYXNCYWNrZHJvcCA9IHRydWU7XG5cbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgY2xvc2Ugd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGJhY2tkcm9wIG9yIHByZXNzZXMgRVNDLiAqRGVmYXVsdHMgdG8gYHRydWVgLiogKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBpbnRlcmFjdGl2ZUNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVDbG9zZTtcbiAgICB9XG4gICAgc2V0IGludGVyYWN0aXZlQ2xvc2UodmFsOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aXZlQ2xvc2UgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUcpKTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfaW50ZXJhY3RpdmVDbG9zZSA9IHRydWU7XG5cbiAgICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIG9wZW5pbmcuICpEZWZhdWx0cyB0byBgJzIwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJ2AuKiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IG9wZW5UcmFuc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlblRyYW5zaXRpb247XG4gICAgfVxuICAgIHNldCBvcGVuVHJhbnNpdGlvbih2YWw6IHN0cmluZykge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNpdGlvbiA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9vcGVuVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAgIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgY2xvc2luZy4gKkRlZmF1bHRzIHRvIGAnMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSknYC4qICovXG4gICAgQElucHV0KClcbiAgICBnZXQgY2xvc2VUcmFuc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VUcmFuc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgY2xvc2VUcmFuc2l0aW9uKHZhbDogc3RyaW5nKSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNpdGlvbiA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9jbG9zZVRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG5cbiAgICAvKiogQSBsaW5rIHRvIGFuIGFzc29jaWF0ZWQgcGFyZW50IG1lbnUgdGhhdCB3aWxsIGJlIGNsb3NlZCB3aGVuIHRoaXMgbWVudSBjbG9zZXMuICovXG4gICAgQElucHV0KClcbiAgICBnZXQgcGFyZW50KCk6IEhjUG9wQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudE1lbnU7XG4gICAgfVxuICAgIHNldCBwYXJlbnQodmFsOiBIY1BvcENvbXBvbmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50TWVudSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Q2xvc2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJlbnRNZW51ID0gdmFsO1xuICAgICAgICB0aGlzLl9wYXJlbnRDbG9zZSA9IHRoaXMuX3BhcmVudE1lbnUuY2xvc2VkLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByaXZhdGUgX3BhcmVudE1lbnU6IEhjUG9wQ29tcG9uZW50O1xuXG4gICAgLyoqIFNob3VsZCB0aGUgcG9wb3ZlciBhbmltYXRlPyAqRGVmYXVsdHMgdG8gYHRydWVgLiogKi9cbiAgICBASW5wdXQoKSBzaG91bGRBbmltYXRlID0gdHJ1ZTtcblxuICAgIC8qKiBPcHRpb25hbCBiYWNrZHJvcCBjbGFzcy4gKkRlZmF1bHRzIHRvIGAnJ2AuKiAqL1xuICAgIEBJbnB1dCgpIGJhY2tkcm9wQ2xhc3MgPSAnJztcblxuICAgIC8qKiBTZXQgdG8gdHJ1ZSBpZiBjbGlja2luZyBhbnl3aGVyZSBpbnNpZGUgdGhlIHBvcG92ZXIgc2hvdWxkIGNsb3NlIGl0LiAqRGVmYXVsdHMgdG8gYGZhbHNlYC4qICovXG4gICAgQElucHV0KCkgYXV0b0Nsb3NlT25Db250ZW50Q2xpY2sgPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZC4gSWYgYGNvbnRleHRgIHdhcyBzZXQgb24gdGhlIGFuY2hvciwgaXQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhpcyBldmVudC4gKi9cbiAgICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gICAgQE91dHB1dCgpIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gICAgQE91dHB1dCgpIGFmdGVyT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGhhcyBmaW5pc2hlZCBjbG9zaW5nLiAqL1xuICAgIEBPdXRwdXQoKSBhZnRlckNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIGJhY2tkcm9wIGlzIGNsaWNrZWQuICovXG4gICAgQE91dHB1dCgpIGJhY2tkcm9wQ2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICAgIEBPdXRwdXQoKSBvdmVybGF5S2V5ZG93biA9IG5ldyBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD4oKTtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGVtcGxhdGUgc28gaXQgY2FuIGJlIHBsYWNlZCB3aXRoaW4gYSBwb3J0YWwuICovXG4gICAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZiwge3N0YXRpYzogZmFsc2V9KSBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogU3RvcmVzIHRoZSBjbGljayBjb29yZGluYXRlcyBmb3IgbW91c2UtYmFzZWQgcG9zaXRpb25pbmcgKi9cbiAgICBfb2Zmc2V0UG9zOiBudW1iZXJbXSA9IFswLCAwXTtcblxuICAgIC8qKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIGFzc29jaWF0ZWQgb3ZlcmxheSAqL1xuICAgIF9jb21wb25lbnRPdmVybGF5OiBPdmVybGF5UmVmO1xuXG4gICAgLyoqIENsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHBvcG92ZXIgZm9yIHNldHRpbmcgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbi4gKi9cbiAgICBfY2xhc3NMaXN0OiBhbnkgPSB7fTtcbiAgICBfeUFsaWduQ2xhc3MgPSAnJztcbiAgICBfeEFsaWduQ2xhc3MgPSAnJztcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICAgIF9vcGVuID0gZmFsc2U7XG5cbiAgICAvKiogSW5zdGFuY2Ugb2Ygbm90aWZpY2F0aW9uIHNlcnZpY2UuIFdpbGwgYmUgdW5kZWZpbmVkIHVudGlsIGF0dGFjaGVkIHRvIGFuIGFuY2hvci4gKi9cbiAgICBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJ1aWxkIGEgZm9jdXMgdHJhcCBhcm91bmQuICovXG4gICAgQFZpZXdDaGlsZCgnZm9jdXNUcmFwRWxlbWVudCcsIHtzdGF0aWM6IGZhbHNlfSlcbiAgICBwcml2YXRlIF9mb2N1c1RyYXBFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSBvcGVuaW5nLiAqL1xuICAgIHByaXZhdGUgX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byBhIGZvY3VzIHRyYXAgYXJvdW5kIHRoZSBwb3BvdmVyLiAqL1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcDogRm9jdXNUcmFwIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqIElmIHRoaXMgbWVudSBoYXMgY2hpbGRyZW4sIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbnkgb2YgdGhlbSBhcmUgb3BlbiAqL1xuICAgIHB1YmxpYyBfc3ViTWVudU9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gc3Vic2NyaXB0aW9uIG9mIHBhcmVudCBwb3BvdmVyIGNsb3NlIGV2ZW50cyAqL1xuICAgIHByaXZhdGUgX3BhcmVudENsb3NlOiBhbnkgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgLyoqIEJsb2NrIHRoaXMgcG9wb3ZlciBmcm9tIGNsb3NpbmcgaXRzIHBhcmVudCBvbiBjbG9zZSAqL1xuICAgIF9wYXJlbnRDbG9zZUJsb2NrOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIGhjTWVudUl0ZW1zIChpZiB0aGUgcG9wb3ZlciBjb250YWlucyB0aGVtKSAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oTWVudUl0ZW1EaXJlY3RpdmUsIHtkZXNjZW5kYW50czogdHJ1ZX0pIF9tZW51SXRlbXM6IFF1ZXJ5TGlzdDxNZW51SXRlbURpcmVjdGl2ZT47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5LFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55XG4gICAgKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX3NldEFsaWdubWVudENsYXNzZXMoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRDbG9zZS51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BvcENvbnRhaW5lckNsaWNrZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZU9uQ29udGVudENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogT3BlbiB0aGlzIHBvcG92ZXIuICovXG4gICAgb3BlbihvcHRpb25zOiBIY1BvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5PUEVOLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2UgdGhpcyBwb3BvdmVyIGFuZCBpdHMgcGFyZW50IChpZiBsaW5rZWQpLiAqL1xuICAgIGNsb3NlKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5DTE9TRSwgdmFsdWUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXRoaXMuX3BhcmVudENsb3NlQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3N1Yk1lbnVPcGVuID0gIXRoaXMuaXNPcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlRPR0dMRSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqIFJlYWxpZ24gdGhlIHBvcG92ZXIgdG8gdGhlIGFuY2hvci4gKi9cbiAgICByZWFsaWduKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVBTElHTik7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqIEdldHMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgICBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cblxuICAgIC8qKiBHZXRzIGFuIGFuaW1hdGlvbiBjb25maWcgd2l0aCBjdXN0b21pemVkIChvciBkZWZhdWx0KSB0cmFuc2l0aW9uIHZhbHVlcy4gKi9cbiAgICBfZ2V0QW5pbWF0aW9uKCk6IHt2YWx1ZTogYW55OyBwYXJhbXM6IGFueX0ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIG9wZW5UcmFuc2l0aW9uOiB0aGlzLnNob3VsZEFuaW1hdGUgPyB0aGlzLm9wZW5UcmFuc2l0aW9uIDogRU1QVFlfVFJBTlNJVElPTixcbiAgICAgICAgICAgICAgICBjbG9zZVRyYW5zaXRpb246IHRoaXMuc2hvdWxkQW5pbWF0ZSA/IHRoaXMuY2xvc2VUcmFuc2l0aW9uIDogRU1QVFlfVFJBTlNJVElPTlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgcG9wb3ZlciBpcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4gb3Igb3V0LiAqL1xuICAgIF9vbkFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYXBGb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5hZnRlck9wZW4uZW1pdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJDbG9zZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQXBwbHkgYWxpZ25tZW50IGNsYXNzZXMgYmFzZWQgb24gYWxpZ25tZW50IGlucHV0cy4gKi9cbiAgICBfc2V0QWxpZ25tZW50Q2xhc3Nlcyhob3JpekFsaWduID0gdGhpcy5ob3Jpem9udGFsQWxpZ24sIHZlcnRBbGlnbiA9IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzRm9yQW5pbWF0aW9uKGhvcml6QWxpZ24sIHZlcnRBbGlnbik7XG4gICAgICAgIHRoaXMuX3NldEFsaWdubWVudENsYXNzZXNGb3JBcnJvdygpO1xuICAgIH1cblxuICAgIF9zZXRBbGlnbm1lbnRDbGFzc2VzRm9yQW5pbWF0aW9uKGhvcml6QWxpZ24gPSB0aGlzLmhvcml6b250YWxBbGlnbiwgdmVydEFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnaGMtcG9wLWJlZm9yZSddID0gaG9yaXpBbGlnbiA9PT0gJ2JlZm9yZScgfHwgaG9yaXpBbGlnbiA9PT0gJ2VuZCc7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnaGMtcG9wLWFmdGVyJ10gPSBob3JpekFsaWduID09PSAnYWZ0ZXInIHx8IGhvcml6QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydoYy1wb3AtYWJvdmUnXSA9IHZlcnRBbGlnbiA9PT0gJ2Fib3ZlJyB8fCB2ZXJ0QWxpZ24gPT09ICdlbmQnO1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1iZWxvdyddID0gdmVydEFsaWduID09PSAnYmVsb3cnIHx8IHZlcnRBbGlnbiA9PT0gJ3N0YXJ0JztcblxuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1jZW50ZXInXSA9IGhvcml6QWxpZ24gPT09ICdjZW50ZXInIHx8IHZlcnRBbGlnbiA9PT0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgX3NldEFsaWdubWVudENsYXNzZXNGb3JBcnJvdyh4QWxpZ24gPSB0aGlzLmhvcml6b250YWxBbGlnbiwgeUFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnaGMtcG9wLXNob3ctYXJyb3cnXSA9XG4gICAgICAgICAgICAodGhpcy5zaG93QXJyb3cgJiZcbiAgICAgICAgICAgICAgICAoeEFsaWduID09PSAnc3RhcnQnIHx8IHhBbGlnbiA9PT0gJ2NlbnRlcicgfHwgeEFsaWduID09PSAnZW5kJykgJiZcbiAgICAgICAgICAgICAgICAoeUFsaWduID09PSAnYWJvdmUnIHx8IHlBbGlnbiA9PT0gJ2JlbG93JykpIHx8XG4gICAgICAgICAgICAoKHlBbGlnbiA9PT0gJ3N0YXJ0JyB8fCB5QWxpZ24gPT09ICdjZW50ZXInIHx8IHlBbGlnbiA9PT0gJ2VuZCcpICYmICh4QWxpZ24gPT09ICdiZWZvcmUnIHx8IHhBbGlnbiA9PT0gJ2FmdGVyJykpO1xuXG4gICAgICAgIHRoaXMuX3lBbGlnbkNsYXNzID0gdGhpcy5fY2xhc3NMaXN0WydoYy1wb3Atc2hvdy1hcnJvdyddID8gYGhjLXBvcC1hcnJvdy15LSR7eUFsaWdufWAgOiAnJztcbiAgICAgICAgdGhpcy5feEFsaWduQ2xhc3MgPSB0aGlzLl9jbGFzc0xpc3RbJ2hjLXBvcC1zaG93LWFycm93J10gPyBgaGMtcG9wLWFycm93LXgtJHt4QWxpZ259YCA6ICcnO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGZvY3VzIG9mIGFuIGhjTWVudSBiYXNlZCBvbiBhIGtleWJvYXJkIGFycm93IHByZXNzICovXG4gICAgX2tleUZvY3VzKGRvd25QcmVzczogYm9vbGVhbikge1xuICAgICAgICBsZXQgaXRlbUFycmF5ID0gdGhpcy5fbWVudUl0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKCFkb3duUHJlc3MpIHtcbiAgICAgICAgICAgIGl0ZW1BcnJheS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGFueSBpdGVtIGluIHRoZSBtZW51IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBhbmQgc2VsZWN0IHRoZSBuZXh0IChvciBwcmV2aW91cylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhaXRlbUFycmF5W2ldLnJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnaGMtZGl2aWRlcicpICYmICFpdGVtQXJyYXlbaV0ucmVmLm5hdGl2ZUVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtQXJyYXlbaV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbUFycmF5W2ldLnJlZi5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbSBpcyBmb2N1c2VkLCBzZWxlY3RlZCB0aGUgZmlyc3QgKG9yIGxhc3QpIGl0ZW0gdGhhdCBpc24ndCBhIGRpdmlkZXIgb3IgZGlzYWJsZWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghaXRlbUFycmF5W2ldLnJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnaGMtZGl2aWRlcicpICYmICFpdGVtQXJyYXlbaV0ucmVmLm5hdGl2ZUVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtQXJyYXlbaV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmVzdG9yZSBmb2N1cyB0byB0aGUgZWxlbWVudCBmb2N1c2VkIGJlZm9yZSB0aGUgcG9wb3ZlciBvcGVuZWQuIEFsc28gZGVzdHJveSB0cmFwLiAqL1xuICAgIF9yZXN0b3JlRm9jdXNBbmREZXN0cm95VHJhcCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcblxuICAgICAgICAvLyBNdXN0IGNoZWNrIGFjdGl2ZSBlbGVtZW50IGlzIGZvY3VzYWJsZSBmb3IgSUUgc2FrZVxuICAgICAgICBpZiAodG9Gb2N1cyAmJiAnZm9jdXMnIGluIHRvRm9jdXMgJiYgdGhpcy5yZXN0b3JlRm9jdXMgJiYgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQuICovXG4gICAgX3NhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNb3ZlIHRoZSBmb2N1cyBpbnNpZGUgdGhlIGZvY3VzIHRyYXAgYW5kIHJlbWVtYmVyIHdoZXJlIHRvIHJldHVybiBsYXRlci4gKi9cbiAgICBwcml2YXRlIF90cmFwRm9jdXMoKTogdm9pZCB7XG4gICAgICAgIC8vIFRoZXJlIHdvbid0IGJlIGEgZm9jdXMgdHJhcCBlbGVtZW50IGlmIHRoZSBjbG9zZSBhbmltYXRpb24gc3RhcnRzIGJlZm9yZSBvcGVuIGZpbmlzaGVzXG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZm9jdXNUcmFwRWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmF1dG9Gb2N1cyAmJiB0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLCBpZiBwb3NzaWJsZS4gKi9cbiAgICBwcml2YXRlIF9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnMuZGlzcGF0Y2gobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEaXNwYXRjaCBhIG5vdGlmaWNhdGlvbiB0byB0aGUgbm90aWZpY2F0aW9uIHNlcnZpY2UgYW5kIHRocm93IGlmIHVuYWJsZSB0by4gKi9cbiAgICBwcml2YXRlIF9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRVbmFuY2hvcmVkUG9wb3ZlckVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIGhvcml6b250YWxBbGlnbi4gKi9cbiAgICBwcml2YXRlIF92YWxpZGF0ZUhvcml6b250YWxBbGlnbihwb3M6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbik6IHZvaWQge1xuICAgICAgICBpZiAoVkFMSURfSE9SSVpfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKHBvcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgdmVydGljYWxBbGlnbi4gKi9cbiAgICBwcml2YXRlIF92YWxpZGF0ZVZlcnRpY2FsQWxpZ24ocG9zOiBIY1BvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZCB7XG4gICAgICAgIGlmIChWQUxJRF9WRVJUX0FMSUdOLmluZGV4T2YocG9zKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGdldEludmFsaWRWZXJ0aWNhbEFsaWduRXJyb3IocG9zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcm9sbCBzdHJhdGVneSBpcyBub3QgYSB2YWxpZCBzdHJhdGVneS4gKi9cbiAgICBwcml2YXRlIF92YWxpZGF0ZVNjcm9sbFN0cmF0ZWd5KHN0cmF0ZWd5OiBIY1BvcG92ZXJTY3JvbGxTdHJhdGVneSk6IHZvaWQge1xuICAgICAgICBpZiAoVkFMSURfU0NST0xMLmluZGV4T2Yoc3RyYXRlZ3kpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0SW52YWxpZFNjcm9sbFN0cmF0ZWd5RXJyb3Ioc3RyYXRlZ3kpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19