/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover-anchoring.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, NgZone, Optional } from '@angular/core';
import { ConnectionPositionPair, Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { takeUntil, take, filter, tap } from 'rxjs/operators';
import { PopoverNotificationService, NotificationAction } from './notification.service';
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() { }
if (false) {
    /** @type {?} */
    PopoverConfig.prototype.horizontalAlign;
    /** @type {?} */
    PopoverConfig.prototype.verticalAlign;
    /** @type {?} */
    PopoverConfig.prototype.hasBackdrop;
    /** @type {?} */
    PopoverConfig.prototype.backdropClass;
    /** @type {?} */
    PopoverConfig.prototype.scrollStrategy;
    /** @type {?} */
    PopoverConfig.prototype.forceAlignment;
    /** @type {?} */
    PopoverConfig.prototype.lockAlignment;
}
var HcPopoverAnchoringService = /** @class */ (function () {
    function HcPopoverAnchoringService(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    };
    /** Anchor a popover instance to a view and connection element. */
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.anchor = /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    function (popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = this._anchor._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._popoverOpen;
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.openPopover = /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._popover._componentOverlay = this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
            this._popover._savePreviouslyFocusedElement();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    function (value, neighborSubMenusAreOpen) {
        if (neighborSubMenusAreOpen === void 0) { neighborSubMenusAreOpen = false; }
        if (this._popover._componentOverlay) {
            this._saveClosedState(value, neighborSubMenusAreOpen);
            this._popover._componentOverlay.detach();
            this._popover._restoreFocusAndDestroyTrap();
        }
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        if (this._popover._componentOverlay) {
            /** @type {?} */
            var config = this._popover._componentOverlay.getConfig();
            /** @type {?} */
            var strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    };
    /** Get a reference to the anchor element. */
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    HcPopoverAnchoringService.prototype.getAnchorElement = /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    function () {
        return this._anchor._elementRef;
    };
    /** Apply behavior properties on the popover based on the open options. */
    /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._applyOpenOptions = /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    function (options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    };
    /** Create an overlay to be attached to the portal. */
    /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._createOverlay = /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    function () {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            var popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment
            };
            /** @type {?} */
            var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        else if (this._popover.horizontalAlign === 'mouse' || this._popover.verticalAlign === 'mouse') {
            /* If aligning to mouse clicks - adjust the strategy based on the most current click */
            this._overlayRef.updatePositionStrategy(this._getPositionStrategy(this._popover.horizontalAlign, this._popover.verticalAlign, this._popover.forceAlignment, this._popover.lockAlignment, this._anchor._elementRef));
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    };
    /** Removes the popover from the DOM. Does NOT update open state. */
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._destroyPopover = /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    };
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef
                .detachments()
                .pipe(take(1), takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._destroyPopover(); }));
        }
        else {
            this._destroyPopover();
        }
    };
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     */
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._subscribeToNotifications = /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events().subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.action) {
                case NotificationAction.OPEN:
                    _this.openPopover(event.value);
                    break;
                case NotificationAction.CLOSE:
                    _this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    _this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    _this._destroyPopoverOnceClosed();
                    break;
                case NotificationAction.REALIGN:
                    _this.realignPopoverToAnchor();
                    break;
            }
        }));
    };
    /** Close popover when backdrop is clicked. */
    /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._subscribeToBackdrop = /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .backdropClick()
            .pipe(tap((/**
         * @return {?}
         */
        function () { return _this._popover.backdropClicked.emit(); })), filter((/**
         * @return {?}
         */
        function () { return _this._popover.interactiveClose; })), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /** Close popover when escape keydown event occurs. */
    /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._subscribeToEscape = /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .keydownEvents()
            .pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this._popover.overlayKeydown.emit(event); })), filter((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.keyCode === ESCAPE; })), filter((/**
         * @return {?}
         */
        function () { return _this._popover.interactiveClose; })), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /** Set state back to closed when detached. */
    /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._subscribeToDetachments = /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef) {
            return;
        }
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this._saveClosedState(); }));
    };
    /** Save the opened state of the popover and emit. */
    /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._saveOpenedState = /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            if (this._popover.parent) {
                this._popover.parent._subMenuOpen = true;
            }
            this.popoverOpened.next();
            if (typeof this._context === 'undefined') {
                this._popover.opened.emit();
            }
            else {
                this._popover.opened.emit(this._context);
            }
        }
    };
    /** Save the closed state of the popover and emit. */
    /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._saveClosedState = /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @param {?=} neighborSubMenusAreOpen
     * @return {?}
     */
    function (value, neighborSubMenusAreOpen) {
        if (neighborSubMenusAreOpen === void 0) { neighborSubMenusAreOpen = false; }
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            if (this._popover.parent) {
                this._popover.parent._subMenuOpen = neighborSubMenusAreOpen;
            }
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    };
    /** Gets the text direction of the containing app. */
    /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._getDirection = /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    function () {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    };
    /** Create and return a config for creating the overlay. */
    /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._getOverlayConfig = /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    function (config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor._elementRef),
            // make it hard for users to shoot themselves in the foot by disabling backdrop if hover is the trigger
            hasBackdrop: anchor.trigger !== 'hover' ? config.hasBackdrop : false,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
            // disable pointer events for hover popovers to avoid potential flickering issues
            panelClass: anchor.trigger === 'hover' ? 'overlay-pointer-events' : ''
        });
    };
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges.pipe(takeUntil(this._onDestroy)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            // Position changes may occur outside the Angular zone
            _this._ngZone.run((/**
             * @return {?}
             */
            function () {
                _this._popover._setAlignmentClassesForAnimation(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
                _this._popover._setAlignmentClassesForArrow(getHPopAlignmentForArrow(change.connectionPair.overlayX, change.connectionPair.originX), getVPopAlignmentForArrow(change.connectionPair.overlayY, change.connectionPair.originY));
            }));
        }));
    };
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    };
    /** Create and return a position strategy based on config provided to the component instance. */
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._getPositionStrategy = /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        var targetPosition = getPosition(horizontalTarget, verticalTarget, this._popover._offsetPos);
        /** @type {?} */
        var positions = [targetPosition];
        /** @type {?} */
        var strategy = this._overlay
            .position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push.apply(positions, tslib_1.__spread(fallbacks));
        }
        return strategy.withPositions(positions);
    };
    /** Get fallback positions based around target alignments. */
    /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    HcPopoverAnchoringService.prototype._getFallbacks = /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    function (hTarget, vTarget) {
        var _this = this;
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        var possibleHorizontalAlignments = horizontalOverlapAllowed
            ? ['before', 'start', 'center', 'end', 'after', 'mouse']
            : ['before', 'after'];
        /** @type {?} */
        var possibleVerticalAlignments = verticalOverlapAllowed
            ? ['above', 'start', 'center', 'end', 'below', 'mouse']
            : ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        var fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
         * @param {?} h
         * @return {?}
         */
        function (h) {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                fallbacks.push(getPosition(h, v, _this._popover._offsetPos));
            }));
        }));
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    };
    HcPopoverAnchoringService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HcPopoverAnchoringService.ctorParameters = function () { return [
        { type: Overlay },
        { type: NgZone },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    return HcPopoverAnchoringService;
}());
export { HcPopoverAnchoringService };
if (false) {
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype.popoverClosed;
    /**
     * Reference to the overlay containing the popover component.
     * @type {?}
     */
    HcPopoverAnchoringService.prototype._overlayRef;
    /**
     * Reference to the target popover.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._popover;
    /**
     * Stores the context assigned to the popover
     * @type {?}
     */
    HcPopoverAnchoringService.prototype._context;
    /**
     * Reference to the view container for the popover template.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._viewContainerRef;
    /**
     * Reference to the anchor
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._anchor;
    /**
     * Reference to a template portal where the overlay will be attached.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._portal;
    /**
     * Communications channel with the popover.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._notifications;
    /**
     * Single subscription to notifications service events.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._notificationsSubscription;
    /**
     * Single subscription to position changes.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._positionChangeSubscription;
    /**
     * Whether the popover is presently open.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._popoverOpen;
    /**
     * Emits when the service is destroyed.
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._onDestroy;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    HcPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning
 * @param {?} hOverlay
 * @param {?} hOrigin
 * @return {?}
 */
function getHPopAlignmentForArrow(hOverlay, hOrigin) {
    if (hOverlay === hOrigin) {
        return hOverlay;
    }
    if (hOverlay === 'start') {
        return 'after';
    }
    if (hOverlay === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning.
 * @param {?} vOverlay
 * @param {?} vOrigin
 * @return {?}
 */
function getVPopAlignmentForArrow(vOverlay, vOrigin) {
    if (vOverlay === vOrigin && (vOverlay === 'top' || vOverlay === 'bottom')) {
        return vOverlay === 'top' ? 'start' : 'end';
    }
    if (vOverlay === 'top') {
        return 'below';
    }
    if (vOverlay === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to get a cdk position pair from HcPopover alignments.
 * @param {?} h
 * @param {?} v
 * @param {?} offset
 * @return {?}
 */
function getPosition(h, v, offset) {
    var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
    var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
    return new ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY }, offset[0], offset[1]);
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
        case 'mouse':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
        case 'mouse':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    var targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    var reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    var left = options.slice(0, targetIndex);
    /** @type {?} */
    var right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        /** @type {?} */
        var r = right.pop();
        if (r) {
            reordered.push(r);
        }
        /** @type {?} */
        var l = left.pop();
        if (l) {
            reordered.push(l);
        }
    }
    // Flush out right side
    while (right.length) {
        /** @type {?} */
        var r2 = right.pop();
        if (r2) {
            reordered.push(r2);
        }
    }
    // Flush out left side
    while (left.length) {
        /** @type {?} */
        var l2 = left.pop();
        if (l2) {
            reordered.push(l2);
        }
    }
    return reordered;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BoZWFsdGhjYXRhbHlzdC9jYXNobWVyZS8iLCJzb3VyY2VzIjpbImxpYi9wb3AvcG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQWEsVUFBVSxFQUFFLE1BQU0sRUFBYSxRQUFRLEVBQW1CLE1BQU0sZUFBZSxDQUFDO0FBQ3BHLE9BQU8sRUFDSCxzQkFBc0IsRUFHdEIsT0FBTyxFQUNQLGFBQWEsRUFJaEIsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUMsY0FBYyxFQUFZLE1BQU0sbUJBQW1CLENBQUM7QUFDNUQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNuRCxPQUFPLEVBQWUsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUs1RCxPQUFPLEVBQUMsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQzs7Ozs7O0FBT3RGLDRCQVFDOzs7SUFQRyx3Q0FBMEM7O0lBQzFDLHNDQUFzQzs7SUFDdEMsb0NBQXFCOztJQUNyQixzQ0FBc0I7O0lBQ3RCLHVDQUF3Qzs7SUFDeEMsdUNBQXdCOztJQUN4QixzQ0FBdUI7O0FBRzNCO0lBeUNJLG1DQUFvQixRQUFpQixFQUFVLE9BQWUsRUFBc0IsSUFBb0I7UUFBcEYsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUFVLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFBc0IsU0FBSSxHQUFKLElBQUksQ0FBZ0I7Ozs7UUF0Q3hHLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQUdwQyxrQkFB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LENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDckI7S0FDSjtJQUVELHVCQUF1QjtJQUN2QixPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUU7O1lBQ1gsRUFBRSxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUU7UUFDdEIsSUFBSSxFQUFFLEVBQUU7WUFDSixTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3RCO0tBQ0o7SUFFRCxzQkFBc0I7SUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFOztZQUNWLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ3JCLElBQUksRUFBRSxFQUFFO1lBQ0osU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN0QjtLQUNKO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RWxlbWVudFJlZiwgSW5qZWN0YWJsZSwgTmdab25lLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQ29ubmVjdGlvblBvc2l0aW9uUGFpcixcbiAgICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksXG4gICAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gICAgT3ZlcmxheSxcbiAgICBPdmVybGF5Q29uZmlnLFxuICAgIE92ZXJsYXlSZWYsXG4gICAgU2Nyb2xsU3RyYXRlZ3ksXG4gICAgVmVydGljYWxDb25uZWN0aW9uUG9zXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7RGlyZWN0aW9uYWxpdHksIERpcmVjdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtFU0NBUEV9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQge1RlbXBsYXRlUG9ydGFsfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7U3Vic2NyaXB0aW9uLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7dGFrZVVudGlsLCB0YWtlLCBmaWx0ZXIsIHRhcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge0hjUG9wQ29tcG9uZW50fSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7SGNQb3BvdmVySG9yaXpvbnRhbEFsaWduLCBIY1BvcG92ZXJWZXJ0aWNhbEFsaWduLCBIY1BvcG92ZXJTY3JvbGxTdHJhdGVneSwgSGNQb3BvdmVyT3Blbk9wdGlvbnN9IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQge1BvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlLCBOb3RpZmljYXRpb25BY3Rpb259IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHtIY1BvcG92ZXJBbmNob3JEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9wb3BvdmVyLWFuY2hvci5kaXJlY3RpdmUnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gcHJvdmlkZWQgYnkgdGhlIHBvcG92ZXIgZm9yIHRoZSBhbmNob3Jpbmcgc2VydmljZVxuICogdG8gYnVpbGQgdGhlIGNvcnJlY3Qgb3ZlcmxheSBjb25maWcuXG4gKi9cbmludGVyZmFjZSBQb3BvdmVyQ29uZmlnIHtcbiAgICBob3Jpem9udGFsQWxpZ246IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbjtcbiAgICB2ZXJ0aWNhbEFsaWduOiBIY1BvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICAgIGhhc0JhY2tkcm9wOiBib29sZWFuO1xuICAgIGJhY2tkcm9wQ2xhc3M6IHN0cmluZztcbiAgICBzY3JvbGxTdHJhdGVneTogSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3k7XG4gICAgZm9yY2VBbGlnbm1lbnQ6IGJvb2xlYW47XG4gICAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhjUG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZC4gKi9cbiAgICBwb3BvdmVyT3BlbmVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgICBwb3BvdmVyQ2xvc2VkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgY29udGFpbmluZyB0aGUgcG9wb3ZlciBjb21wb25lbnQuICovXG4gICAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWYgfCBudWxsO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gICAgcHJpdmF0ZSBfcG9wb3ZlcjogSGNQb3BDb21wb25lbnQ7XG5cbiAgICAvKiogU3RvcmVzIHRoZSBjb250ZXh0IGFzc2lnbmVkIHRvIHRoZSBwb3BvdmVyICovXG4gICAgX2NvbnRleHQ6IGFueTtcblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHZpZXcgY29udGFpbmVyIGZvciB0aGUgcG9wb3ZlciB0ZW1wbGF0ZS4gKi9cbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgYW5jaG9yICovXG4gICAgcHJpdmF0ZSBfYW5jaG9yOiBIY1BvcG92ZXJBbmNob3JEaXJlY3RpdmU7XG5cbiAgICAvKiogUmVmZXJlbmNlIHRvIGEgdGVtcGxhdGUgcG9ydGFsIHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgYmUgYXR0YWNoZWQuICovXG4gICAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDxhbnk+O1xuXG4gICAgLyoqIENvbW11bmljYXRpb25zIGNoYW5uZWwgd2l0aCB0aGUgcG9wb3Zlci4gKi9cbiAgICBwcml2YXRlIF9ub3RpZmljYXRpb25zOiBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZTtcblxuICAgIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIG5vdGlmaWNhdGlvbnMgc2VydmljZSBldmVudHMuICovXG4gICAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gcG9zaXRpb24gY2hhbmdlcy4gKi9cbiAgICBwcml2YXRlIF9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgcHJpdmF0ZSBfcG9wb3Zlck9wZW4gPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBzZXJ2aWNlIGlzIGRlc3Ryb3llZC4gKi9cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHkpIHt9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgLy8gRGVzdHJveSBwb3BvdmVyIGJlZm9yZSB0ZXJtaW5hdGluZyBzdWJzY3JpcHRpb25zIHNvIHRoYXQgYW55IHJlc3VsdGluZ1xuICAgICAgICAvLyBkZXRhY2htZW50cyB1cGRhdGUgJ2Nsb3NlZCBzdGF0ZSdcbiAgICAgICAgdGhpcy5fZGVzdHJveVBvcG92ZXIoKTtcblxuICAgICAgICAvLyBUZXJtaW5hdGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcblxuICAgICAgICB0aGlzLnBvcG92ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5wb3BvdmVyQ2xvc2VkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEFuY2hvciBhIHBvcG92ZXIgaW5zdGFuY2UgdG8gYSB2aWV3IGFuZCBjb25uZWN0aW9uIGVsZW1lbnQuICovXG4gICAgYW5jaG9yKHBvcG92ZXI6IEhjUG9wQ29tcG9uZW50LCB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLCBhbmNob3I6IEhjUG9wb3ZlckFuY2hvckRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICAvLyBEZXN0cm95IGFueSBwcmV2aW91cyBwb3BvdmVyc1xuICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgICAgIC8vIEFzc2lnbiBsb2NhbCByZWZzXG4gICAgICAgIHRoaXMuX3BvcG92ZXIgPSBwb3BvdmVyO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gYW5jaG9yO1xuXG4gICAgICAgIC8vIFByb3ZpZGUgbm90aWZpY2F0aW9uIHNlcnZpY2UgYXMgYSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgYmV0d2VlbiBwb3BvdmVyIGFuZCBhbmNob3IuXG4gICAgICAgIC8vIFRoZW4gc3Vic2NyaWJlIHRvIG5vdGlmaWNhdGlvbnMgdG8gdGFrZSBhcHByb3ByaWF0ZSBhY3Rpb25zLlxuICAgICAgICB0aGlzLl9wb3BvdmVyLl9ub3RpZmljYXRpb25zID0gdGhpcy5fbm90aWZpY2F0aW9ucyA9IHRoaXMuX2FuY2hvci5fbm90aWZpY2F0aW9ucyA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb05vdGlmaWNhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICAgIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbjtcbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMuY2xvc2VQb3BvdmVyKCkgOiB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgfVxuXG4gICAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xuICAgIG9wZW5Qb3BvdmVyKG9wdGlvbnM6IEhjUG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlPcGVuT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX2NvbXBvbmVudE92ZXJsYXkgPSB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0VzY2FwZSgpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2htZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fc2F2ZU9wZW5lZFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2xvc2VzIHRoZSBwb3BvdmVyLiAqL1xuICAgIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSwgbmVpZ2hib3JTdWJNZW51c0FyZU9wZW46IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fcG9wb3Zlci5fY29tcG9uZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZUNsb3NlZFN0YXRlKHZhbHVlLCBuZWlnaGJvclN1Yk1lbnVzQXJlT3Blbik7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9jb21wb25lbnRPdmVybGF5LmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5fcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gICAgcmVhbGlnblBvcG92ZXJUb0FuY2hvcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXIuX2NvbXBvbmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX3BvcG92ZXIuX2NvbXBvbmVudE92ZXJsYXkuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbiAgICAgICAgICAgIHN0cmF0ZWd5LnJlYXBwbHlMYXN0UG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICAgIGdldEFuY2hvckVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3IuX2VsZW1lbnRSZWY7XG4gICAgfVxuXG4gICAgLyoqIEFwcGx5IGJlaGF2aW9yIHByb3BlcnRpZXMgb24gdGhlIHBvcG92ZXIgYmFzZWQgb24gdGhlIG9wZW4gb3B0aW9ucy4gKi9cbiAgICBwcml2YXRlIF9hcHBseU9wZW5PcHRpb25zKG9wdGlvbnM6IEhjUG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgICAgIC8vIE9ubHkgb3ZlcnJpZGUgcmVzdG9yZUZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICAgICAgY29uc3QgcmVzdG9yZUZvY3VzID0gb3B0aW9ucy5yZXN0b3JlRm9jdXMgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgICAgICAvLyBPbmx5IG92ZXJyaWRlIGF1dG9Gb2N1cyBhcyBgZmFsc2VgIGlmIHRoZSBvcHRpb24gaXMgZXhwbGljaXRseSBgZmFsc2VgXG4gICAgICAgIGNvbnN0IGF1dG9Gb2N1cyA9IG9wdGlvbnMuYXV0b0ZvY3VzICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBvdmVybGF5IHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBwb3J0YWwuICovXG4gICAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAgICAgLy8gQ3JlYXRlIG92ZXJsYXkgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5fcG9wb3Zlci5fdGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuXG4gICAgICAgICAgICBjb25zdCBwb3BvdmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbjogdGhpcy5fcG9wb3Zlci5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgIGhhc0JhY2tkcm9wOiB0aGlzLl9wb3BvdmVyLmhhc0JhY2tkcm9wLFxuICAgICAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGFzcyxcbiAgICAgICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgICAgICAgICBmb3JjZUFsaWdubWVudDogdGhpcy5fcG9wb3Zlci5mb3JjZUFsaWdubWVudCxcbiAgICAgICAgICAgICAgICBsb2NrQWxpZ25tZW50OiB0aGlzLl9wb3BvdmVyLmxvY2tBbGlnbm1lbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKG92ZXJsYXlDb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpO1xuXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcG9wb3Zlci5ob3Jpem9udGFsQWxpZ24gPT09ICdtb3VzZScgfHwgdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAvKiBJZiBhbGlnbmluZyB0byBtb3VzZSBjbGlja3MgLSBhZGp1c3QgdGhlIHN0cmF0ZWd5IGJhc2VkIG9uIHRoZSBtb3N0IGN1cnJlbnQgY2xpY2sgKi9cbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb25TdHJhdGVneShcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmZvcmNlQWxpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmxvY2tBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuY2hvci5fZWxlbWVudFJlZlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxseSBvcGVuIHRoZSBwb3BvdmVyXG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgIH1cblxuICAgIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gICAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHBvcG92ZXIgaW1tZWRpYXRlbHkgaWYgaXQgaXMgY2xvc2VkLCBvciB3YWl0cyB1bnRpbCBpdFxuICAgICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyT25jZUNsb3NlZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQb3BvdmVyT3BlbigpICYmIHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgICAgICAgICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgICAgICAgICAgIC5waXBlKHRha2UoMSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZGVzdHJveVBvcG92ZXIoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhcHByb3ByaWF0ZSBhbmNob3IgbWV0aG9kIHdoZW4gYW4gZXZlbnQgaXMgZGlzcGF0Y2hlZCB0aHJvdWdoXG4gICAgICogdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvTm90aWZpY2F0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9ub3RpZmljYXRpb25zLmV2ZW50cygpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLk9QRU46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5DTE9TRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5UT0dHTEU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5VUERBVEVfQ09ORklHOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uUkVBTElHTjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2UgcG9wb3ZlciB3aGVuIGJhY2tkcm9wIGlzIGNsaWNrZWQuICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZlxuICAgICAgICAgICAgLmJhY2tkcm9wQ2xpY2soKVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3BvcG92ZXIuaW50ZXJhY3RpdmVDbG9zZSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Fc2NhcGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgICAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHRhcChldmVudCA9PiB0aGlzLl9wb3BvdmVyLm92ZXJsYXlLZXlkb3duLmVtaXQoZXZlbnQpKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgICB9XG5cbiAgICAvKiogU2V0IHN0YXRlIGJhY2sgdG8gY2xvc2VkIHdoZW4gZGV0YWNoZWQuICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZlxuICAgICAgICAgICAgLmRldGFjaG1lbnRzKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zYXZlQ2xvc2VkU3RhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgdGhlIG9wZW5lZCBzdGF0ZSBvZiB0aGUgcG9wb3ZlciBhbmQgZW1pdC4gKi9cbiAgICBwcml2YXRlIF9zYXZlT3BlbmVkU3RhdGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fcG9wb3Zlck9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX29wZW4gPSB0aGlzLl9wb3BvdmVyT3BlbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIHRoaXMuX3BvcG92ZXIucGFyZW50ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIucGFyZW50Ll9zdWJNZW51T3BlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9wb3Zlck9wZW5lZC5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BvdmVyLm9wZW5lZC5lbWl0KHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgdGhlIGNsb3NlZCBzdGF0ZSBvZiB0aGUgcG9wb3ZlciBhbmQgZW1pdC4gKi9cbiAgICBwcml2YXRlIF9zYXZlQ2xvc2VkU3RhdGUodmFsdWU/OiBhbnksIG5laWdoYm9yU3ViTWVudXNBcmVPcGVuOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICggdGhpcy5fcG9wb3Zlci5wYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5wYXJlbnQuX3N1Yk1lbnVPcGVuID0gbmVpZ2hib3JTdWJNZW51c0FyZU9wZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXJDbG9zZWQubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmNsb3NlZC5lbWl0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gICAgcHJpdmF0ZSBfZ2V0RGlyZWN0aW9uKCk6IERpcmVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbmQgcmV0dXJuIGEgY29uZmlnIGZvciBjcmVhdGluZyB0aGUgb3ZlcmxheS4gKi9cbiAgICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBIY1BvcG92ZXJBbmNob3JEaXJlY3RpdmUpOiBPdmVybGF5Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2dldFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgICAgICAgICAgY29uZmlnLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgICAgICAgICBjb25maWcudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICBjb25maWcuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgY29uZmlnLmxvY2tBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgYW5jaG9yLl9lbGVtZW50UmVmXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gbWFrZSBpdCBoYXJkIGZvciB1c2VycyB0byBzaG9vdCB0aGVtc2VsdmVzIGluIHRoZSBmb290IGJ5IGRpc2FibGluZyBiYWNrZHJvcCBpZiBob3ZlciBpcyB0aGUgdHJpZ2dlclxuICAgICAgICAgICAgaGFzQmFja2Ryb3A6IGFuY2hvci50cmlnZ2VyICE9PSAnaG92ZXInID8gY29uZmlnLmhhc0JhY2tkcm9wIDogZmFsc2UsXG5cbiAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzIHx8ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShjb25maWcuc2Nyb2xsU3RyYXRlZ3kpLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb24oKSxcblxuICAgICAgICAgICAgLy8gZGlzYWJsZSBwb2ludGVyIGV2ZW50cyBmb3IgaG92ZXIgcG9wb3ZlcnMgdG8gYXZvaWQgcG90ZW50aWFsIGZsaWNrZXJpbmcgaXNzdWVzXG4gICAgICAgICAgICBwYW5lbENsYXNzOiBhbmNob3IudHJpZ2dlciA9PT0gJ2hvdmVyJyA/ICdvdmVybGF5LXBvaW50ZXItZXZlbnRzJyA6ICcnXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBhbmQgc2V0IHRoZSBjb3JyZWN0IGFsaWdubWVudCBjbGFzc2VzLFxuICAgICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgY29ycmVjdCwgZXZlbiB3aXRoIGEgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Qb3NpdGlvbkNoYW5nZXMocG9zaXRpb246IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHBvc2l0aW9uLnBvc2l0aW9uQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGNoYW5nZXMgbWF5IG9jY3VyIG91dHNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2V0QWxpZ25tZW50Q2xhc3Nlc0ZvckFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZ2V0SG9yaXpvbnRhbFBvcG92ZXJBbGlnbm1lbnQoY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlYKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmVydGljYWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX3NldEFsaWdubWVudENsYXNzZXNGb3JBcnJvdyhcbiAgICAgICAgICAgICAgICAgICAgZ2V0SFBvcEFsaWdubWVudEZvckFycm93KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCwgY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblgpLFxuICAgICAgICAgICAgICAgICAgICBnZXRWUG9wQWxpZ25tZW50Rm9yQXJyb3coY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZLCBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3JpZ2luWSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBNYXAgYSBzY3JvbGwgc3RyYXRlZ3kgc3RyaW5nIHR5cGUgdG8gYW4gaW5zdGFuY2Ugb2YgYSBzY3JvbGwgc3RyYXRlZ3kuICovXG4gICAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShzdHJhdGVneTogSGNQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kpOiBTY3JvbGxTdHJhdGVneSB7XG4gICAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmJsb2NrKCk7XG4gICAgICAgICAgICBjYXNlICdyZXBvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG4gICAgICAgICAgICBjYXNlICdub29wJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ub29wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBwb3NpdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBjb25maWcgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbiAgICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgICAgICBob3Jpem9udGFsVGFyZ2V0OiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgICAgIHZlcnRpY2FsVGFyZ2V0OiBIY1BvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICAgICAgICBmb3JjZUFsaWdubWVudDogYm9vbGVhbixcbiAgICAgICAgbG9ja0FsaWdubWVudDogYm9vbGVhbixcbiAgICAgICAgYW5jaG9yOiBFbGVtZW50UmVmXG4gICAgKTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBvdmVybGF5IGF0IHRoZSBwcmVmZXJyZWQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCwgdGhpcy5fcG9wb3Zlci5fb2Zmc2V0UG9zKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW3RhcmdldFBvc2l0aW9uXTtcblxuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuX292ZXJsYXlcbiAgICAgICAgICAgIC5wb3NpdGlvbigpXG4gICAgICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhhbmNob3IpXG4gICAgICAgICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgICAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgICAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oMClcbiAgICAgICAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24obG9ja0FsaWdubWVudCk7XG5cbiAgICAgICAgLy8gVW5sZXNzIHRoZSBhbGlnbm1lbnQgaXMgZm9yY2VkLCBhZGQgZmFsbGJhY2tzIGJhc2VkIG9uIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zXG4gICAgICAgIGlmICghZm9yY2VBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuX2dldEZhbGxiYWNrcyhob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCguLi5mYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LndpdGhQb3NpdGlvbnMocG9zaXRpb25zKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGZhbGxiYWNrIHBvc2l0aW9ucyBiYXNlZCBhcm91bmQgdGFyZ2V0IGFsaWdubWVudHMuICovXG4gICAgcHJpdmF0ZSBfZ2V0RmFsbGJhY2tzKGhUYXJnZXQ6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbiwgdlRhcmdldDogSGNQb3BvdmVyVmVydGljYWxBbGlnbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFyZ2V0IGFsaWdubWVudHMgb3ZlcmxhcCB0aGUgYW5jaG9yXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxPdmVybGFwQWxsb3dlZCA9IGhUYXJnZXQgIT09ICdiZWZvcmUnICYmIGhUYXJnZXQgIT09ICdhZnRlcic7XG4gICAgICAgIGNvbnN0IHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWQgPSB2VGFyZ2V0ICE9PSAnYWJvdmUnICYmIHZUYXJnZXQgIT09ICdiZWxvdyc7XG5cbiAgICAgICAgLy8gSWYgYSB0YXJnZXQgYWxpZ25tZW50IGRvZXNuJ3QgY292ZXIgdGhlIGFuY2hvciwgZG9uJ3QgbGV0IGFueSBvZiB0aGUgZmFsbGJhY2sgYWxpZ25tZW50c1xuICAgICAgICAvLyBjb3ZlciB0aGUgYW5jaG9yXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHM6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbltdID0gaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkXG4gICAgICAgICAgICA/IFsnYmVmb3JlJywgJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYWZ0ZXInLCAnbW91c2UnXVxuICAgICAgICAgICAgOiBbJ2JlZm9yZScsICdhZnRlciddO1xuICAgICAgICBjb25zdCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50czogSGNQb3BvdmVyVmVydGljYWxBbGlnbltdID0gdmVydGljYWxPdmVybGFwQWxsb3dlZFxuICAgICAgICAgICAgPyBbJ2Fib3ZlJywgJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYmVsb3cnLCAnbW91c2UnXVxuICAgICAgICAgICAgOiBbJ2Fib3ZlJywgJ2JlbG93J107XG5cbiAgICAgICAgLy8gQ3JlYXRlIGZhbGxiYWNrcyBmb3IgZWFjaCBhbGxvd2VkIHByaW9yaXRpemVkIGZhbGxiYWNrIGFsaWdubWVudCBjb21ib1xuICAgICAgICBjb25zdCBmYWxsYmFja3M6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KGhUYXJnZXQsIHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHMpLmZvckVhY2goaCA9PiB7XG4gICAgICAgICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KHZUYXJnZXQsIHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrcy5wdXNoKGdldFBvc2l0aW9uKGgsIHYsIHRoaXMuX3BvcG92ZXIuX29mZnNldFBvcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCB3aWxsIGJlIHRoZSB0YXJnZXQgYWxpZ25tZW50IGFuZCBpc24ndCBjb25zaWRlcmVkIGEgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrcy5zbGljZSgxLCBmYWxsYmFja3MubGVuZ3RoKTtcbiAgICB9XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudCBmb3IgYXJyb3cgcG9zaXRpb25pbmcgKi9cbmZ1bmN0aW9uIGdldEhQb3BBbGlnbm1lbnRGb3JBcnJvdyhoT3ZlcmxheTogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsIGhPcmlnaW46IEhvcml6b250YWxDb25uZWN0aW9uUG9zKTogSGNQb3BvdmVySG9yaXpvbnRhbEFsaWduIHtcbiAgICBpZiAoaE92ZXJsYXkgPT09IGhPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIGhPdmVybGF5O1xuICAgIH1cblxuICAgIGlmIChoT3ZlcmxheSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICByZXR1cm4gJ2FmdGVyJztcbiAgICB9XG5cbiAgICBpZiAoaE92ZXJsYXkgPT09ICdlbmQnKSB7XG4gICAgICAgIHJldHVybiAnYmVmb3JlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudCBmb3IgYXJyb3cgcG9zaXRpb25pbmcuICovXG5mdW5jdGlvbiBnZXRWUG9wQWxpZ25tZW50Rm9yQXJyb3codk92ZXJsYXk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcywgdk9yaWdpbjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogSGNQb3BvdmVyVmVydGljYWxBbGlnbiB7XG4gICAgaWYgKHZPdmVybGF5ID09PSB2T3JpZ2luICYmICh2T3ZlcmxheSA9PT0gJ3RvcCcgfHwgdk92ZXJsYXkgPT09ICdib3R0b20nKSkge1xuICAgICAgICByZXR1cm4gdk92ZXJsYXkgPT09ICd0b3AnID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgIH1cblxuICAgIGlmICh2T3ZlcmxheSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcmV0dXJuICdiZWxvdyc7XG4gICAgfVxuXG4gICAgaWYgKHZPdmVybGF5ID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gJ2Fib3ZlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgY2RrIHBvc2l0aW9uIHBhaXIgZnJvbSBIY1BvcG92ZXIgYWxpZ25tZW50cy4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGg6IEhjUG9wb3Zlckhvcml6b250YWxBbGlnbiwgdjogSGNQb3BvdmVyVmVydGljYWxBbGlnbiwgb2Zmc2V0OiBudW1iZXJbXSk6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICAgIGNvbnN0IHtvcmlnaW5YLCBvdmVybGF5WH0gPSBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaCk7XG4gICAgY29uc3Qge29yaWdpblksIG92ZXJsYXlZfSA9IGdldFZlcnRpY2FsQ29ubmVjdGlvblBvc1BhaXIodik7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHtvcmlnaW5YLCBvcmlnaW5ZfSwge292ZXJsYXlYLCBvdmVybGF5WX0sIG9mZnNldFswXSwgb2Zmc2V0WzFdKTtcbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIG92ZXJsYXkgY29ubmVjdGlvbiBwb3NpdGlvbiB0byBlcXVpdmFsZW50IHBvcG92ZXIgYWxpZ25tZW50LiAqL1xuZnVuY3Rpb24gZ2V0SG9yaXpvbnRhbFBvcG92ZXJBbGlnbm1lbnQoaDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MpOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ24ge1xuICAgIGlmIChoID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHJldHVybiAnYWZ0ZXInO1xuICAgIH1cblxuICAgIGlmIChoID09PSAnZW5kJykge1xuICAgICAgICByZXR1cm4gJ2JlZm9yZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQodjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogSGNQb3BvdmVyVmVydGljYWxBbGlnbiB7XG4gICAgaWYgKHYgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiAnYmVsb3cnO1xuICAgIH1cblxuICAgIGlmICh2ID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gJ2Fib3ZlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbGlnbm1lbnQgdG8gb3JpZ2luL292ZXJsYXkgcG9zaXRpb24gcGFpci4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxDb25uZWN0aW9uUG9zUGFpcihcbiAgICBoOiBIY1BvcG92ZXJIb3Jpem9udGFsQWxpZ25cbik6IHtvcmlnaW5YOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvczsgb3ZlcmxheVg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zfSB7XG4gICAgc3dpdGNoIChoKSB7XG4gICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblg6ICdzdGFydCcsIG92ZXJsYXlYOiAnZW5kJ307XG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgY2FzZSAnbW91c2UnOlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnc3RhcnQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblg6ICdjZW50ZXInLCBvdmVybGF5WDogJ2NlbnRlcid9O1xuICAgIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFsaWdubWVudCB0byBvcmlnaW4vb3ZlcmxheSBwb3NpdGlvbiBwYWlyLiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2OiBIY1BvcG92ZXJWZXJ0aWNhbEFsaWduKToge29yaWdpblk6IFZlcnRpY2FsQ29ubmVjdGlvblBvczsgb3ZlcmxheVk6IFZlcnRpY2FsQ29ubmVjdGlvblBvc30ge1xuICAgIHN3aXRjaCAodikge1xuICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAndG9wJ307XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICByZXR1cm4ge29yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WTogJ3RvcCd9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnY2VudGVyJywgb3ZlcmxheVk6ICdjZW50ZXInfTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JkZXJlZCBhcnJheSBvcHRpb25zIGFuZCByZXR1cm5zIGEgcmVvcmRlcmRlZFxuICogYXJyYXkgYXJvdW5kIHRoZSB0YXJnZXQgaXRlbS4gZS5nLjpcbiAqXG4gKiB0YXJnZXQ6IDM7IG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAqXG4gKiByZXR1cm46IFszLCA0LCAyLCA1LCAxLCA2LCA3XVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplQXJvdW5kVGFyZ2V0PFQ+KHRhcmdldDogVCwgb3B0aW9uczogVFtdKTogVFtdIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgLy8gU2V0IHRoZSBmaXJzdCBpdGVtIHRvIGJlIHRoZSB0YXJnZXRcbiAgICBjb25zdCByZW9yZGVyZWQgPSBbdGFyZ2V0XTtcblxuICAgIC8vIE1ha2UgbGVmdCBhbmQgcmlnaHQgc3RhY2tzIHdoZXJlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGl0ZW0gaXMgbGFzdFxuICAgIGNvbnN0IGxlZnQgPSBvcHRpb25zLnNsaWNlKDAsIHRhcmdldEluZGV4KTtcbiAgICBjb25zdCByaWdodCA9IG9wdGlvbnMuc2xpY2UodGFyZ2V0SW5kZXggKyAxLCBvcHRpb25zLmxlbmd0aCkucmV2ZXJzZSgpO1xuXG4gICAgLy8gQWx0ZXJuYXRlIGJldHdlZW4gc3RhY2tzIHVudGlsIG9uZSBpcyBlbXB0eVxuICAgIHdoaWxlIChsZWZ0Lmxlbmd0aCAmJiByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgciA9IHJpZ2h0LnBvcCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmVvcmRlcmVkLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbCA9IGxlZnQucG9wKCk7XG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICByZW9yZGVyZWQucHVzaChsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsdXNoIG91dCByaWdodCBzaWRlXG4gICAgd2hpbGUgKHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByMiA9IHJpZ2h0LnBvcCgpO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHJlb3JkZXJlZC5wdXNoKHIyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsdXNoIG91dCBsZWZ0IHNpZGVcbiAgICB3aGlsZSAobGVmdC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbDIgPSBsZWZ0LnBvcCgpO1xuICAgICAgICBpZiAobDIpIHtcbiAgICAgICAgICAgIHJlb3JkZXJlZC5wdXNoKGwyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW9yZGVyZWQ7XG59XG4iXX0=